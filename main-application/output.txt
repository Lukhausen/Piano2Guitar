audio/
chord-factory/
  chordfactory.js
  chordrating.js
  chordvoicing.js
  constants.js
  main.js
  utils.js
chord-library/
  script.js
createChatGPTContext.js
drag-drop/
  script.js
index.html
midi-integration/
  index.html
  script.js
piano/
  script.js
progression-generator/
  main.js
script.js
svg/
tab-generator/
  index.html
  script.js

File: chordfactory.js

import { STANDARD_TUNING, NOTE_INDEX_MAP, TUNING, FINGER_FRET_RANGE, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordVoicing } from './chordvoicing.js';


export class ChordFactory {
  constructor(notes, root, startWithRoot = true, tuning = TUNING) {
    console.log("ChordFactory Recieved Notes: ", notes)
    this.notes = notes;
    this.startWithRoot = startWithRoot
    this.root = root
    this.tuning = tuning;
    this.fingerPositions = this.calculateFingerPositions();
    this.allChords = this.generateAllChordCombinations()
    this.playableChords = this.filterPlayableChords(this.allChords)
    this.sortPlayableChordsByCombinedRating(1)
  }

  calculateFingerPositions() {
    const fingerPositions = [];
  
    for (let stringIndex of this.tuning) {
      const positions = [];
      for (let chordIndex of this.notes) {
        const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12);
        positions.push(...validPositions);
      }
      positions.push(-1); // Add -1 once for each string index
      positions.sort((a, b) => a - b); // Sort the positions from lowest to highest
      fingerPositions.push(positions);
    }
  
    return fingerPositions;
  }
  
  getValidFretPositionsForNote(noteIndex, stringIndex) {
    const baseFret = (noteIndex - stringIndex +120) % 12;
    return [baseFret, baseFret + 12];
  }

  cartesianProduct(arrays) {
    return arrays.reduce((acc, curr) => {
      return acc.flatMap(a => curr.map(b => [...a, b]));
    }, [[]]);
  }

  generateAllChordCombinations() {
    const chords = [];
    // All 12 Frets
    for (let startFret = 0; startFret <= 12; startFret++) {
      let positionsInRange = []
      let endFret = startFret + FINGER_FRET_RANGE - 1
      for (let string = 0; string < 6; string++) {
        let possibleStringPlacements = []
        //Push -1 to every String Because it could be muted
        possibleStringPlacements.push(-1)
        // As The First Index of The this.fingerPositions[string] String Array ALLWAYS is 1 -1, we can skip it and add it separately
        //THis is why we start a t 1
        for (let finger = 1; finger < this.fingerPositions[string].length; finger++) {
          // As the this.fingerPositions[string][finger] Array is sorted, we can break out, once we hit a higher position than endFret
          if (this.fingerPositions[string][finger] > endFret) {
            break;
          } else if (this.fingerPositions[string][finger] == endFret) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
            break;
          } else if (this.fingerPositions[string][finger] >= startFret) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
          } else if (this.fingerPositions[string][finger] == 0) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
          }
        }
        positionsInRange[string] = possibleStringPlacements
      }
      chords.push(...this.cartesianProduct(positionsInRange))

    }

    return chords;
  }


  filterPlayableChords(allChords) {
    const playableChords = allChords.map(voicing => {
      if (this.startWithRoot) {
        for (let string = 0; string <= 5; string++) {
          if (voicing[string] == -1) {
            continue;
          }
          else if (((voicing[string] + this.tuning[string]) % 12) == this.root) {
            voicing[string] = -1;
          } else {
            break;
          }
        }
      }

      //Faster Way to Calculate the MinaboveZero
      let minAboveZero = Infinity;

      for (let i = 0; i < voicing.length; i++) {
        if (voicing[i] > 0 && voicing[i] < minAboveZero) {
          minAboveZero = voicing[i];
        }
      }

      if (minAboveZero === Infinity) {
        minAboveZero = 0;
      }


      let fingersUsed = 0;
      let barreStop = false;
      let barreUseFingers = 0;
      let barreAddFingers = 0;
      for (let i = 5; i >= 0; i--) {
        if (voicing[i] <= 0) {
          barreStop = true;
        }
        if (voicing[i] >= minAboveZero && barreStop == false) {
          barreUseFingers++;
          if (voicing[i] > minAboveZero) {
            barreAddFingers++;
          }
        } else if (voicing[i] > 0 && voicing[i] !== "x") {
          barreAddFingers++;
        }
      }
      if (barreUseFingers)
        if (barreUseFingers >= 2 && barreAddFingers > 3) {
          return null;
        } else if (barreUseFingers < 2) {
          fingersUsed = voicing.filter(fret => fret >= minAboveZero).length;
          barreUseFingers = 0
        }
      if (fingersUsed <= 4) {
        let newVoicing = new ChordVoicing(voicing, barreUseFingers > 0 ? minAboveZero : null, barreUseFingers > 0 ? barreAddFingers : fingersUsed, barreUseFingers, minAboveZero, this.notes, this.startWithRoot ? this.root : -1)

        return newVoicing;
      }
      return null;
    }
    ).filter(chordVoicing => chordVoicing !== null);
    return removeDuplicateArrays(playableChords);
  }

  sortPlayableChordsByRating() {
    this.playableChords.sort((a, b) => a.rating - b.rating);
  }

  /**
   * Sorts the playable chords by a combined rating based on sound quality and 
   * playability. The combined rating is calculated using a weighted sum of 
   * the sound quality rating and the playability rating.
   * 
   * @param {number} soundWeight - A value between 0 and 1 that determines the weight 
   * given to the sound quality rating. The weight given to the playability rating 
   * will be (1 - soundWeight).
   * 
   * Usage example:
   * ```javascript
   * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning);
   * chordFactory.sortPlayableChordsByCombinedRating(0.7);
   * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating
   * ```
   * 
   * @throws {Error} If `soundWeight` is not a number between 0 and 1.
   */
  sortPlayableChordsByCombinedRating(soundWeight = 0) {
    if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) {
      throw new Error("soundWeight must be a number between 0 and 1.");
    }
    console.log("Sorting...")
    this.playableChords.sort((a, b) => {
      let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight));
      let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight));
      return bCombinedRating - aCombinedRating;
    });
  }
}


File: chordrating.js

import { STANDARD_TUNING, TUNING, FINGER_FRET_RANGE, NOTE_INDEX_MAP, BARRE_RATING } from './constants.js';


export class ChordRating {
    constructor(chordVoicing) {
      this.chordVoicing = chordVoicing;
      this.playabilityRating = 0;
      this.soundQualityRating = 0;
  
      this.ratePlayability();
      this.rateSoundQuality();
    }
  
    ratePlayability() {
      let totalScore = (
        this.assessPlayabilityFingersUsed() +
        this.assessPlayabilityFingerSpread() +
        this.assessPlayabilityMuttedAmmount()
      ) / 3;
      
      if (totalScore < 0 || totalScore > 1) {
        console.error("ChordRating.ratePlayability: Unusual Rating Output: " + totalScore + " from Object: ", this.chordVoicing)
      }
  
      this.playabilityRating = totalScore;
      return;
    }
  
    assessPlayabilityFingersUsed() {
      let maxUsableFingers = 4;
      let usedFingers = 0;
      for (let i = 0; i < 6; i++) {
        if (this.chordVoicing.fingerPositions[i] > usedFingers) {
          usedFingers = this.chordVoicing.fingerPositions[i];
        }
      }
      let rating = 1 - (usedFingers / maxUsableFingers);
      return rating;
    }
  
    assessPlayabilityFingerSpread() {
      let maxFret = this.chordVoicing.minAboveZero;
      for (let i = 0; i < 6; i++) {
        if (this.chordVoicing.voicing[i] > this.chordVoicing.minAboveZero) {
          maxFret = this.chordVoicing.voicing[i];
        }
      }
      return 1 - ((maxFret - this.chordVoicing.minAboveZero) / FINGER_FRET_RANGE);
    }
  
    assessPlayabilityMuttedAmmount() {
      let mutedCount = 0;
      for (let i = 0; i < 6; i++) {
        if (this.chordVoicing.voicing[i] == -1) {
          mutedCount++;
        }
      }
      return 1 - (mutedCount / 6);
    }
  
    rateSoundQuality() {
      let totalScore = (
        this.assessSoundHarmonicCompleteness() +
        this.assessSoundOpenStrings() +
        this.assessSoundPlayedStrings() * 2 +
        this.assessSoundFretBoardHeight() +
        this.assessSoundVoicingRange() +
        this.assessSoundDoubleNotes()
      ) / 7;
      
      if (totalScore < 0 || totalScore > 1) {
        console.error("ChordRating.rateSoundQuality: Unusual Rating Output: " + totalScore + " from Object: ", this.chordVoicing)
      }
      this.soundQualityRating = totalScore;
      return;
    }
  
    assessSoundHarmonicCompleteness() {
      const uniqueDesiredNotes = new Set(this.chordVoicing.chordFactoryNotes);
      let overlapCount = 0;
      uniqueDesiredNotes.forEach(note => {
        if (this.chordVoicing.actuallyPlayedNotes.includes(note)) {
          overlapCount++;
        }
      });
      const completenessScore = overlapCount / uniqueDesiredNotes.size;
      return completenessScore;
    }
  
    assessSoundOpenStrings() {
      let openStrings = 0;
      for (let i = 0; i < this.chordVoicing.voicing.length; i++) {
        if (this.chordVoicing.voicing[i] == 0) {
          openStrings++;
        }
      }
      return openStrings / this.chordVoicing.voicing.length;
    }
  
    assessSoundPlayedStrings() {
      let playedStrings = 0;
      for (let i = 0; i < this.chordVoicing.voicing.length; i++) {
        if (this.chordVoicing.voicing[i] >= 0) {
          playedStrings++;
        }
      }
      return playedStrings / this.chordVoicing.voicing.length;
    }
  
    assessSoundFretBoardHeight() {
      return Math.max(0, (1 - (this.chordVoicing.minAboveZero / 12)));
    }
  
    assessSoundVoicingRange() {
      let minIndex = -1;
      let maxIndex = -1;
      for (let i = 0; i < 6; i++) {
        if (this.chordVoicing.voicing[i] != -1) {
          minIndex = i;
          break;
        }
      }
      if (minIndex < 0) {
        return 0;
      }
      for (let i = 5; i >= 0; i--) {
        if (this.chordVoicing.voicing[i] != -1) {
          maxIndex = i;
          break;
        }
      }
      let spacing = this.chordVoicing.actuallyPlayedNotes[maxIndex] - this.chordVoicing.actuallyPlayedNotes[minIndex];
      let maxSpacing = TUNING[5] + this.chordVoicing.minAboveZero + FINGER_FRET_RANGE - TUNING[0] + this.chordVoicing.minAboveZero;
      let spacingRatio = spacing / maxSpacing;
      return spacingRatio;
    }
  
    assessSoundDoubleNotes() {
      let doubleNotes = 0;
      for (let i = 0; i < 5; i++) {
        if (this.chordVoicing.actuallyPlayedNotes[i] == this.chordVoicing.actuallyPlayedNotes[i + 1]) {
          doubleNotes++;
        }
      }
      return 1 - (doubleNotes / 5);
    }
  }
  

File: chordvoicing.js

import { STANDARD_TUNING, TUNING, FINGER_FRET_RANGE, NOTE_INDEX_MAP, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';
import { ChordRating } from './chordrating.js';

export class ChordVoicing {
  constructor(voicing, barre, fingersUsed, barreSize, minAboveZero, chordFactoryNotes, chordFactoryRoot) {
    this.voicing = voicing;
    this.barre = barre;

    this.fingersUsed = fingersUsed
    this.barreSize = barreSize
    this.minAboveZero = minAboveZero
    this.fingerPositions = [0, 0, 0, 0, 0, 0]
    this.chordSpacing = 0
    this.chordFactoryNotes = chordFactoryNotes
    this.chordFactoryRoot = chordFactoryRoot
    this.actuallyPlayedNotes = [0, 0, 0, 0, 0, 0]

    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] >= 0) {
        this.actuallyPlayedNotes[i] = (this.voicing[i] + TUNING[i])
      } else {
        this.actuallyPlayedNotes[i] = this.voicing[i]
      }
    }

    this.rating = new ChordRating(this); // Initialize ChordRating

    // Use ratings from ChordRating
    this.playabilityRating = this.rating.playabilityRating;
    this.soundQualityRating = this.rating.soundQualityRating;

    this.calculateChordSpacing()
    this.calculateFingerPosition()


    //Send From ChordFactory over

  }

  calculateChordSpacing() {
    if (this.fingerPositions.length !== 6 || this.voicing.length !== 6) {
      throw new Error('Input arrays must each have 6 elements.');
    }

    let notes = this.fingerPositions.map((finger, index) => ({
      string: index + 1,
      fret: this.voicing[index],
      finger
    })).filter(note => note.finger !== 0 && note.fret !== -1);

    // Additional condition for barre chords
    if (this.barre) {
      notes = notes.filter(note => note.finger !== 1);
    }

    notes.sort((a, b) => a.fret - b.fret || a.string - b.string);

    let totalSpacing = 0;
    for (let i = 0; i < notes.length - 1; i++) {
      const stringDistance = Math.abs(notes[i].string - notes[i + 1].string);
      const fretDistance = Math.abs(notes[i].fret - notes[i + 1].fret);
      totalSpacing += stringDistance + fretDistance;
    }

    this.chordSpacing = totalSpacing;
  }


  calculateFingerPosition() {
    let startPosition = this.minAboveZero
    let finger = 1

    //Make the start Position the BArre Position and If there is an Barre, Set all The according Things to Barre
    if (this.barre) {
      for (let i = this.barreSize; i > 0; i--) {
        if (this.voicing[6 - i] == this.barre) {
          this.fingerPositions[6 - i] = 1
        }

        finger = 2
      }
    }
    //Now go through each Fret, Start With the lowest fret above zero or with the barre fret.

    for (let fret = 0; fret < 4; fret++) {
      for (let string = 0; string < 6; string++) {
        if (startPosition + fret == this.voicing[string] && this.fingerPositions[string] !== 1 && this.voicing[string] !== 0) {
          this.fingerPositions[string] = finger
          finger++
        }
      }
    }

    return;
  }
}

File: constants.js

// constants.js
export const STANDARD_TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
export const TUNING = [40, 45, 50, 55, 59, 64];
export const NOTE_INDEX_MAP = {
  'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4,
  'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9,
  'A#': 10, 'B': 11
};
export const BARRE_RATING = 1
export const FINGER_FRET_RANGE = 4

File: main.js

import { STANDARD_TUNING,TUNING, NOTE_INDEX_MAP, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';

let totalDuration = 0;
const repetitions = 50;
let lastPlayChords;

for (let i = 0; i < repetitions; i++) {
    const startTime = performance.now();
    
    const chord = new ChordFactory("E, G, B", 4, true, TUNING);
    const playableChords = chord.playableChords
    
    if (i === repetitions - 1) { // Only save the last result
        lastPlayChords = playableChords;
    }

    const endTime = performance.now();
    totalDuration += endTime - startTime; // Calculate the duration for this iteration
}

// Sort lastPlayChords by difficulty
if (lastPlayChords && lastPlayChords.length > 0) {
    lastPlayChords.sort((a, b) => a.rating - b.rating);
}

lastPlayChords.forEach((chord) => console.log(chord));

// Calculate the average time
const averageTime = totalDuration / repetitions;
console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);


File: utils.js

import { STANDARD_TUNING, NOTE_INDEX_MAP } from './constants.js';

export function parseNotes(input) {
  return input.toUpperCase()
    .replace(/B#/g, 'C').replace(/E#/g, 'F')
    .split(/[\s,]+/)
    .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note));
}

export function removeDuplicateArrays(arrays) {
  const uniqueArrays = new Set();
  return arrays.filter(array => {
    const serialized = JSON.stringify(array);
    if (!uniqueArrays.has(serialized)) {
      uniqueArrays.add(serialized);
      return true;
    }
    return
  });
}


File: script.js

import { DragAndDropItem } from "../drag-drop/script.js";

export class Chord {
    constructor(rootNote, notes, name, customRoot) {
        this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = notes; // Array of integers representing notes of the chord
        this.name = name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = customRoot 
        console.log("Constructed Chord: " + this.name + " Root: " + this.rootNote + " Notes: " + this.notes)
    }
}

export class ChordLibrary {
    constructor() {
        this.chords = [];
        this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        this.chordStructures = {
            '': { notes: [0, 4, 7] }, // Major
            'm': { notes: [0, 3, 7] }, // Minor
            '7': { notes: [0, 4, 7, 10] }, // Dominant 7th
            'M7': { notes: [0, 4, 7, 11] }, // Major 7th
            'm7': { notes: [0, 3, 7, 10] }, // Minor 7th
            'mM7': { notes: [0, 3, 7, 11] }, // Minor Major 7th
            'sus2': { notes: [0, 2, 7] }, // Suspended 2nd
            'sus4': { notes: [0, 5, 7] }, // Suspended 4th
            'dim': { notes: [0, 3, 6] }, // Diminished
            'aug': { notes: [0, 4, 8] }, // Augmented
            '9': { notes: [0, 4, 7, 10, 14] }, // Dominant 9th
            'M9': { notes: [0, 4, 7, 11, 14] }, // Major 9th
            'm9': { notes: [0, 3, 7, 10, 14] }, // Minor 9th
            '11': { notes: [0, 4, 7, 10, 14, 17] }, // Dominant 11th
            '13': { notes: [0, 4, 7, 10, 14, 17, 21] }, // Dominant 13th
            'add9': { notes: [0, 2, 4, 7] }, // Added 9th
            'm6': { notes: [0, 3, 7, 9] }, // Minor 6th
            '6': { notes: [0, 4, 7, 9] }, // Major 6th
            '5': { notes: [0, 7] }, // Power chord
            '6/9': { notes: [0, 4, 7, 9, 14] }, // Major 6/9
            'm11': { notes: [0, 3, 7, 10, 14, 17] }, // Minor 11
            'M7#11': { notes: [0, 4, 7, 11, 18] }, // Major 7#11
            'm7b5': { notes: [0, 3, 6, 10] }, // Half-Diminished
            '+7': { notes: [0, 4, 8, 10] }, // Augmented 7th
            'dim7': { notes: [0, 3, 6, 9] }, // Diminished 7th
            'M7+5': { notes: [0, 4, 8, 11] }, // Augmented Major 7th
            'mM9': { notes: [0, 3, 7, 11, 14] }, // Minor Major 9th
            'dimM7': { notes: [0, 3, 6, 11] }, // Diminished Major 7th - check if real
            '7alt': { notes: [0, 4, 6, 10, 13] }, // Altered Dominant (using 6 and 13)
            'M13': { notes: [0, 4, 7, 11, 14, 17, 21] }, // Major 13th
            'M11': { notes: [0, 4, 7, 11, 14, 17] }, // Major 11th
            'M7sus4': { notes: [0, 5, 7, 11] }, // Major 7th Suspended 4th
            'm7#5': { notes: [0, 3, 8, 10] }, // Minor 7th #5
            'M#5': { notes: [0, 4, 8] }, // Major #5
            '9#11': { notes: [0, 4, 7, 10, 14, 18] }, // Dominant 9th #11
            '13#11': { notes: [0, 4, 7, 10, 14, 18, 21] }, // Dominant 13th #11
            '7b5': { notes: [0, 4, 6, 10] }, // Dominant 7th Flat Five
            'M7b5': { notes: [0, 4, 6, 11] }, // Major 7th Flat Five
            'M7#5': { notes: [0, 4, 8, 11] }, // Major 7th Sharp Five
            'm7b9': { notes: [0, 3, 7, 10, 13] }, // Minor 7th Flat Nine
            '9b5': { notes: [0, 4, 6, 10, 14] }, // 9th Flat Five
            '9#5': { notes: [0, 4, 8, 10, 14] }, // 9th Sharp Five
            '7b9': { notes: [0, 4, 7, 10, 13] }, // Dominant 7th Flat Nine
            '7#9': { notes: [0, 4, 7, 10, 15] }, // Dominant 7th Sharp Nine
            '7#11': { notes: [0, 4, 7, 10, 18] }, // Dominant 7th Sharp Eleven
            'm7add11': { notes: [0, 3, 7, 10, 17] }, // Minor 7th Add 11
            'add2': { notes: [0, 2, 4, 7] }, // Major Add 2
            'add4': { notes: [0, 4, 5, 7] }, // Major Add 4
            '6add9': { notes: [0, 4, 7, 9, 14] }, // Major 6 Add 9

            '/C': { notes: [0, 4, 7], root: 0 }, // C Major
            'm/C': { notes: [0, 3, 7], root: 0 }, // C Minor
            '/C#': { notes: [0, 4, 7], root: 1 }, // C# Major
            'm/C#': { notes: [0, 3, 7], root: 1 }, // C# Minor
            '/D': { notes: [0, 4, 7], root: 2 }, // D Major
            'm/D': { notes: [0, 3, 7], root: 2 }, // D Minor
            '/D#': { notes: [0, 4, 7], root: 3 }, // D# Major
            'm/D#': { notes: [0, 3, 7], root: 3 }, // D# Minor
            '/E': { notes: [0, 4, 7], root: 4 }, // E Major
            'm/E': { notes: [0, 3, 7], root: 4 }, // E Minor
            '/F': { notes: [0, 4, 7], root: 5 }, // F Major
            'm/F': { notes: [0, 3, 7], root: 5 }, // F Minor
            '/F#': { notes: [0, 4, 7], root: 6 }, // F# Major
            'm/F#': { notes: [0, 3, 7], root: 6 }, // F# Minor
            '/G': { notes: [0, 4, 7], root: 7 }, // G Major
            'm/G': { notes: [0, 3, 7], root: 7 }, // G Minor
            '/G#': { notes: [0, 4, 7], root: 8 }, // G# Major
            'm/G#': { notes: [0, 3, 7], root: 8 }, // G# Minor
            '/A': { notes: [0, 4, 7], root: 9 }, // A Major
            'm/A': { notes: [0, 3, 7], root: 9 }, // A Minor
            '/A#': { notes: [0, 4, 7], root: 10 }, // A# Major
            'm/A#': { notes: [0, 3, 7], root: 10 }, // A# Minor
            '/B': { notes: [0, 4, 7], root: 11 }, // B Major
            'm/B': { notes: [0, 3, 7], root: 11 } // B Minor

        };

        this.generateChords();
    }

    generateChords() {
        Object.entries(this.chordStructures).forEach(([suffix, structure]) => {
            for (let i = 0; i < 12; i++) {
                let rootNote = i
                let customRoot = false
                let notes = structure.notes.map(interval => (i + interval) % 12);
                const chordName = `${this.noteNames[i]}${suffix}`;
                if (structure.root !== undefined) {
                    //Filter Dumb Chord Like C/C D/D
                    if (structure.root == rootNote) {
                        continue
                    }
                    rootNote = structure.root
                    customRoot = true
                    notes.push(rootNote)
                }


                this.chords.push(new Chord(rootNote, notes, chordName, customRoot));
            }
        });
    }

    searchChords(noteArray, rootNote, threshold = 50) {
        console.log("Searching Chords...")
        const results = [];
        noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave
        if (rootNote) {
            rootNote = rootNote % 12

        }
        const inputNotesSet = new Set(noteArray);

        this.chords.forEach(chord => {
            let chordNotes = [...chord.notes];

            //console.log("Comparing to: " + chord.name)
            //Add the Root note to the Chords For Cases like A/D
            
            //console.log("Input Notes Set: ", inputNotesSet);

            const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note)));
            //console.log("Common Notes with Chord: ", commonNotes);

            const totalUniqueNotes = new Set([...chordNotes, ...noteArray]);
            //console.log("Total Unique Notes: ", totalUniqueNotes);


            let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100;
            //console.log("Searched Root: " + rootNote + " Presen Root: " + chord.rootNote);

            // Adjusting match percentage based on root note comparison
            if (rootNote !== null) {
                if (chord.rootNote == rootNote) {
                    //console.log("Matching Root for: " + chord.name + " Root: " + chord.rootNote + " Notes: " + chordNotes)
                    // If root notes match, this is fine as calculated
                } else {
                    // Penalize the match percentage slightly if root notes don't match
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized for not matching Root")
                }
            } else {
                //If a Custom Root in the CHord Details is specified but the user hasnt put a custom root
                if (chord.customRoot == true) {
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized For Havinng Specific when it shouldnt")

                }
            }



            if (matchPercentage >= threshold) {
                results.push(
                    new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2)))
                );
            }
        });

        // Sort results by probability in descending order
        return results.sort((a, b) => b.probability - a.probability);
    }

    getAllChords() {
        // Return all chord names in a simplified object format
        return this.chords;
    }

    getChordByName(name) {
        const chord = this.chords.find(chord => chord.name === name);
        if (chord) {
            //console.log('Chord found:', chord);
            return chord;
        } else {
            //console.log('No chord found with the name:', name);
            return null;
        }
    }
}



File: createChatGPTContext.js

const fs = require('fs');
const path = require('path');

function isHtmlOrJsFile(file) {
  return file.endsWith('.html') || file.endsWith('.js');
}

function getDirectoryStructure(dir, fileStructure = {}, root = true) {
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      fileStructure[item] = {};
      getDirectoryStructure(fullPath, fileStructure[item], false);
    } else if (isHtmlOrJsFile(item)) {
      fileStructure[item] = fullPath;
    }
  });
  if (root) {
    return fileStructure;
  }
}

function readAllFiles(dir) {
  let allText = '';
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      allText += readAllFiles(fullPath);
    } else if (isHtmlOrJsFile(item)) {
      allText += `File: ${item}\n\n`;
      allText += fs.readFileSync(fullPath, 'utf8') + '\n\n';
    }
  });
  return allText;
}

function formatStructure(fileStructure, indent = 0) {
  let structureText = '';
  const indentString = ' '.repeat(indent);
  for (const key in fileStructure) {
    if (typeof fileStructure[key] === 'string') {
      structureText += `${indentString}${key}\n`;
    } else {
      structureText += `${indentString}${key}/\n`;
      structureText += formatStructure(fileStructure[key], indent + 2);
    }
  }
  return structureText;
}

const targetDir = path.join(__dirname, ''); // Change 'target' to your target folder
const outputFilePath = path.join(__dirname, 'output.txt');

// Get the folder and file structure
const fileStructure = getDirectoryStructure(targetDir);

// Format the structure to a string
const structureText = formatStructure(fileStructure);

// Read all the text from HTML and JS files
const filesText = readAllFiles(targetDir);

// Combine structure and file texts
const finalOutput = `${structureText}\n${filesText}`;

// Write the final output to a file
fs.writeFileSync(outputFilePath, finalOutput);

console.log('Folder structure and file contents have been saved to output.txt');


File: script.js

import { Chord } from "../chord-library/script.js";

export class DragAndDropItem extends Chord {
    constructor(chord, probability = -1) {
        super(chord)
        this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = chord.notes; // Array of integers representing notes of the chord
        this.name = chord.name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = chord.customRoot
        this.probability = probability
    }
}

export default class DragAndDropList {
    constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) {
        this.items = []
        this.idCounter = 0;
        items.forEach(item => {
            this.items.push(new DragAndDropItem(item))
        })

        this.dropzoneId = dropzoneId;

        this.selectedItemsEvent = new CustomEvent('selectedItemsUpdated', { bubbles: true, detail: { selectedItems: [] } });

        this.emptyMessageContainer = document.getElementById(emptyMessage);
        this.itemsContainer = document.getElementById(itemsContainer);
        this.selectedItemsContainer = document.getElementById(selectedItems);
        this.itemFilterInput = document.getElementById(itemSearch);
        this.selectedItemsArray = [];

        this.addEventListeners();
        this.populateItemsList();

        this.emptyMessage = "Click on chords to add";
        this.emptyMessageElement = document.createElement('div');
        this.emptyMessageElement.id = "DragAndDrop-EmptyMessage";

        const words = this.emptyMessage.split(' ');

        const baseElement = this.createItemElement({ name: "Sample Word" });
        baseElement.draggable = false;
        baseElement.isSelectable = false;

        words.forEach(word => {
            const clone = baseElement.cloneNode(true);
            clone.innerHTML = word;
            this.emptyMessageElement.appendChild(clone);
        });

        this.selectedItemsContainer.appendChild(this.emptyMessageElement);
    }

    addEventListeners() {
        window.addEventListener('dragover', this.handleWindowDragOver.bind(this));
        window.addEventListener('drop', this.handleWindowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('dragover', this.allowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('drop', this.handleDropOnContainer.bind(this));
        this.itemFilterInput.addEventListener('input', this.filterItems.bind(this));
    }

    handleWindowDragOver(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    handleWindowDrop(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    last100PercentItemIndex() {
        let lastIndex = -1;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].probability === 100) {
                lastIndex = i;
            }
        }
        return lastIndex;
    }

    populateItemsList() {
        const lastIndex100Percent = this.last100PercentItemIndex();
        let first100Percent = false;
        this.items.forEach((item, index) => {
            if (item.probability === 100 && !first100Percent) {
                first100Percent = true;
                const firstElement = document.createElement('div');
                firstElement.style.width = "100%";
                firstElement.innerHTML = "BEST MATCHES FOUND:";
                firstElement.style.backgroundColor = "#ffffff00";
                firstElement.style.color = "var(--light3)";
                firstElement.style.fontSize = "small";
                firstElement.style.marginBottom = "var(--padding)";

                this.itemsContainer.appendChild(firstElement);
            }
            const itemElement = this.createItemElement(item, true);
            this.itemsContainer.appendChild(itemElement);

            if (index === lastIndex100Percent) {
                const breakElement = document.createElement('div');
                breakElement.style.width = "100%";
                breakElement.style.height = "2px";
                breakElement.style.backgroundColor = "var(--dark1)";
                breakElement.style.marginTop = "var(--padding)";
                breakElement.style.marginBottom = "var(--padding)";
                breakElement.style.boxShadow = "var(--padding) 0px 0px 0px var(--dark1), calc(var(--padding)*-1) 0px 0px 0px var(--dark1)";

                this.itemsContainer.appendChild(breakElement);
            }
        });
    }

    createItemElement(item, isSelectable = false) {
        const itemElement = document.createElement('div');
        itemElement.textContent = item.name;

        itemElement.className = 'dragDropItem';
        itemElement.id = `dragDropItem-${this.idCounter++}`;

        if (item.probability >0) {
            const probabilitySpan = document.createElement('span');
            probabilitySpan.textContent = `(${item.probability}%)`;
            probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability);
            if (item.probability === 100) {
                itemElement.style.boxShadow = '0px 0px 13px 0px rgba(0,255,0)';
                itemElement.style.fontWeight = "800";
            }

            itemElement.appendChild(probabilitySpan);
        }

        if (isSelectable) {
            itemElement.addEventListener('click', () => this.addSelectedItem(item));
        }
        return itemElement;
    }

    getBackgroundColor(probability) {
        const startColor = [255, 130, 130];
        const endColor = [230, 230, 30];
        const winnerColor = [150, 200, 0];

        probability = Math.max(50, Math.min(100, probability));

        const scaledProbability = (probability - 50) / 50;

        const adjustedProbability = Math.log10(1 + 9 * scaledProbability);

        let blendedColor = startColor.map((component, index) => {
            return Math.round(component + (endColor[index] - component) * adjustedProbability);
        });
        if (probability === 100) {
            blendedColor = winnerColor;
        }
        return `rgb(${blendedColor.join(',')})`;
    }

    createSelectedItemElement(item) {
        const selectedItemElement = document.createElement('div');
        selectedItemElement.className = 'selected-dragDropItem dragDropItem';
        selectedItemElement.draggable = true;
        selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`;
        selectedItemElement.textContent = item.name;
        selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this));
        selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this));
        selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this));
        selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this));
        selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this));
        return selectedItemElement;
    }

    removeSelectedItem(event) {
        event.target.remove();
        this.updateArray();
    }

    addSelectedItem(item) {
        const selectedItemElement = this.createSelectedItemElement(item);
        this.selectedItemsContainer.appendChild(selectedItemElement);
        this.selectedItemsArray.push(item);
        this.updateDisplayArray();
    }

    updateItems(newItems) {
        console.log("Updating Library...");
        this.clearList();
        this.items = newItems;
        this.populateItemsList();
    }

    clearList() {
        this.items = [];
        while (this.itemsContainer.firstChild) {
            this.itemsContainer.removeChild(this.itemsContainer.firstChild);
        }
    }

    clearSelectedList() {
        this.selectedItemsArray = [];
        while (this.selectedItemsContainer.firstChild) {
            this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild);
        }
        this.updateDisplayArray();
    }

    handleDropOnItemList(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) {
            droppedItemElement.remove();
            this.updateArray();
        }
    }

    handleDragStart(event) {
        event.dataTransfer.setData('text/plain', event.target.id);

        if (event.target.classList.contains('selected-dragDropItem')) {
            event.target.classList.add('dragging');
        }
    }

    handleDragOver(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.add('over');
        }
    }

    handleDragLeave(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.remove('over');
        }
    }

    handleDropReorder(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);
        if (!droppedItemElement) return;

        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            if (droppedItemElement.classList.contains('selected-dragDropItem')) {
                this.insertAtCorrectPosition(droppedItemElement, targetElement);
            }
        } else {
            if (!droppedItemElement.classList.contains('selected-dragDropItem')) {
                const chordName = droppedItemElement.textContent.split(' (')[0];
                const chord = this.items.find(item => item.name === chordName);

                if (chord) {
                    const newClone = this.createSelectedItemElement(chord);
                    this.selectedItemsContainer.appendChild(newClone);
                    this.selectedItemsArray.push(chord);
                }
            } else {
                this.selectedItemsContainer.appendChild(droppedItemElement);
                this.updateArray();
            }
        }
        this.updateDisplayArray();
    }

    updateArray() {
        this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => {
            const chordName = el.textContent.split(' (')[0];
            return this.items.find(item => item.name === chordName);
        });
    }

    handleDragEnd(event) {
        event.target.classList.remove('dragging');
        const overItems = document.querySelectorAll('.selected-dragDropItem');
        overItems.forEach(item => item.classList.remove('over'));
    }

    allowDrop(event) {
        event.preventDefault();
    }

    handleDropOnContainer(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) {
            const chordName = droppedItemElement.textContent.split(' (')[0];
            const chord = this.items.find(item => item.name === chordName);

            if (chord) {
                const newClone = this.createSelectedItemElement(chord);
                this.selectedItemsContainer.appendChild(newClone);
                this.selectedItemsArray.push(chord);
                this.updateDisplayArray();
            }
        }
    } insertAtCorrectPosition(droppedItemElement, targetElement) {
        const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement);
        const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement);

        if (droppedIndex < targetIndex) {
            targetElement.after(droppedItemElement);
        } else {
            targetElement.before(droppedItemElement);
        }
        targetElement.classList.remove('over');
        this.updateArray();
    }

    updateDisplayArray() {
        console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`);
        console.log(this.selectedItemsArray.length);
        if (this.selectedItemsArray.length === 0) {
            if (!this.emptyMessageElement.parentNode) {
                this.selectedItemsContainer.appendChild(this.emptyMessageElement);
            }
        } else {
            this.emptyMessageElement.remove();
        }
        this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray];
        document.dispatchEvent(this.selectedItemsEvent);
    }

    filterItems() {
        const filterValue = this.itemFilterInput.value.toUpperCase();
        const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem');
        itemElements.forEach(itemElement => {
            const itemText = itemElement.textContent.toUpperCase();
            itemElement.style.display = itemText.includes(filterValue) ? '' : 'none';
        });
    }

    getArray() {
        return [...this.selectedItemsArray];
    }
}

File: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="piano/style.css" />
    <link rel="stylesheet" href="./output-styles.css" />
    <link rel="stylesheet" href="./input-styles.css" />


    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./script.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div id="settings">
            Settings
        </div>
        <div class="header">
            PianoToGuitar.com
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="visualPianoContainer">
                <div class="pianoMIDIWrapper">

                    <div class="pianoContainer"></div>
                    <div id="MIDIStatusDiv">
                        Initializing MIDI... </div>
                </div>
                <div class="pianoIconContainer">
                    <svg class="visualPianoIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg"
                        onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24">
                        <path
                            d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path
                            d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
            <div class="searchWordContainer">
                <div class="blackFadeBottom"></div>
                <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                <div class="searchChordList" id="itemsContainer">
                    <!-- Items will be populated here by JavaScript -->
                </div>
            </div>
        </div>
        Your Selected Progression
        <div class="selectedItemsWrapper">
            <div class="selectedItems" id="selectedItems">
                <!-- Dragged items will appear here -->
            </div>

            <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24"
                viewBox="0 -960 960 960" width="24">
                <path fill="currentColor"
                    d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
            </svg>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div id="progressionWrappers"></div>
            <div class="progressionInfo">DYNAMIC<br>Capo: 0 <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
            </div>

        </div>
    </div>
</body>

</html>

File: index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Note Logger</title>
</head>
<body>
<h1>MIDI Note Logger</h1>
<div id="status">Waiting for MIDI...</div>
<div id="log"></div>
<script src="script.js"></script>
</body>
</html>


File: script.js

export class MIDIAccessManager {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 5;
        this.notesPlayed = new Set();
        this.activeNotes = new Set();

        if (navigator.requestMIDIAccess) {
            this.attemptMIDIAccess();
        } else {
            console.log("Web MIDI API not supported!");
        }
    }

    attemptMIDIAccess() {
        navigator.requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))
            .catch(err => {
                console.error('Error accessing MIDI devices:', err);
                this.handleRetry(err);
            });
    }

    onMIDISuccess(midiAccess) {
        this.updateStatus("MIDI ready!");
        midiAccess.onstatechange = this.updateDeviceState.bind(this);
        Array.from(midiAccess.inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this));
    }

    onMIDIFailure() {
        this.updateStatus("No MIDI Devices found...");
        this.handleRetry(new Error("Initial connection failed"));
    }

    handleRetry(err) {
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            console.log(`Retrying... Attempt ${this.retryCount}`);
            setTimeout(() => this.attemptMIDIAccess(), 1000); // Retry after 1 second
        } else {
            console.error(`Failed to connect after ${this.maxRetries} attempts: ${err.message}`);
            this.updateStatus(`No MIDI Devices found.`);
        }
    }

    onMIDIMessage({ data: [command, note, velocity] }) {
        const eventDetail = { command, note, velocity };
        if (command === 144 && velocity > 0) {
            if (this.activeNotes.size === 0) { // New session
                this.notesPlayed.clear();
            }
            this.notesPlayed.add(note);
            this.activeNotes.add(note);
            window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail }));
        } else if (command === 128 || velocity === 0) {
            this.activeNotes.delete(note);
            window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail }));
            if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) {
                this.outputNotes();
            }
        }
    }

    outputNotes() {
        const uniqueNotes = Array.from(this.notesPlayed);
        console.log(uniqueNotes);
        window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes }));
    }

    updateStatus(message) {
        window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message }));
    }

    updateDeviceState({ port }) {
        const status = `MIDI: ${port.name} ${port.state}`;
        this.updateStatus(status);
        window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } }));
    }
}

export default MIDIAccessManager

File: script.js

class Piano {
    constructor(containerSelector, options = {}) {
        this.container = document.querySelector(containerSelector);
        this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50);

        this.octaves = options.octaves || 2;
        this.playedNotes = [];
        this.rootNote = null; // Add a property for the root note

        this.lastClickTime = 0;
        this.clickDelay = 300; // 300 milliseconds delay

        this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        this.keysPerOctave = this.layout.length;
        this.whiteKeyCount = this.layout.filter(x => x === 0).length;
        this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
        this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
        this.blackKeyHeight = 0.63;
        this.totalKeys = this.octaves * this.keysPerOctave;

        this.audioElements = [];
        this.volume = true
        this.globalVolume = 0.7;  // Global volume set to maximum by default


        this.createPiano();
        this.addKeyListeners();
    }

    volumeOff() {
        this.volume = false
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

    }

    volumeOn() {
        this.volume = true
    }

    updateVolume() {
        const activeCount = this.playedNotes.length;
        const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
        this.audioElements.forEach(audio => {
            if (!audio.paused) {  // Only update audio elements that are currently playing
                audio.volume = volume;
            }
        });
    }
    
    

    createPiano() {
        this.container.innerHTML = ''; // Clear existing piano keys
        let whiteCounter = 0;

        for (let index = 0; index < this.totalKeys; index++) {
            let key = document.createElement("div");
            key.setAttribute('data-note', index);
            if (this.layout[index % this.keysPerOctave] === 1) {
                key.classList.add("key", "black");
                key.style.left = `${(whiteCounter * this.whiteKeyWidth) - (this.blackKeyWidth / 2)}%`;
                key.style.width = `${this.blackKeyWidth}%`;
                key.style.height = `${this.blackKeyHeight * 100}%`;
                key.style.boxSizing = "border-box";
                key.style.position = `absolute`;
            } else {
                key.classList.add("key", "white");
                key.style.boxSizing = "border-box";
                key.style.width = `${this.whiteKeyWidth}%`;
                whiteCounter++;
            }
            this.container.appendChild(key);
            this.audioElements[index] = new Audio(`./audio/${index % 24}.mp3`);
            this.audioElements[index].preload = 'auto'; // This tells the browser to load the audio as soon as the page is loaded


        }
    }

    addKeyListeners() {
        this.container.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                //console.log("Click triggered")
                let currentTime = Date.now();



                const note = key.getAttribute('data-note');

                
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    if (currentTime - this.lastClickTime > 200) {
                        this.lastClickTime = currentTime;
                        //console.log("Set Time to: "+currentTime)
                    }

                    this.rootNote = null;

                } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) {
                    this.playedNotes = this.playedNotes.filter(n => n !== note);
                    key.classList.remove("selectedKey");
                } else {
                    if (!this.playedNotes.includes(note)) {
                        this.playedNotes.push(note);
                    }
                    key.classList.add("selectedKey");
                    this.playSoundLong(note, 0.75);
                }
                this.updatePlayedNotesDebounced();
            });

            key.addEventListener('dblclick', (event) => {
                //console.log("Doubleclick triggered")
                const note = key.getAttribute('data-note');
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    this.rootNote = null;
                } else {
                    if (this.rootNote !== null) {
                        this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
                    }
                    let currentTime = Date.now();
                    if (currentTime - this.lastClickTime < 500) {
                    } else {
                        this.rootNote = note;
                        if (!this.playedNotes.includes(note)) {
                            this.playedNotes.push(note);
                        }
                        key.classList.add('rootNote', 'selectedKey');
                    }

                }
                this.updatePlayedNotesDebounced();
            });
        });
    }


    debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }


    playSoundLong(index, localVolume) {
        if (this.volume) {
            const audio = this.audioElements[index];
            audio.volume = localVolume * this.globalVolume; // Apply global volume scaling
            if (!audio.paused) {
                audio.currentTime = 0; // Reset if it is already playing
            }
            audio.play();
        }
    }


    
    playChord() {
        this.playedNotes.sort((a, b) => a - b);
        const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1);
        this.playedNotes.forEach((note, index) => {
            const randomDelay = Math.random() * 20;
            setTimeout(() => {
                this.playSoundLong(note, localVolume);
            }, 20 * index + randomDelay);
        });
    }

    activateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (!key.classList.contains("selectedKey")) {
            key.classList.add("selectedKey");
            this.playedNotes.push(index);
            this.updatePlayedNotesDebounced();
            this.updateVolume(); // Adjust volume based on the new number of active notes
        }
        this.playSoundLong(index, 0.75); // Initial play sound with default volume
    }
    
    

    deactivateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (key.classList.contains("selectedKey")) {
            key.classList.remove("selectedKey");
            this.playedNotes = this.playedNotes.filter(n => n !== index);
            this.updatePlayedNotesDebounced();
            // Do not update volume here to keep it consistent with the number of keys pressed
        }
    }
    
    setRootNote(note) {
        const key = this.container.querySelector(`.key[data-note="${note}"]`);
        if (this.rootNote !== null) {
            // Remove rootNote class from the old root note
            this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
        }
        this.rootNote = note; // Update the rootNote to the new note
        key.classList.add('rootNote', 'selectedKey'); // Add rootNote class to new root note
        if (!this.playedNotes.includes(note)) {
            this.playedNotes.push(note); // Add root note to playedNotes if it's not already there
        }
        this.updatePlayedNotesDebounced();
    }

    clearRootNote() {
        if (this.rootNote !== null) {
            const key = this.container.querySelector(`.key[data-note="${this.rootNote}"]`);
            key.classList.remove('rootNote'); // Remove the rootNote class
            this.rootNote = null; // Reset the rootNote property
            this.updatePlayedNotesDebounced();
        }
    }

    updatePlayedNotes() {
        const event = new CustomEvent('notesChanged', { detail: { notes: this.playedNotes, rootNote: this.rootNote } });
        console.log("Dispatching Note Change Event: " + this.playedNotes + " Root: " + this.rootNote)
        this.container.dispatchEvent(event);
    }
    clearPiano() {
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

        this.playedNotes = []; // Clear the array of played notes
        this.rootNote = null; // Clear the root note
        this.container.querySelectorAll('.key.selectedKey').forEach(key => {
            key.classList.remove("selectedKey");
        });
        this.container.querySelectorAll('.key.rootNote').forEach(key => {
            key.classList.remove("rootNote");
        });
        this.updatePlayedNotes();
    }

    setOctaves(newOctaves) {
        if (newOctaves !== this.octaves) {
            this.octaves = newOctaves;
            this.totalKeys = this.octaves * this.keysPerOctave;
            this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
            this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
            this.clearPiano();
            this.createPiano();
            this.addKeyListeners();
        }
    }
}

export default Piano;


File: main.js

import { TUNING, NOTE_INDEX_MAP, BARRE_RATING } from '../chord-factory/constants.js';
import { parseNotes, removeDuplicateArrays } from '../chord-factory/utils.js';
import { ChordFactory } from '../chord-factory/chordfactory.js';
import { Chord } from '../chord-library/script.js';
import TabGenerator from "../tab-generator/script.js"


export class ProgressionGenerator {
    constructor(initialProgression = [], useRoot = true, tuning = TUNING, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.tuning = tuning;
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.progression = [];
        this.useRoot = useRoot; // This flag determines if the root note should be the starting note
        this.setProgression(initialProgression);
        this.progressionTypes = {
            basic: this.getProgressionBasic,
            // Add more progression types as methods here
        };
    }

    // Set initial progression with ChordFactory instances for each chord
    setProgression(initialProgression) {
        this.progression = [];
        initialProgression.forEach(chord => {
            console.log(chord)
            if (chord instanceof Chord) {
                // Create a ChordFactory for each chord definition = Get All Possible Chords for the Chord                
                let chordFactory = new ChordFactory(chord.notes, chord.rootNote, this.useRoot, this.tuning);
                console.log(chordFactory)
                this.progression.push(chordFactory);
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
            }
        });
    }

    getProgression(type = 'basic') {
        if (this.progressionTypes[type]) {
            return this.progressionTypes[type].call(this); // Ensures the method is called with correct this context
        } else {
            console.error('ProgressionGenerator: Invalid progression type requested.');
            return [];
        }
    }

    getProgressionHTML(desiredClasses = [], progressionType = "basic") {
        // Create an instance of ProgressionGenerator with the given progression and tuning
        const progression = this.getProgression(progressionType); // Get the basic progression

        const diagramsContainer = document.createElement('div'); // Container for chord diagrams
        desiredClasses.forEach(desiredClass => {
            diagramsContainer.classList.add(desiredClass)
        });

        progression.forEach(chordVoicing => {
            // Extract first playable chord from each ChordFactory instance
            if (chordVoicing) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    const chordDiagram = new TabGenerator(chordVoicing.voicing, chordVoicing.fingerPositions, chordVoicing.barreSize, chordVoicing.barre, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                    const svg = chordDiagram.generateChordSVG();
                    diagramsContainer.appendChild(svg);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        });

        return diagramsContainer; // Return the container with all SVGs
    }

    getProgressionBasic() {
        // Iterate over each entry in the progression and get the first playable chord
        return this.progression.map(chordFactory => {
            if (chordFactory.playableChords && chordFactory.playableChords.length > 0) {
                return chordFactory.playableChords[0];
            } else {
                return null; // Return null if there are no playable chords available
            }
        }).filter(chord => chord !== null); // Filter out any null entries
    }


    getProgressionDynamicHTML(soundQuality = 0.5) {
        // Iterate over each entry in the progression, sort by combined rating, and get the first playable chord
        this.progression.forEach(chordFactory => {
            chordFactory.sortPlayableChordsByCombinedRating(soundQuality);
        });

        let diagramsContainer = document.createElement('div'); // Container for chord diagrams
console.log(this.progression)


        this.progression.forEach(chordFactory => {
            // Extract first playable chord from each ChordFactory instance
            if (chordFactory.playableChords[0]) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    const chordDiagram = new TabGenerator(chordFactory.playableChords[0].voicing, chordFactory.playableChords[0].fingerPositions, chordFactory.playableChords[0].barreSize, chordFactory.playableChords[0].barre, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                    const svg = chordDiagram.generateChordSVG();
                    diagramsContainer.appendChild(svg);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        });

        return diagramsContainer; // Return the container with all SVGs
    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
}

File: script.js

import DragAndDropList from './drag-drop/script.js';
import Piano from './piano/script.js';
import { Chord, ChordLibrary } from "./chord-library/script.js"
import MIDIAccessManager from "./midi-integration/script.js"
import { ProgressionGenerator } from './progression-generator/main.js';
import { TUNING } from './chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {


    //Make Settings Button functional
    window.toggleSettings = function () {
        let settingsScreen = document.getElementById("settings");
        // Toggle a class that controls the visibility and opacity
        settingsScreen.classList.toggle('visible');
    }
    


    // Import the MidiManager
    const midiManager = new MIDIAccessManager();

    var visualPianoOctaves = 3


    // Function to calculate the number of octaves based on screen width
    function calculateOctaves() {
        const screenWidth = window.innerWidth;
        console.log((Math.sqrt(screenWidth)))
        const maxOctaves = 3; // Base octaves to start with
        const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25);
        visualPianoOctaves = Math.min(maxOctaves, extraOctaves)
        return visualPianoOctaves;
    }



    // Create a new Piano instance with dynamic number of octaves
    const myPiano = new Piano('.pianoContainer', { octaves: calculateOctaves() });


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);


    var isVolumeOn = localStorage.getItem('volumeState') === 'off' ? false : true;
    const volumeIcon = document.getElementById('volumeIcon');

    updateVolumeIcon(); // Update the icon at load

    window.toggleVolume = function () {

        if (isVolumeOn) {
            myPiano.volumeOff(); // Turn volume off
            isVolumeOn = false;
            localStorage.setItem('volumeState', 'off');
        } else {
            myPiano.volumeOn(); // Turn volume on
            isVolumeOn = true;
            localStorage.setItem('volumeState', 'on');
        }
        updateVolumeIcon();
    };

    function updateVolumeIcon() {
        if (!isVolumeOn) {
            volumeIcon.innerHTML = `<path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"/>`;
        } else {
            volumeIcon.innerHTML = `<path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"/>`;
        }
    }

    window.playPiano = function () {
        myPiano.playChord();
        console.log("Piano played");
    };


    window.clearPiano = function () {
        document.getElementById("itemSearch").value = ""
        myPiano.clearPiano();
        console.log("Piano cleared");
    };

    window.clearProgression = function () {
        document.getElementById("itemSearch").value = ""
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };

    // Handle window resize to adjust the number of octaves dynamically
    window.onresize = function () {
        const newOctaves = calculateOctaves();
        myPiano.setOctaves(newOctaves); // Assuming there's a method to update the octaves dynamically
    };




    document.querySelector('.pianoContainer').addEventListener('notesChanged', (e) => {
        console.log('Piano notes changed:', e.detail.notes, e.detail.rootNote);
        let items
        if (e.detail.notes.length > 0) {
            console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote)
            items = chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50)
        } else {
            items = allChordLibraryItems
        }
        //dragAndDropList.ceateAndInsertElement(e.detail.notes)
        dragAndDropList.updateItems(items)
        // Additional logic to handle the change in notes
    });


    //Midi Integration for Pinao Notes 
    let actualPressedKeys = new Map(); // Maps actual notes to their counts
    let visualPressedKeys = new Set();

    function mapNoteToVisualKey(note) {
        return note % (visualPianoOctaves * 12);
    }

    window.addEventListener('noteOn', (e) => {
        const { note } = e.detail;
        const visualKey = mapNoteToVisualKey(note);
        let count = actualPressedKeys.get(note) || 0;
        actualPressedKeys.set(note, count + 1);
        visualPressedKeys.add(visualKey);
        myPiano.activateKey(visualKey);
        updateRootNote();
    });

    window.addEventListener('noteOff', (e) => {
        const { note } = e.detail;
        if (actualPressedKeys.has(note)) {
            let count = actualPressedKeys.get(note);
            if (count > 1) {
                actualPressedKeys.set(note, count - 1);
            } else {
                actualPressedKeys.delete(note);
                // Check if any other actual key maps to the same visual key
                const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note));
                if (!anyOther) {
                    visualPressedKeys.delete(mapNoteToVisualKey(note));
                    myPiano.deactivateKey(mapNoteToVisualKey(note));
                }
            }
        }
        updateRootNote();
    });

    function updateRootNote() {
        if (actualPressedKeys.size > 0) {
            // Convert actualPressedKeys to an array and sort it
            const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b);
    
            // Determine if the lowest note should be set as the root note
            const lowestNote = sortedNotes[0];
            const lowestNoteMod12 = lowestNote % 12;
            let setRoot = false;
    
            // Check if the lowest note is doubled in higher octaves
            if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) {
                setRoot = true;
            }
    
            // Check if the lowest note is 12 interval steps away from the second lowest note
            if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6 )) {
                setRoot = true;
            }
    
            // Set or clear the root note based on the above conditions
            if (setRoot) {
                const visualKey = mapNoteToVisualKey(lowestNote);
                myPiano.setRootNote(visualKey);
            } else {
                myPiano.clearRootNote();
            }
        } else {
            myPiano.clearRootNote();
        }
    }
    

    window.addEventListener("statusUpdated", (e) => {
        document.getElementById("MIDIStatusDiv").innerHTML = e.detail

    })


    //Functionality to autom,atically add Chord when played by midi:
    window.addEventListener('notesOutput', (e) => {
        const notes = e.detail;
        if (notes.length > 0) {
            const rootNote = Math.min(...notes);
            const searchResults = chordLibrary.searchChords(notes, rootNote, 100);
            if (searchResults.length > 0) {
                const chord = searchResults[0];
                dragAndDropList.addSelectedItem(chord);
                //popUp.open("Added: " +chord.name, { autoClose: true, duration: 1000 });
            }
        }
    });


    let progressionGenerator = new ProgressionGenerator([], true, TUNING , "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', function(event) {
        console.log('Updated Selected Items:', event.detail.selectedItems);
        console.log(typeof(event.detail.selectedItems[0]))
        progressionGenerator.setProgression(event.detail.selectedItems) 
        let progressionHTML = progressionGenerator.getProgressionHTML([], "basic")
        console.log(progressionHTML)
        document.getElementById("progressionWrappers").innerHTML = ""
        document.getElementById("progressionWrappers").appendChild(progressionHTML)
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");

    soundQualitySlider.addEventListener('input', (e) => {
        const soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);

        let progressionHTML = progressionGenerator.getProgressionDynamicHTML(soundQualityValue);
        document.getElementById("progressionWrappers").innerHTML = "";
        document.getElementById("progressionWrappers").appendChild(progressionHTML);
    });
    
});


File: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Diagram Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>Guitar Chord Diagram Generator</h1>
        <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input">
        <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)">
        <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button>
        <div id="diagram" class="diagram-container"></div>
    </div>
    <script type="module">
        import TabGenerator from "./script.js"

        const fingerPositions = ['-1', '13', '12', '5', '0', '0'];
        const fingerNumbers = ['9', '1', '2', '1', '', ''];
        const barreSize = 3;
        const barre = 10;
        const color = "#fff";
        const textColor = "#000";
        const showOpenStrings = true;

        try {
            const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, barreSize, barre, color, textColor, 'belowString', showOpenStrings);
            const svg = chordDiagram.generateChordSVG();
            document.getElementById('diagram').appendChild(svg);
        } catch (error) {
            console.error('Error generating chord diagram:', error);
        }
    </script>
</body>

</html>

File: script.js

/**
 * Represents a TabGenerator for creating guitar chord diagrams as SVG elements.
 * This class allows the configuration of various aspects of the diagram, including finger positions,
 * barre chords, string and note visualization, and color customization.
 */
class TabGenerator {
    /**
     * Creates an instance of TabGenerator.
     * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings.
     * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string.
     * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used.
     * @param {string} [barre=null] - Specific fret where the barre is placed.
     * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes.
     * @param {string} [textColor="#fff"] - Color for the text used in the diagram.
     * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately.
     * @param {boolean} showOpenStrings - Whether to display open strings in the diagram.
     */
    constructor(fingerPositions, fingerNumbers, barreSize = null, barre = null, elementColor = "#000", textColor = "#fff", numberPosition = 'onNote', showOpenStrings) {

        if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) {
            console.error("Error: fingerPositions must be an array of length 6.");
        }
        if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) {
            console.error("Error: fingerNumbers must be an array of length 6 or null.");
        }
        if (barreSize !== null && (typeof barreSize !== 'number' || barreSize < 1 || barreSize > 6)) {
            console.error("Error: barreSize must be a number between 1 and 6 or null.");
        }
        if (barre !== null && (typeof barre !== 'number' || !/^\d+$/.test(barre))) {
            console.error("Error: barre must be a string representing a number or null.");
        }
        if (typeof elementColor !== 'string') {
            console.error("Error: elementColor must be a string.");
        }
        if (typeof textColor !== 'string') {
            console.error("Error: textColor must be a string.");
        }
        if (numberPosition !== 'onNote' && numberPosition !== 'belowString') {
            console.error("Error: numberPosition must be either 'onNote' or 'belowString'.");
        }
        if (typeof showOpenStrings !== 'boolean') {
            console.error("Error: showOpenStrings must be a boolean.");
        }

        this.fingerPositions = fingerPositions;
        this.fingerNumbers = fingerNumbers;
        this.barreSize = barreSize;
        this.barre = barre;
        this.numberPosition = numberPosition;
        this.showOpenStrings = showOpenStrings;
        this.topSpacing = 25;
        this.indicatorTopSpacing = 19;
        this.textTopSpacing = 190
        this.topBarHeight = 5
        this.color = elementColor
        this.textColor = textColor
    }

    generateChordSVG() {
        const svgAttributes = {
            width: '200',
            height: '200',
            viewBox: '0 0 200 200'  // This sets the viewBox attribute
        };
        const svg = this.createSVGElement('svg', svgAttributes);
        this.drawDiagramComponents(svg);
        return svg;
    }

    drawDiagramComponents(svg) {
        this.drawTopBar(svg);
        if (this.barreSize !== null) {
            this.drawBarre(svg);
        }
        this.drawStrings(svg);
        this.drawFrets(svg);
        if (this.showOpenStrings) {
            this.drawOpenStrings(svg);
        }
        this.drawNotes(svg);
        this.drawMuteIndicators(svg);
    }


    createSVGElement(tag, attributes) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const attr in attributes) {
            element.setAttribute(attr, attributes[attr]);
        }
        return element;
    }

    drawTopBar(svg) {
        const topBar = this.createSVGElement('rect', {
            x: "29.5",
            y: 14 + this.topSpacing,
            width: '125',
            height: this.topBarHeight,
            fill: this.color,
            stroke: this.color,
            'stroke-width': '2'
        });
        svg.appendChild(topBar);
    }

    drawStrings(svg) {
        for (let i = 0; i < 6; i++) {
            const line = this.createSVGElement('line', {
                x1: 30 + i * 25, y1: this.topSpacing + 13,
                x2: 30 + i * 25, y2: 140 + this.topSpacing,
                stroke: this.color, 'stroke-width': ((6 - i) / 3) + 1
            });
            svg.appendChild(line);
        }
    }

    drawFrets(svg) {
        for (let j = 0; j < 5; j++) {
            const line = this.createSVGElement('line', {
                x1: '30', y1: 20 + this.topSpacing + j * 25,
                x2: '155', y2: 20 + this.topSpacing + j * 25,
                stroke: this.color, 'stroke-width': '2'
            });
            svg.appendChild(line);
        }
    }

    drawNotes(svg) {
        const barreFret = this.barre ? parseInt(this.barre) : 1;
        for (let k = 0; k < 6; k++) {
            if (this.fingerPositions[k] !== 'x') {
                const fret = parseInt(this.fingerPositions[k]);
                if (fret > 0) {
                    const position = 40 + (fret - barreFret) * 25;
                    const circle = this.createSVGElement('circle', {
                        cx: 30 + k * 25, cy: position + this.topSpacing - 8,
                        r: '10', fill: this.color
                    });
                    svg.appendChild(circle);

                    if (this.fingerNumbers && this.fingerNumbers[k]) {
                        const textPositionY = this.numberPosition === 'onNote' ? position + this.topSpacing : this.textTopSpacing;
                        const text = this.createSVGElement('text', {
                            x: 30 + k * 25,
                            y: textPositionY,
                            'font-family': 'Arial',
                            'font-size': '20',
                            'font-weight': '500',
                            fill: this.numberPosition === 'onNote' ? this.textColor : this.color,
                            'text-anchor': 'middle'
                        });
                        text.textContent = this.fingerNumbers[k];
                        svg.appendChild(text);
                    }
                }
            }
        }
    }

    drawMuteIndicators(svg) {
        const ofsetX = 0;
        const ofsetY = -15 + this.indicatorTopSpacing;
        const strokeLength = 13;
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] == -1) {
                const halfStroke = strokeLength / 2;
                const line1 = this.createSVGElement('line', {
                    x1: 30 + i * 25 - halfStroke + ofsetX,
                    y1: 10 + ofsetY,
                    x2: 30 + i * 25 + halfStroke + ofsetX,
                    y2: 10 + strokeLength + ofsetY,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                const line2 = this.createSVGElement('line', {
                    x1: 30 + i * 25 + halfStroke + ofsetX,
                    y1: 10 + ofsetY,
                    x2: 30 + i * 25 - halfStroke + ofsetX,
                    y2: 10 + strokeLength + ofsetY,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(line1);
                svg.appendChild(line2);
            }
        }
    }

    drawOpenStrings(svg) {
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] === '0') {
                const circle = this.createSVGElement('circle', {
                    cx: 30 + i * 25,
                    cy: this.indicatorTopSpacing,
                    r: '7',
                    fill: 'none',
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(circle);
            }
        }
    }

    drawBarre(svg) {
        const index = 6 - this.barreSize;
        const barreWidth = this.barreSize * 25 - 15;
        const barreHeight = 10;
        const barreX = 25 + index * 25 - 5;
        const barreY = 25 + (7.5 - barreHeight / 2) + this.topSpacing;

        const rect = this.createSVGElement('rect', {
            x: barreX, y: barreY,
            width: barreWidth + 10, height: barreHeight,
            rx: '5', ry: '5',
            fill: this.color
        });
        svg.appendChild(rect);

        if (this.barre) {
            const text = this.createSVGElement('text', {
                x: barreX + barreWidth + 15, y: barreY + barreHeight,
                'font-family': 'Arial', 'font-size': '20', fill: this.color,
                'text-anchor': 'left'
            });
            text.textContent = this.barre + "fr";
            svg.appendChild(text);
        }
    }
}

export default TabGenerator;

