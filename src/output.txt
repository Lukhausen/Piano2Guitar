Directory Structure:
audio/
chord-factory/
  chordfactory.js (Path: chord-factory\chordfactory.js, Size: 17403 bytes)
  chordvoicing.js (Path: chord-factory\chordvoicing.js, Size: 14477 bytes)
  constants.js (Path: chord-factory\constants.js, Size: 1652 bytes)
  main.js (Path: chord-factory\main.js, Size: 1061 bytes)
  timingtext.js (Path: chord-factory\timingtext.js, Size: 1898 bytes)
  utils.js (Path: chord-factory\utils.js, Size: 1356 bytes)
chord-library/
  script.js (Path: chord-library\script.js, Size: 10574 bytes)
chordviewer/
  index.html (Path: chordviewer\index.html, Size: 4280 bytes)
  index.js (Path: chordviewer\index.js, Size: 2342 bytes)
createChatGPTContext.js (Path: createChatGPTContext.js, Size: 4532 bytes)
css/
drag-drop/
  script.js (Path: drag-drop\script.js, Size: 13797 bytes)
index.html (Path: index.html, Size: 11225 bytes)
index.js (Path: index.js, Size: 16391 bytes)
midi-integration/
  index.html (Path: midi-integration\index.html, Size: 263 bytes)
  script.js (Path: midi-integration\script.js, Size: 3424 bytes)
piano/
  script.js (Path: piano\script.js, Size: 9866 bytes)
progression-generator/
  main.js (Path: progression-generator\main.js, Size: 13511 bytes)
  svg/
  tabhtml.js (Path: progression-generator\tabhtml.js, Size: 8754 bytes)
settings.js (Path: settings.js, Size: 191 bytes)
svg/
tab-generator/
  index.html (Path: tab-generator\index.html, Size: 1572 bytes)
  script.js (Path: tab-generator\script.js, Size: 11120 bytes)
test.html (Path: test.html, Size: 2981 bytes)

File Contents:
File: chordfactory.js
Path: chord-factory\chordfactory.js

import { settings, MAX_FRETS } from './constants.js'; import { ChordVoicing } from './chordvoicing.js'; export class ChordFactory { constructor(chord, startWithRoot = true, tuning = settings.tuning) { console.log("ChordFactory Recieved Notes: ", chord.notes) this.identifier = chord.name this.notes = chord.notes; this.startWithRoot = startWithRoot this.root = chord.rootNote this.tuning = tuning; this.fingerPositions = this.calculateValidFingerPositions(); this.allChords = this.generateAllChordCombinations2() this.playableChords = this.filterPlayableChords2(structuredClone(this.allChords)) //this.getFretSpanStatistics() this.sortPlayableChordsByCombinedRating(1) } getFretSpanStatistics() { let spanCounts = {}; // Object to store the count of each span // Iterate over all chord combinations this.allChords.forEach(chord => { // Filter out muted and open strings, keeping only fretted notes const frets = chord.filter(fret => fret > 0); if (frets.length > 1) { // Ensure there's more than one fretted note to calculate a span const minFret = Math.min(...frets); const maxFret = Math.max(...frets); const span = maxFret - minFret; // Update the count for the calculated span if (span in spanCounts) { spanCounts[span] = spanCounts[span] + 1; } else { spanCounts[span] = 1; } } }); // Log the statistics for review console.log("Fret Span Statistics:", spanCounts); return spanCounts; } calculateValidFingerPositions() { const fingerPositions = []; for (let stringIndex of this.tuning) { const positions = []; for (let chordIndex of this.notes) { const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12); positions.push(...validPositions); } if (!positions.includes(0)) { // Check if positions array does not contain 0 positions.push(-1); // Add -1 only if there is no 0 } positions.sort((a, b) => a - b); // Sort the positions from lowest to highest fingerPositions.push(positions); } return fingerPositions; } getValidFretPositionsForNote(noteIndex, stringIndex) { const baseFret = (noteIndex - stringIndex + 120) % 12; return [baseFret, baseFret + 12]; } cartesianProduct(arrays) { return arrays.reduce((acc, curr) => { return acc.flatMap(a => curr.map(b => [...a, b])); }, [[]]); } //Highly efficent Variant of the Cartesian Product, That will not calulate any position twice generateAllChordCombinations2() { const startTime = performance.now(); let chords = []; //console.log("Initial chords array:", chords); let maskScope = []; for (let i = 0; i < 6; i++) { //Check If A Zero is present in the Valid Positions. Then We dont need to Mute The String Ever. if (this.fingerPositions[i]) maskScope[i] = [this.fingerPositions[i][0]]; // Each sub-array is separately instantiated } //console.log("Initial maskScope array:", maskScope); const fingerIndexStorage = Array(6).fill(1); //console.log("Initial fingerIndexStorage array:", fingerIndexStorage); let fingerIndexLength = [] this.fingerPositions.forEach((element, inndex) => { fingerIndexLength[inndex] = element.length - 1 }) //console.log("Finger index lengths for all strings:", fingerIndexLength); // As the first entry of the chords is allways -1 we can skip this for (let fret = 0; fret < 13; fret++) { //console.log("generateAllChordCombinations2 - FRET: ", fret) for (let string = 0; string < 6; string++) { for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) { // FIrst remove all Non Fitting Elements From Out current maskScope on All Strings. // Exclude The -1 (muted) and 0 (open string) Because they can be used everywhere if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) { maskScope[string].splice(validPosition, 1); } } } //for (let i = 0; i < 6; i++) { //console.log("generateAllChordCombinations2 - maskScope: ", i, maskScope[i]) //} //Now We deleted all old ElementInternals, we can start inserting New elements one by one for (let string = 0; string < 6; string++) { //console.log("generateAllChordCombinations2 Fret, String", fret, string) // Add The New Element, if there is one // First Check If there is a New Element inside the Array if (fingerIndexStorage[string] < fingerIndexLength[string]) { // CHeck if its in range for Valid CHord, if so add it if (this.fingerPositions[string][fingerIndexStorage[string]] <= fret + settings.fingerFretRange - 1) { //console.log("generateAllChordCombinations2 Pushing into maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]] ", maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]]) maskScope[string].push(this.fingerPositions[string][fingerIndexStorage[string]]) for (let pos1 of maskScope[(string + 1) % 6]) { for (let pos2 of maskScope[(string + 2) % 6]) { for (let pos3 of maskScope[(string + 3) % 6]) { for (let pos4 of maskScope[(string + 4) % 6]) { for (let pos5 of maskScope[(string + 5) % 6]) { let newVoicing = [] newVoicing[string] = this.fingerPositions[string][fingerIndexStorage[string]] newVoicing[(string + 1) % 6] = pos1 newVoicing[(string + 2) % 6] = pos2 newVoicing[(string + 3) % 6] = pos3 newVoicing[(string + 4) % 6] = pos4 newVoicing[(string + 5) % 6] = pos5 //console.log("NEW: ", newVoicing) chords.push(newVoicing); } } } } } //Flag the next index to be looked at later fingerIndexStorage[string]++ } else { //Break because the element found is too big to be inserte into the maskScope } } else { //break because there are no more elments left in the Array } //Calculate the Cartesian Product From the Inserted element // Add each element to the chords } } // Track end time const endTime = performance.now(); // Calculate the time taken const timeTaken = endTime - startTime; console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds"); return chords; } filterPlayableChords(allChordsCopy) { const startTime = performance.now(); const playableChordsSet = new Set(); allChordsCopy.forEach(voicing => { // Start By Muting All Chords if (this.startWithRoot) { for (let string = 0; string < 6; string++) { if (voicing[string] == -1) { continue; } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) { voicing[string] = -1; } else { break; } } } // Faster Way to Calculate the MinaboveZero let minAboveZero = Infinity; for (let i = 0; i < voicing.length; i++) { if (voicing[i] > 0 && voicing[i] < minAboveZero) { minAboveZero = voicing[i]; } } if (minAboveZero === Infinity) { minAboveZero = 0; } let fingersUsed = 0; let barreStop = false; let barreUseFingers = 0; let barreAddFingers = 0; for (let i = 5; i >= 0; i--) { if (voicing[i] <= 0) { barreStop = true; } if (voicing[i] >= minAboveZero && barreStop == false) { barreUseFingers++; if (voicing[i] > minAboveZero) { barreAddFingers++; } } else if (voicing[i] > 0 && voicing[i] !== "x") { barreAddFingers++; } } if (barreUseFingers) { if (barreUseFingers >= 2 && barreAddFingers > 3) { return; } else if (barreUseFingers < 2) { fingersUsed = voicing.filter(fret => fret >= minAboveZero).length; barreUseFingers = 0; } } if (fingersUsed <= 4) { let newVoicing = new ChordVoicing( voicing, barreUseFingers > 0 ? minAboveZero : null, barreUseFingers > 0 ? barreAddFingers : fingersUsed, barreUseFingers, minAboveZero, this.notes, this.startWithRoot ? this.root : -1 ); playableChordsSet.add(JSON.stringify(newVoicing)); } }); // Convert the Set back to an array of unique ChordVoicing objects const playableChords = Array.from(playableChordsSet).map(voicingString => JSON.parse(voicingString)); // Track end time const endTime = performance.now(); // Calculate the time taken const timeTaken = endTime - startTime; console.log("filterPlayableChords - Time taken:", timeTaken, "milliseconds"); return playableChords; } filterPlayableChords2(allChordsCopy) { const startTime = performance.now(); let playableChordsVoicingSet = new Set(); let playableChordsArray = [] let totalChordVoicingTime = 0; // Initialize a variable to accumulate time for ChordVoicing creation // Pre-create and reuse these objects - Testing Showed This is faster than Creating them newly let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => [])); let barreClassesUsed = new Set(); let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0); let minAboveZero = 99; let mutingTillRoot = true; let touchedSet = new Set(); let barres = [] let touchedIndices = []; let fingerPositionsCounter = 0 let fingerPositions = [-1, -1, -1, -1, -1, -1] let fingerPositionsAmmount = 0 allChordsCopy.forEach(voicing => { minAboveZero = 99; mutingTillRoot = true; // Reset values for each iteration barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0)); barreClassesUsed.clear(); touchedSet.clear() barreSeparatorIndex.fill(0); barres = [] touchedIndices = []; fingerPositionsCounter = 0 fingerPositions = [-1, -1, -1, -1, -1, -1] fingerPositionsAmmount = 0 for (let string = 0; string < 6; string++) { //Mute Strings That are not the Root Note if (this.startWithRoot && mutingTillRoot) { if (voicing[string] == -1) { // Do Nothing } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) { // Mute The String voicing[string] = -1; } else { mutingTillRoot = false; } } //Count Total Fingers Used in this voicing. if (voicing[string] > 0) { fingerPositionsAmmount++ if (voicing[string] < minAboveZero) { minAboveZero = voicing[string]; } } } // Check if the voicing is already in the set let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5]; if (playableChordsVoicingSet.has(voicingString)) { //console.log("Allready Has Voicing, Skipping...") return; // Skip processing if voicing is already in the set } //Remove Chords Below two fingers used. if (fingerPositionsAmmount < 2) { return } //Take a Look at the Ammount of fingers Required. If is less than 5 no barre needs to be caluclated. if (fingerPositionsAmmount > 4) { for (let string = 0; string < 6; string++) { //Mute Strings That are not the Root Note //Now, Place the Strings in their Corresponding barreClass if (voicing[string] >= 0) { barreClassesUsed.forEach((index) => { if (voicing[string] < index) { barreSeparatorIndex[index] += 1; } }); barreClassesUsed.add(voicing[string]); barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string); const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`; if (!touchedSet.has(newIndex)) { touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]); touchedSet.add(newIndex); } } } // Sort touchedIndices from lowest to highest fret touchedIndices.sort(([fretA], [fretB]) => fretA - fretB); //console.log(touchedIndices) touchedIndices.forEach(([fret, index]) => { if (barreClass[fret][index].length > 0) { if (barreClass[fret][index].length > 1 && fret != 0) { barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])]) fingerPositionsCounter++ barreClass[fret][index].forEach(element => { fingerPositions[element] = fingerPositionsCounter }) } else if (fret != 0) { fingerPositionsCounter++ fingerPositions[barreClass[fret][index]] = fingerPositionsCounter } } }); //Check if 5 Finger are still used, If so, Remove the CHord. if (fingerPositionsCounter > 4) { return } } else { //console.log("SkippedBarre Because The Fingers are to less") //No Barre Requred, so we can just calulate Where each finger goes. for (let fret = 0; fret < settings.fingerFretRange; fret++) { for (let string = 0; string < 6; string++) { if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) { fingerPositionsCounter++ fingerPositions[string] = fingerPositionsCounter } } } } //IF minabove Zero Was note set, Set it to zero if (minAboveZero == 99) { minAboveZero = 0 } const chordVoicingStartTime = performance.now(); let newVoicing = new ChordVoicing( voicing, fingerPositions, barres, minAboveZero, fingerPositionsAmmount, this.notes, this.startWithRoot ? this.root : -1 ); const chordVoicingEndTime = performance.now(); const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime; totalChordVoicingTime += chordVoicingTimeTaken; playableChordsVoicingSet.add(voicingString); playableChordsArray.push(newVoicing); //console.log("filterPlayableChords2 - voicing, barres", voicing, barres); //Now Check For each Barre Class Starting at MinAboveZero... }); const endTime = performance.now(); // Calculate the time taken const totalTimeTaken = endTime - startTime; console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds"); console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds"); return playableChordsArray } /** * Sorts the playable chords by a combined rating based on sound quality and * playability. The combined rating is calculated using a weighted sum of * the sound quality rating and the playability rating. * * @param {number} soundWeight - A value between 0 and 1 that determines the weight * given to the sound quality rating. The weight given to the playability rating * will be (1 - soundWeight). * * Usage example: * ```javascript * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning); * chordFactory.sortPlayableChordsByCombinedRating(0.7); * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating * ``` * * @throws {Error} If `soundWeight` is not a number between 0 and 1. */ sortPlayableChordsByCombinedRating(soundWeight = 0) { if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) { throw new Error("soundWeight must be a number between 0 and 1."); } console.log("Sorting...") this.playableChords.sort((a, b) => { let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight)); let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight)); return bCombinedRating - aCombinedRating; }); } }

File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { settings } from './constants.js'; 

File: constants.js
Path: chord-factory\constants.js

// constants.js export const BARRE_RATING = 1 export const MAX_FRETS = 24 /** * Class representing application settings. */ class Settings { /** * Create a settings object with default values. */ constructor() { this._tuning = [40, 45, 50, 55, 59, 64]; this._fingerFretRange = 4; } /** * Get the current tuning values. * @returns {number[]} The current tuning values as an array of integers. */ get tuning() { return this._tuning; } /** * Set new tuning values. * @param {number[]} value - An array of integers representing the new tuning values. * @throws {Error} Throws an error if the value is not an array of integers. */ set tuning(value) { if (Array.isArray(value) && value.every(num => Number.isInteger(num))) { this._tuning = value; } else { throw new Error(__PRESERVED__0__); } } /** * Get the current finger fret range. * @returns {number} The current finger fret range as a positive integer. */ get fingerFretRange() { return this._fingerFretRange; } /** * Set a new finger fret range. * @param {number} value - A positive integer representing the new finger fret range. * @throws {Error} Throws an error if the value is not a positive integer. */ set fingerFretRange(value) { if (Number.isInteger(value) && value > 0) { this._fingerFretRange = value; } else { throw new Error("Invalid fingerFretRange value. It must be a positive integer."); } } } export const settings = new Settings();

File: main.js
Path: chord-factory\main.js

import { settings } from './constants.js'; import { parseNotes, removeDuplicateArrays } from './utils.js'; import { ChordFactory } from './chordfactory.js'; let totalDuration = 0; const repetitions = 50; let lastPlayChords; for (let i = 0; i < repetitions; i++) { const startTime = performance.now(); const chord = new ChordFactory("E, G, B", 4, true, settings.tuning); const playableChords = chord.playableChords if (i === repetitions - 1) { // Only save the last result lastPlayChords = playableChords; } const endTime = performance.now(); totalDuration += endTime - startTime; // Calculate the duration for this iteration } // Sort lastPlayChords by difficulty if (lastPlayChords && lastPlayChords.length > 0) { lastPlayChords.sort((a, b) => a.rating - b.rating); } lastPlayChords.forEach((chord) => console.log(chord)); // Calculate the average time const averageTime = totalDuration / repetitions; console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);

File: timingtext.js
Path: chord-factory\timingtext.js

const MAX_FRETS = 12; function generateFixedVoicing() { return [ [0, 2, 2, 1, 0, 0], [3, 2, 0, 0, 3, 3], [0, 3, 2, 0, 1, 0], [-1, -1, 0, 2, 3, 2], [3, 2, 0, 0, 1, 0] ]; } function generateFixedChords(numChords) { const fixedVoicing = generateFixedVoicing(); const chords = []; for (let i = 0; i < numChords; i++) { chords.push(fixedVoicing[i % fixedVoicing.length]); } return chords; } function filterPlayableChordsWithSet(allChordsCopy) { const startTime = performance.now(); allChordsCopy.forEach(voicing => { let touchedIndices = new Set(); for (let string = 0; string < 6; string++) { if (voicing[string] > 0) { touchedIndices.add(`${voicing[string]}-${string}`); } } }); const endTime = performance.now(); return endTime - startTime; } function filterPlayableChordsWithArrayCheck(allChordsCopy) { const startTime = performance.now(); allChordsCopy.forEach(voicing => { let touchedIndices = []; for (let string = 0; string < 6; string++) { if (voicing[string] > 0) { let index = `${voicing[string]}-${string}`; if (!touchedIndices.includes(index)) { touchedIndices.push(index); } } } }); const endTime = performance.now(); return endTime - startTime; } const numChords = 10000; const allChordsCopy = generateFixedChords(numChords); const timeWithSet = filterPlayableChordsWithSet(allChordsCopy); const timeWithArrayCheck = filterPlayableChordsWithArrayCheck(allChordsCopy); console.log(`Time taken with Set: ${timeWithSet} milliseconds`); console.log(`Time taken with Array Check: ${timeWithArrayCheck} milliseconds`);

File: utils.js
Path: chord-factory\utils.js

// Mapping of musical notes to their respective index numbers export const NOTE_INDEX_MAP = { __PRESERVED__0__: 0, __PRESERVED__1__: 1, __PRESERVED__2__: 1, __PRESERVED__3__: 2, __PRESERVED__4__: 3, __PRESERVED__5__: 3, __PRESERVED__6__: 4, __PRESERVED__7__: 4, __PRESERVED__8__: 5, __PRESERVED__9__: 6, __PRESERVED__10__: 6, __PRESERVED__11__: 7, __PRESERVED__12__: 8, __PRESERVED__13__: 8, __PRESERVED__14__: 9, __PRESERVED__15__: 10, __PRESERVED__16__: 10, __PRESERVED__17__: 11, __PRESERVED__18__: 11 }; // Reverse mapping for number to note conversion const NOTE_ARRAY = [__PRESERVED__19__, __PRESERVED__20__, __PRESERVED__21__, __PRESERVED__22__, __PRESERVED__23__, __PRESERVED__24__, __PRESERVED__25__, __PRESERVED__26__, __PRESERVED__27__, __PRESERVED__28__, __PRESERVED__29__, __PRESERVED__30__]; // Convert a note to its respective index number export function noteToNumber(note) { const normalizedNote = note.toUpperCase().replace(/[\s#]+/g, __PRESERVED__31__).replace(/[\sB]+/g, __PRESERVED__32__); return NOTE_INDEX_MAP.hasOwnProperty(normalizedNote) ? NOTE_INDEX_MAP[normalizedNote] : __PRESERVED__33__; } // Convert a number to its respective musical note export function numberToNote(number) { return NOTE_ARRAY[number % 12]; } export function parseNotes(input) { return input.toUpperCase() .replace(/B#/g, __PRESERVED__34__).replace(/E#/g, __PRESERVED__35__) .split(/[\s,]+/) .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note)); } export function removeDuplicateArrays(arrays) { const uniqueArrays = new Set(); return arrays.filter(array => { const serialized = JSON.stringify(array); if (!uniqueArrays.has(serialized)) { uniqueArrays.add(serialized); return true; } return }); }

File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js"; export class Chord { constructor(rootNote, notes, name, customRoot) { this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc. this.notes = notes; // Array of integers representing notes of the chord this.name = name; // String representing the full name of the chord, e.g., __PRESERVED__1__, __PRESERVED__2__ this.customRoot = customRoot console.log(__PRESERVED__3__ + this.name + __PRESERVED__4__ + this.rootNote + __PRESERVED__5__ + this.notes) } } export class ChordLibrary { constructor() { this.chords = []; this.noteNames = [__PRESERVED__6__, __PRESERVED__7__, __PRESERVED__8__, __PRESERVED__9__, __PRESERVED__10__, __PRESERVED__11__, __PRESERVED__12__, __PRESERVED__13__, __PRESERVED__14__, __PRESERVED__15__, __PRESERVED__16__, __PRESERVED__17__]; this.chordStructures = { __PRESERVED__18__: { notes: [0, 4, 7], priority: 1 }, // Major __PRESERVED__19__: { notes: [0, 3, 7], priority: 2 }, // Minor __PRESERVED__20__: { notes: [0, 4, 7, 10], priority: 3 }, // Dominant 7th __PRESERVED__21__: { notes: [0, 4, 7, 11], priority: 4 }, // Major 7th __PRESERVED__22__: { notes: [0, 3, 7, 10], priority: 5 }, // Minor 7th __PRESERVED__23__: { notes: [0, 3, 7, 11], priority: 18 }, // Minor Major 7th __PRESERVED__24__: { notes: [0, 2, 7], priority: 7 }, // Suspended 2nd __PRESERVED__25__: { notes: [0, 5, 7], priority: 6 }, // Suspended 4th __PRESERVED__26__: { notes: [0, 3, 6], priority: 9 }, // Diminished __PRESERVED__27__: { notes: [0, 4, 8], priority: 8 }, // Augmented __PRESERVED__28__: { notes: [0, 4, 7, 10, 14], priority: 11 }, // Dominant 9th __PRESERVED__29__: { notes: [0, 4, 7, 11, 14], priority: 12 }, // Major 9th __PRESERVED__30__: { notes: [0, 3, 7, 10, 14], priority: 13 }, // Minor 9th __PRESERVED__31__: { notes: [0, 4, 7, 10, 14, 17], priority: 16 }, // Dominant 11th __PRESERVED__32__: { notes: [0, 4, 7, 10, 14, 17, 21], priority: 24 }, // Dominant 13th __PRESERVED__33__: { notes: [0, 2, 4, 7], priority: 17 }, // Added 9th __PRESERVED__34__: { notes: [0, 3, 7, 9], priority: 14 }, // Minor 6th __PRESERVED__35__: { notes: [0, 4, 7, 9], priority: 15 }, // Major 6th __PRESERVED__36__: { notes: [0, 7], priority: 10 }, // Power chord __PRESERVED__37__: { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6/9 'm11': { notes: [0, 3, 7, 10, 14, 17], priority: 39 }, // Minor 11 __PRESERVED__39__: { notes: [0, 4, 7, 11, 18], priority: 29 }, // Major 7#11 __PRESERVED__40__: { notes: [0, 3, 6, 10], priority: 19 }, // Half-Diminished __PRESERVED__41__: { notes: [0, 4, 8, 10], priority: 21 }, // Augmented 7th __PRESERVED__42__: { notes: [0, 3, 6, 9], priority: 20 }, // Diminished 7th __PRESERVED__43__: { notes: [0, 4, 8, 11], priority: 28 }, // Augmented Major 7th __PRESERVED__44__: { notes: [0, 3, 7, 11, 14], priority: 18 }, // Minor Major 9th __PRESERVED__45__: { notes: [0, 3, 6, 11], priority: 22 }, // Diminished Major 7th __PRESERVED__46__: { notes: [0, 4, 6, 10, 13], priority: 23 }, // Altered Dominant __PRESERVED__47__: { notes: [0, 4, 7, 11, 14, 17, 21], priority: 24 }, // Major 13th __PRESERVED__48__: { notes: [0, 4, 7, 11, 14, 17], priority: 25 }, // Major 11th __PRESERVED__49__: { notes: [0, 5, 7, 11], priority: 26 }, // Major 7th Suspended 4th __PRESERVED__50__: { notes: [0, 3, 8, 10], priority: 27 }, // Minor 7th #5 __PRESERVED__51__: { notes: [0, 4, 8], priority: 28 }, // Major #5 __PRESERVED__52__: { notes: [0, 4, 7, 10, 14, 18], priority: 29 }, // Dominant 9th #11 __PRESERVED__53__: { notes: [0, 4, 7, 10, 14, 18, 21], priority: 30 }, // Dominant 13th #11 __PRESERVED__54__: { notes: [0, 4, 6, 10], priority: 31 }, // Dominant 7th Flat Five __PRESERVED__55__: { notes: [0, 4, 6, 11], priority: 32 }, // Major 7th Flat Five __PRESERVED__56__: { notes: [0, 4, 8, 11], priority: 33 }, // Major 7th Sharp Five __PRESERVED__57__: { notes: [0, 3, 7, 10, 13], priority: 34 }, // Minor 7th Flat Nine __PRESERVED__58__: { notes: [0, 4, 6, 10, 14], priority: 34 }, // 9th Flat Five __PRESERVED__59__: { notes: [0, 4, 8, 10, 14], priority: 35 }, // 9th Sharp Five __PRESERVED__60__: { notes: [0, 4, 7, 10, 13], priority: 36 }, // Dominant 7th Flat Nine __PRESERVED__61__: { notes: [0, 4, 7, 10, 15], priority: 37 }, // Dominant 7th Sharp Nine __PRESERVED__62__: { notes: [0, 4, 7, 10, 18], priority: 38 }, // Dominant 7th Sharp Eleven __PRESERVED__63__: { notes: [0, 3, 7, 10, 17], priority: 39 }, // Minor 7th Add 11 __PRESERVED__64__: { notes: [0, 2, 4, 7], priority: 40 }, // Major Add 2 __PRESERVED__65__: { notes: [0, 4, 5, 7], priority: 41 }, // Major Add 4 __PRESERVED__66__: { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6 Add 9 __PRESERVED__67__: { notes: [0, 4, 7], root: 0, priority: 43 }, // C Major __PRESERVED__68__: { notes: [0, 3, 7], root: 0, priority: 44 }, // C Minor __PRESERVED__69__: { notes: [0, 4, 7], root: 1, priority: 43 }, // C# Major __PRESERVED__70__: { notes: [0, 3, 7], root: 1, priority: 44 }, // C# Minor __PRESERVED__71__: { notes: [0, 4, 7], root: 2, priority: 43 }, // D Major __PRESERVED__72__: { notes: [0, 3, 7], root: 2, priority: 44 }, // D Minor __PRESERVED__73__: { notes: [0, 4, 7], root: 3, priority: 43 }, // D# Major __PRESERVED__74__: { notes: [0, 3, 7], root: 3, priority: 44 }, // D# Minor __PRESERVED__75__: { notes: [0, 4, 7], root: 4, priority: 43 }, // E Major __PRESERVED__76__: { notes: [0, 3, 7], root: 4, priority: 44 }, // E Minor __PRESERVED__77__: { notes: [0, 4, 7], root: 5, priority: 43 }, // F Major __PRESERVED__78__: { notes: [0, 3, 7], root: 5, priority: 44 }, // F Minor __PRESERVED__79__: { notes: [0, 4, 7], root: 6, priority: 43 }, // F# Major __PRESERVED__80__: { notes: [0, 3, 7], root: 6, priority: 44 }, // F# Minor __PRESERVED__81__: { notes: [0, 4, 7], root: 7, priority: 43 }, // G Major __PRESERVED__82__: { notes: [0, 3, 7], root: 7, priority: 44 }, // G Minor __PRESERVED__83__: { notes: [0, 4, 7], root: 8, priority: 43 }, // G# Major __PRESERVED__84__: { notes: [0, 3, 7], root: 8, priority: 44 }, // G# Minor __PRESERVED__85__: { notes: [0, 4, 7], root: 9, priority: 43 }, // A Major __PRESERVED__86__: { notes: [0, 3, 7], root: 9, priority: 44 }, // A Minor __PRESERVED__87__: { notes: [0, 4, 7], root: 10, priority: 43 }, // A# Major __PRESERVED__88__: { notes: [0, 3, 7], root: 10, priority: 44 }, // A# Minor __PRESERVED__89__: { notes: [0, 4, 7], root: 11, priority: 43 }, // B Major __PRESERVED__90__: { notes: [0, 3, 7], root: 11, priority: 44 } // B Minor }; this.generateChords(); } generateChords() { Object.entries(this.chordStructures).forEach(([suffix, structure]) => { for (let i = 0; i < 12; i++) { let rootNote = i let customRoot = false let notes = structure.notes.map(interval => (i + interval) % 12); const chordName = __PRESERVED__91__; if (structure.root !== undefined) { // Filter Dumb Chord Like C/C D/D if (structure.root == rootNote) { continue; } rootNote = structure.root; customRoot = true; notes.push(rootNote); } const chord = new Chord(rootNote, notes, chordName, customRoot); chord.priority = structure.priority; this.chords.push(chord); } }); // Sort chords by priority this.chords.sort((a, b) => a.priority - b.priority); } async searchChords(noteArray, rootNote, threshold = 50) { console.log(__PRESERVED__92__) const results = []; noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave if (rootNote) { rootNote = rootNote % 12 } const inputNotesSet = new Set(noteArray); this.chords.forEach(chord => { let chordNotes = [...chord.notes]; //console.log(__PRESERVED__93__ + chord.name) //Add the Root note to the Chords For Cases like A/D //console.log(__PRESERVED__94__, inputNotesSet); const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note))); //console.log(__PRESERVED__95__, commonNotes); const totalUniqueNotes = new Set([...chordNotes, ...noteArray]); //console.log(__PRESERVED__96__, totalUniqueNotes); let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100; //console.log(__PRESERVED__97__ + rootNote + __PRESERVED__98__ + chord.rootNote); // Adjusting match percentage based on root note comparison if (rootNote !== null) { if (chord.rootNote == rootNote) { //console.log(__PRESERVED__99__ + chord.name + __PRESERVED__100__ + chord.rootNote + __PRESERVED__101__ + chordNotes) // If root notes match, this is fine as calculated } else { // Penalize the match percentage slightly if root notes don't match matchPercentage *= 0.85; // Penalize by 10% //console.log("Panelized for not matching Root") } } else { //If a Custom Root in the CHord Details is specified but the user hasnt put a custom root if (chord.customRoot == true) { matchPercentage *= 0.85; // Penalize by 10% //console.log("Panelized For Havinng Specific when it shouldnt") } } if (matchPercentage >= threshold) { results.push( new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2))) ); } }); // Sort results by probability in descending order return results.sort((a, b) => b.probability - a.probability); } getAllChords() { // Return all chord names in a simplified object format return this.chords; } getChordByName(name) { const chord = this.chords.find(chord => chord.name === name); if (chord) { //console.log('Chord found:', chord); return chord; } else { //console.log('No chord found with the name:', name); return null; } } }

File: index.html
Path: chordviewer\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Piano2Guitar</title> <!-- STYLESHEETS --> <link rel="stylesheet" href="../piano/style.css" /> <link rel="stylesheet" href="../progression-generator/style.css" /> <link rel="stylesheet" href="../css/output-styles.css" /> <link rel="stylesheet" href="../css/input-styles.css" /> <link rel="stylesheet" href="../css/slider-styles.css" /> <link rel="stylesheet" href="../css/settings-styles.css" /> <link rel="stylesheet" href="styles.css" /> <!-- FONT --> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet"> <!-- SCRIPTS --> <script type="module" src="./index.js"></script> </head> <body> <div class="inputWrapper"> <div class="header"> PianoToGuitar.com - ChordViewer <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" /> </svg> </div> <div class="searchContainer"> <div class="searchContainerWrapper"> <div class="searchContainer"> <div class="searchWordContainer"> <div class="blackFadeBottom"></div> <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name..."> <div class="searchChordList" id="itemsContainer"> <!-- Items will be populated here by JavaScript --> </div> </div> </div> </div> <div class="selectedItemWrapper"> <div class="selectedItemsHeading"> <div>Your Selected Chord</div> </div> <div class="selectedItemsWrapper"> <div class="selectedItems" id="selectedItems"> <!-- Dragged items will appear here --> </div> <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> </div> </div> <div class="outputWrapper" id="outputWrapper"> <div class="progression"> <div class="progressionWrapper" id="dynamicProgressionWrapper"></div> <div class="progressionInfo"> <div class="progressionInfoText"> <div class="progressionInfoTextName"><i>DYNAMIC</i></div> <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the most beautifully sounding ones! </div> </div> <div class="soundQualityWrapper"> <input id="soundQualitySlider" type="range" min="0" max="100" value="50"> <div class="soundQualityLables"> <div>EASY</div> <div>BEST SOUND</div> </div> </div> </div> </div> </body> </html>

File: index.js
Path: chordviewer\index.js

import DragAndDropList from '../drag-drop/script.js'; import { ChordLibrary } from "../chord-library/script.js" import { ProgressionGenerator } from '../progression-generator/main.js'; import { settings } from '../chord-factory/constants.js'; document.addEventListener('DOMContentLoaded', () => { // Get All Chords From the Libaray const chordLibrary = new ChordLibrary // Create the Search and Drag and Drop const allChordLibraryItems = chordLibrary.getAllChords() const dropzone = __PRESERVED__5__; const itemsContainer = __PRESERVED__6__; const itemSearch = __PRESERVED__7__; const selectedItems = __PRESERVED__8__; const emptyMessageContainer = __PRESERVED__9__; const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer); window.clearProgression = function () { dragAndDropList.clearSelectedList(); console.log(__PRESERVED__10__); }; let soundQualityValue = 1; let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, __PRESERVED__11__, __PRESERVED__12__, true) document.addEventListener(__PRESERVED__13__, async function (event) { console.log(__PRESERVED__14__, event.detail.selectedItems[0]); await progressionGenerator.setProgression([event.detail.selectedItems[0]]) await updateProgressionDynamic(soundQualityValue) dragAndDropList.clearSelectedList(); }); const soundQualitySlider = document.getElementById(__PRESERVED__15__); soundQualitySlider.addEventListener(__PRESERVED__16__, async (e) => { soundQualityValue = e.target.value / 100; console.log("Slider Value:", soundQualityValue); await updateProgressionDynamic(soundQualityValue) }); async function updateProgressionDynamic(soundQualityValue) { let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue, 20); document.getElementById("dynamicProgressionWrapper").innerHTML = ""; document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML); }; 

File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs'); const path = require('path'); function isHtmlOrJsFile(file) { return file.endsWith('.html') || file.endsWith('.js'); } function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') { const items = fs.readdirSync(dir); items.forEach(item => { const fullPath = path.join(dir, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { fileStructure[item] = {}; getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item)); } else if (isHtmlOrJsFile(item)) { fileStructure[item] = { path: fullPath, relativePath: path.join(parentPath, item), size: stats.size, lastModified: stats.mtime }; } }); return fileStructure; } function removeWhitespace(text) { return text.replace(/\s+/g, __PRESERVED__5__).trim(); } function removeComments(text) { const singleLineCommentPattern = /\/\/.*(?=[\n\r]|$)/g; const multiLineCommentPattern = /\/\*[\s\S]*?\*\//g; const stringPattern = /(['"`])(?:(?!\1|\\).|\\.)*\1/g; const regexPattern = /\/(?!\*)[^/\\\n]+\/[gimsuy]*/g; // Improved regex for JS regex patterns // Preserve strings and regex to avoid removing comment-like patterns within them const preservedItems = []; let preservedText = text.replace(stringPattern, match => { preservedItems.push(match); return `__PRESERVED__${preservedItems.length - 1}__`; }).replace(regexPattern, match => { preservedItems.push(match); return `__PRESERVED__${preservedItems.length - 1}__`; }); // Remove comments preservedText = preservedText.replace(singleLineCommentPattern, ''); preservedText = preservedText.replace(multiLineCommentPattern, ''); // Restore strings and regex patterns preservedText = preservedText.replace(/__PRESERVED__(\d+)__/g, (_, index) => preservedItems[Number(index)]); return preservedText; } function readAllFiles(dir, parentPath = '', removeWhitespaceSetting = false, removeCommentsSetting = false) { let allText = ''; const items = fs.readdirSync(dir); items.forEach(item => { const fullPath = path.join(dir, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { allText += readAllFiles(fullPath, path.join(parentPath, item), removeWhitespaceSetting, removeCommentsSetting); } else if (isHtmlOrJsFile(item)) { let fileContent = fs.readFileSync(fullPath, 'utf8'); if (removeWhitespaceSetting) { fileContent = removeWhitespace(fileContent); } if (removeCommentsSetting && item.endsWith('.js')) { fileContent = removeComments(fileContent); } allText += `File: ${item}\n`; allText += `Path: ${path.join(parentPath, item)}\n\n`; allText += fileContent + '\n\n'; } }); return allText; } function formatStructure(fileStructure, indent = 0) { let structureText = ''; const indentString = ' '.repeat(indent); for (const key in fileStructure) { if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) { const { relativePath, size, lastModified } = fileStructure[key]; structureText += `${indentString}${key} (Path: ${relativePath}, Size: ${size} bytes)\n`; } else { structureText += `${indentString}${key}/\n`; structureText += formatStructure(fileStructure[key], indent + 2); } } return structureText; } try { const targetDir = path.join(__dirname, ''); // Change '' to your target folder const outputFilePath = path.join(__dirname, 'output.txt'); const removeWhitespaceSetting = true; // Set to true to remove whitespace const removeCommentsSetting = true; // Set to true to remove comments // Get the folder and file structure const fileStructure = getDirectoryStructure(targetDir); // Format the structure to a string const structureText = formatStructure(fileStructure); // Read all the text from HTML and JS files const filesText = readAllFiles(targetDir, '', removeWhitespaceSetting, removeCommentsSetting); // Combine structure and file texts const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`; // Write the final output to a file fs.writeFileSync(outputFilePath, finalOutput); console.log('Folder structure and file contents have been saved to output.txt'); } catch (error) { console.error('Error reading directory:', error.message); }

File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js"; export class DragAndDropItem extends Chord { constructor(chord, probability = -1) { super(chord) this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc. this.notes = chord.notes; // Array of integers representing notes of the chord this.name = chord.name; // String representing the full name of the chord, e.g., __PRESERVED__1__, __PRESERVED__2__ this.customRoot = chord.customRoot this.probability = probability } } export default class DragAndDropList { constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) { this.items = [] this.idCounter = 0; items.forEach(item => { this.items.push(new DragAndDropItem(item)) }) this.dropzoneId = dropzoneId; this.selectedItemsEvent = new CustomEvent(__PRESERVED__3__, { bubbles: true, detail: { selectedItems: [] } }); this.emptyMessageContainer = document.getElementById(emptyMessage); this.itemsContainer = document.getElementById(itemsContainer); this.selectedItemsContainer = document.getElementById(selectedItems); this.itemFilterInput = document.getElementById(itemSearch); this.selectedItemsArray = []; this.addEventListeners(); this.populateItemsList(); this.emptyMessage = __PRESERVED__4__; this.emptyMessageElement = document.createElement(__PRESERVED__5__); this.emptyMessageElement.id = __PRESERVED__6__; const words = this.emptyMessage.split(__PRESERVED__7__); const baseElement = this.createItemElement({ name: __PRESERVED__8__ }); baseElement.draggable = false; baseElement.isSelectable = false; words.forEach(word => { const clone = baseElement.cloneNode(true); clone.innerHTML = word; this.emptyMessageElement.appendChild(clone); }); this.selectedItemsContainer.appendChild(this.emptyMessageElement); } addEventListeners() { window.addEventListener(__PRESERVED__9__, this.handleWindowDragOver.bind(this)); window.addEventListener(__PRESERVED__10__, this.handleWindowDrop.bind(this)); this.selectedItemsContainer.addEventListener(__PRESERVED__11__, this.allowDrop.bind(this)); this.selectedItemsContainer.addEventListener(__PRESERVED__12__, this.handleDropOnContainer.bind(this)); this.itemFilterInput.addEventListener(__PRESERVED__13__, this.filterItems.bind(this)); } handleWindowDragOver(e) { e = e || event; if (e.target.id !== this.dropzoneId) { e.preventDefault(); } } handleWindowDrop(e) { e = e || event; if (e.target.id !== this.dropzoneId) { e.preventDefault(); } } last100PercentItemIndex() { let lastIndex = -1; for (let i = 0; i < this.items.length; i++) { if (this.items[i].probability === 100) { lastIndex = i; } } return lastIndex; } populateItemsList() { const lastIndex100Percent = this.last100PercentItemIndex(); let first100Percent = false; this.items.forEach((item, index) => { if (item.probability === 100 && !first100Percent) { first100Percent = true; const firstElement = document.createElement(__PRESERVED__14__); firstElement.style.width = __PRESERVED__15__; firstElement.innerHTML = __PRESERVED__16__; firstElement.style.backgroundColor = __PRESERVED__17__; firstElement.style.color = __PRESERVED__18__; firstElement.style.fontSize = __PRESERVED__19__; this.itemsContainer.appendChild(firstElement); } const itemElement = this.createItemElement(item, true); this.itemsContainer.appendChild(itemElement); if (index === lastIndex100Percent) { const breakElement = document.createElement(__PRESERVED__20__); breakElement.style.width = __PRESERVED__21__; breakElement.style.height = __PRESERVED__22__; breakElement.style.backgroundColor = __PRESERVED__23__; breakElement.style.boxShadow = __PRESERVED__24__; this.itemsContainer.appendChild(breakElement); } }); } createItemElement(item, isSelectable = false) { const itemElement = document.createElement(__PRESERVED__25__); itemElement.textContent = item.name; itemElement.className = __PRESERVED__26__; itemElement.id = __PRESERVED__27__; if (item.probability > 0) { const probabilitySpan = document.createElement(__PRESERVED__28__); probabilitySpan.textContent = __PRESERVED__29__; probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability); if (item.probability === 100) { itemElement.style.boxShadow = __PRESERVED__30__; itemElement.style.fontWeight = __PRESERVED__31__; } itemElement.appendChild(probabilitySpan); } if (isSelectable) { itemElement.addEventListener(__PRESERVED__32__, () => this.addSelectedItem(item)); } return itemElement; } getBackgroundColor(probability) { const startColor = [255, 130, 130]; const endColor = [230, 230, 30]; const winnerColor = [150, 200, 0]; probability = Math.max(50, Math.min(100, probability)); const scaledProbability = (probability - 50) / 50; const adjustedProbability = Math.log10(1 + 9 * scaledProbability); let blendedColor = startColor.map((component, index) => { return Math.round(component + (endColor[index] - component) * adjustedProbability); }); if (probability === 100) { blendedColor = winnerColor; } return `rgb(${blendedColor.join(',')})`; } createSelectedItemElement(item) { const selectedItemElement = document.createElement('div'); selectedItemElement.className = 'selected-dragDropItem dragDropItem'; selectedItemElement.draggable = true; selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`; selectedItemElement.textContent = item.name; selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this)); selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this)); selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this)); selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this)); selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this)); selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this)); return selectedItemElement; } removeSelectedItem(event) { event.target.remove(); this.updateArrayFromList(); } addSelectedItem(item) { this.selectedItemsArray.push(item); this.updateDisplayArray(); } updateItems(newItems) { console.log("Updating Library..."); this.clearList(); this.items = newItems; this.populateItemsList(); } clearList() { this.items = []; while (this.itemsContainer.firstChild) { this.itemsContainer.removeChild(this.itemsContainer.firstChild); } } clearSelectedList() { this.selectedItemsArray = []; while (this.selectedItemsContainer.firstChild) { this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild); } this.updateDisplayArray(); } handleDropOnItemList(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) { droppedItemElement.remove(); this.updateDisplayArray(); } } handleDragStart(event) { event.dataTransfer.setData('text/plain', event.target.id); if (event.target.classList.contains('selected-dragDropItem')) { event.target.classList.add('dragging'); } } handleDragOver(event) { event.preventDefault(); const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { targetElement.classList.add('over'); } } handleDragLeave(event) { event.preventDefault(); const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { targetElement.classList.remove('over'); } } handleDropReorder(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (!droppedItemElement) return; const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { if (droppedItemElement.classList.contains('selected-dragDropItem')) { this.insertAtCorrectPosition(droppedItemElement, targetElement); } } else { if (!droppedItemElement.classList.contains('selected-dragDropItem')) { const chordName = droppedItemElement.textContent.split(' (')[0]; const chord = this.items.find(item => item.name === chordName); if (chord) { const newClone = this.createSelectedItemElement(chord); this.selectedItemsContainer.appendChild(newClone); this.selectedItemsArray.push(chord); } } else { this.selectedItemsContainer.appendChild(droppedItemElement); this.updateDisplayArray(); } } this.updateDisplayArray(); } handleDragEnd(event) { event.target.classList.remove('dragging'); const overItems = document.querySelectorAll('.selected-dragDropItem'); overItems.forEach(item => item.classList.remove('over')); } allowDrop(event) { event.preventDefault(); } handleDropOnContainer(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) { const chordName = droppedItemElement.textContent.split(' (')[0]; const chord = this.items.find(item => item.name === chordName); if (chord) { const newClone = this.createSelectedItemElement(chord); this.selectedItemsContainer.appendChild(newClone); this.selectedItemsArray.push(chord); this.updateDisplayArray(); } } } insertAtCorrectPosition(droppedItemElement, targetElement) { const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement); const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement); if (droppedIndex < targetIndex) { targetElement.after(droppedItemElement); } else { targetElement.before(droppedItemElement); } targetElement.classList.remove('over'); this.updateArrayFromList(); } updateArrayFromList(){ this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => { const chordName = el.textContent.split(' (')[0]; return this.items.find(item => item.name === chordName); }); this.updateDisplayArray(); } updateDisplayArray() { this.selectedItemsContainer.innerHTML = "" if (this.selectedItemsArray.length == 0) { if (!this.emptyMessageElement.parentNode) { this.selectedItemsContainer.appendChild(this.emptyMessageElement); } } else { this.emptyMessageElement.remove(); } this.selectedItemsArray.forEach(item => { const selectedItemElement = this.createSelectedItemElement(item); this.selectedItemsContainer.appendChild(selectedItemElement); }) this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray]; document.dispatchEvent(this.selectedItemsEvent); console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`); } filterItems() { const filterValue = this.itemFilterInput.value.toUpperCase(); const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem'); itemElements.forEach(itemElement => { const itemText = itemElement.textContent.toUpperCase(); itemElement.style.display = itemText.includes(filterValue) ? '' : 'none'; }); } getArray() { return [...this.selectedItemsArray]; } }

File: index.html
Path: index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Piano2Guitar</title> <!-- STYLESHEETS --> <link rel="stylesheet" href="piano/style.css" /> <link rel="stylesheet" href="progression-generator/style.css" /> <link rel="stylesheet" href="css/output-styles.css" /> <link rel="stylesheet" href="css/input-styles.css" /> <link rel="stylesheet" href="css/slider-styles.css" /> <link rel="stylesheet" href="css/settings-styles.css" /> <!-- FONT --> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet"> <!-- SCRIPTS --> <script type="module" src="./settings.js"></script> <script type="module" src="./index.js"></script> </head> <body> <div class="inputWrapper"> <div id="closeSettings" onClick="toggleSettings()"></div> <div id="settings"> <div class="settingsHeader">Settings</div> <div class="settingsContent"> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div>Guitar Tuning</div> </div> <div class="settingSubDescription"> Choose a preset tuning from the dropdown or adjust each string's pitch with the sliders. </div> </div> <select id="settingsCommonTunings" onchange="setTuning(this.value)"> <option value="E A D G B E">Standard (E A D G B E)</option> <option value="D A D G B E">Drop D (D A D G B E)</option> <option value="D A D G A D">DADGAD (D A D G A D)</option> <option value="D G D G B D">Open G (D G D G B D)</option> <option value="D A D F# A D">Open D (D A D F# A D)</option> <option value="E B E G# B E">Open E (E B E G# B E)</option> <option value="C G C G C E">Open C (C G C G C E)</option> <option value="D A D G B D">Double Drop D (D A D G B D)</option> <option value="">Custom</option> </select> <div class="settingsStringTuning"> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue6">A</div> <input class="settingsStringSlider string6" id="settingsString6" type="range" min="0" max="12" value="0"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue5">A</div> <input class="settingsStringSlider string5" id="settingsString5" type="range" min="0" max="12" value="0"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue4">A</div> <input class="settingsStringSlider string4" id="settingsString4" type="range" min="0" max="12" value="0"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue3">A</div> <input class="settingsStringSlider string3" id="settingsString3" type="range" min="0" max="12" value="0"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue2">A</div> <input class="settingsStringSlider string2" id="settingsString2" type="range" min="0" max="12" value="0"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue1">A</div> <input class="settingsStringSlider string1" id="settingsString1" type="range" min="0" max="12" value="0"> </div> </div> </div> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div>Maximum Fret Range</div> </div> <div class="settingSubDescription"> Choose the ammunt of Frets a Chord can have. </div> </div> <div class="settingsFretWrapper"> <div class="settingsFretSliderWrapper"> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar selected">1</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">2</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">3</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">4</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">5</div> <div class="settingsFretBarSeparator"></div> </div> <div id="settingsFretValue">4 Frets</div> </div> </div> </div> </div> <div class="header"> PianoToGuitar.com <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" /> </svg> </div> <div class="searchContainer"> <div class="visualPianoContainer"> <div class="pianoMIDIWrapper"> <div class="pianoContainer"></div> <div id="MIDIStatusDiv"> Initializing MIDI... </div> </div> <div class="pianoIconContainer"> <svg class="visualPianoIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24"> <path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" /> </svg> <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" /> </svg> <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> <div class="searchWordContainer"> <div class="blackFadeBottom"></div> <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name..."> <div class="searchChordList" id="itemsContainer"> <!-- Items will be populated here by JavaScript --> </div> </div> </div> <div class="selectedItemsHeading"> <div>Your Selected Progression</div> <div id="scaleDisplay"></div> </div> <div class="selectedItemsWrapper"> <div class="selectedItems" id="selectedItems"> <!-- Dragged items will appear here --> </div> <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> <div class="outputWrapper" id="outputWrapper"> <div class="progression"> <div class="progressionWrapper" id="dynamicProgressionWrapper"></div> <div class="progressionInfo"> <div class="progressionInfoText"> <div class="progressionInfoTextName"><i>DYNAMIC</i></div> <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the most beautifully sounding ones! </div> </div> <div class="soundQualityWrapper"> <input id="soundQualitySlider" type="range" min="0" max="100" value="50"> <div class="soundQualityLables"> <div>EASY</div> <div>BEST SOUND</div> </div> </div> </div> </div> </body> </html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js'; import Piano from './piano/script.js'; import { Chord, ChordLibrary } from "./chord-library/script.js" import MIDIAccessManager from "./midi-integration/script.js" import { ProgressionGenerator } from './progression-generator/main.js'; import { settings } from './chord-factory/constants.js'; import { noteToNumber, numberToNote } from "./chord-factory/utils.js"; document.addEventListener('DOMContentLoaded', () => { function debounce(func, wait) { let timeout; return function () { const context = this, args = arguments; clearTimeout(timeout); timeout = setTimeout(() => { func.apply(context, args); }, wait); }; } // Import the MidiManager const midiManager = new MIDIAccessManager(); var visualPianoOctaves = 3 // Function to calculate the number of octaves based on screen width function calculateOctaves() { const screenWidth = window.innerWidth; console.log((Math.sqrt(screenWidth))) const maxOctaves = 3; // Base octaves to start with const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25); visualPianoOctaves = Math.min(maxOctaves, extraOctaves) return visualPianoOctaves; } // Create a new Piano instance with dynamic number of octaves const myPiano = new Piano(__PRESERVED__8__, { octaves: calculateOctaves() }); // Get All Chords From the Libaray const chordLibrary = new ChordLibrary // Create the Search and Drag and Drop const allChordLibraryItems = chordLibrary.getAllChords() const dropzone = __PRESERVED__9__; const itemsContainer = __PRESERVED__10__; const itemSearch = __PRESERVED__11__; const selectedItems = __PRESERVED__12__; const emptyMessageContainer = __PRESERVED__13__; const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer); var isVolumeOn = localStorage.getItem(__PRESERVED__14__) === __PRESERVED__15__ ? false : true; const volumeIcon = document.getElementById(__PRESERVED__16__); updateVolumeIcon(); // Update the icon at load window.toggleVolume = function () { if (isVolumeOn) { myPiano.volumeOff(); // Turn volume off isVolumeOn = false; localStorage.setItem(__PRESERVED__17__, __PRESERVED__18__); } else { myPiano.volumeOn(); // Turn volume on isVolumeOn = true; localStorage.setItem(__PRESERVED__19__, __PRESERVED__20__); } updateVolumeIcon(); }; function updateVolumeIcon() { if (!isVolumeOn) { volumeIcon.innerHTML = __PRESERVED__21__; } else { volumeIcon.innerHTML = __PRESERVED__22__; } } window.playPiano = function () { myPiano.playChord(); console.log(__PRESERVED__23__); }; window.clearPiano = function () { document.getElementById(__PRESERVED__24__).value = __PRESERVED__25__ myPiano.clearPiano(); console.log(__PRESERVED__26__); }; window.clearProgression = function () { dragAndDropList.clearSelectedList(); console.log(__PRESERVED__27__); }; // Handle window resize to adjust the number of octaves dynamically window.onresize = function () { const newOctaves = calculateOctaves(); myPiano.setOctaves(newOctaves); // Assuming there__PRESERVED__28__.pianoContainer__PRESERVED__29__notesChanged__PRESERVED__30__Piano notes changed:__PRESERVED__31__noteOn__PRESERVED__32__noteOff__PRESERVED__33__notesOutput__PRESERVED__34__scaleDetected__PRESERVED__35__selectedItemsUpdated__PRESERVED__36__Updated Selected Items:__PRESERVED__37__input__PRESERVED__38__visible__PRESERVED__39__visible__PRESERVED__40__visible__PRESERVED__41__guitarTuning__PRESERVED__42__guitarTuning__PRESERVED__43__guitarTuning__PRESERVED__44__input__PRESERVED__45__settingsCommonTunings__PRESERVED__46__ __PRESERVED__47__settingsCommonTunings__PRESERVED__48__change__PRESERVED__49__settingsCommonTunings__PRESERVED__50__ __PRESERVED__51__settingsFretValue__PRESERVED__52__fretRange__PRESERVED__53__.settingsFretBar__PRESERVED__54__selected__PRESERVED__55__data-fret__PRESERVED__56__selected__PRESERVED__57__data-fret__PRESERVED__58__.settingsFretBar__PRESERVED__59__click__PRESERVED__60__fretRange__PRESERVED__61__fretRange')); setFretRange(storedFretRange); console.log(__PRESERVED__62__, storedFretRange); } } // Initialize the fret range setting loadFretRangeSetting(); })

File: index.html
Path: midi-integration\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>MIDI Note Logger</title> </head> <body> <h1>MIDI Note Logger</h1> <div id="status">Waiting for MIDI...</div> <div id="log"></div> <script src="script.js"></script> </body> </html>

File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager { constructor() { this.retryCount = 0; this.maxRetries = 50; this.notesPlayed = new Set(); this.activeNotes = new Set(); if (navigator.requestMIDIAccess) { this.attemptMIDIAccess(); } else { console.log("Web MIDI API not supported!"); } } attemptMIDIAccess() { navigator.requestMIDIAccess() .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this)) .catch(err => { console.error('Error accessing MIDI devices:', err); this.handleRetry(err); }); } onMIDISuccess(midiAccess) { this.updateStatus("MIDI ready..."); this.midiAccess = midiAccess; // Store midiAccess for later use midiAccess.onstatechange = this.updateDeviceState.bind(this); this.addMIDIInputs(midiAccess.inputs); } addMIDIInputs(inputs) { Array.from(inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this)); } onMIDIFailure() { this.updateStatus(__PRESERVED__3__); this.handleRetry(new Error(__PRESERVED__4__)); } handleRetry(err) { if (this.retryCount < this.maxRetries) { this.retryCount++; console.log(__PRESERVED__5__); setTimeout(() => this.attemptMIDIAccess(), 3000); // Retry after 3 seconds } else { console.error(__PRESERVED__6__); //No Midi Device Found this.updateStatus(__PRESERVED__7__); } } onMIDIMessage({ data: [command, note, velocity] }) { const eventDetail = { command, note, velocity }; if (command === 144 && velocity > 0) { if (this.activeNotes.size === 0) { // New session this.notesPlayed.clear(); } this.notesPlayed.add(note); this.activeNotes.add(note); window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail })); } else if (command === 128 || velocity === 0) { this.activeNotes.delete(note); window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail })); if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) { this.outputNotes(); } } } outputNotes() { const uniqueNotes = Array.from(this.notesPlayed); console.log(uniqueNotes); window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes })); } updateStatus(message) { window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message })); } updateDeviceState({ port }) { const status = `MIDI: ${port.name} ${port.state}`; this.updateStatus(status); window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } })); if (port.state === "disconnected" || port.state === "unavailable") { this.handleDisconnection(); } } handleDisconnection() { console.log("MIDI device disconnected. Attempting to reconnect..."); this.attemptMIDIAccess(); } } export default MIDIAccessManager;

File: script.js
Path: piano\script.js

class Piano { constructor(containerSelector, options = {}) { this.container = document.querySelector(containerSelector); this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50); this.octaves = options.octaves || 2; this.playedNotes = []; this.rootNote = null; // Add a property for the root note this.lastClickTime = 0; this.clickDelay = 300; // 300 milliseconds delay this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; this.keysPerOctave = this.layout.length; this.whiteKeyCount = this.layout.filter(x => x === 0).length; this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves); this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234; this.blackKeyHeight = 0.63; this.totalKeys = this.octaves * this.keysPerOctave; this.audioElements = []; this.volume = true this.globalVolume = 0.7; // Global volume set to maximum by default this.createPiano(); this.addKeyListeners(); } volumeOff() { this.volume = false this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; }); } volumeOn() { this.volume = true } updateVolume() { const activeCount = this.playedNotes.length; const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1; this.audioElements.forEach(audio => { if (!audio.paused) { // Only update audio elements that are currently playing audio.volume = volume; } }); } createPiano() { this.container.innerHTML = __PRESERVED__0__; // Clear existing piano keys let whiteCounter = 0; for (let index = 0; index < this.totalKeys; index++) { let key = document.createElement(__PRESERVED__1__); key.setAttribute(__PRESERVED__2__, index); if (this.layout[index % this.keysPerOctave] === 1) { key.classList.add(__PRESERVED__3__, __PRESERVED__4__); key.style.left = __PRESERVED__5__; key.style.width = __PRESERVED__6__; key.style.height = __PRESERVED__7__; key.style.boxSizing = __PRESERVED__8__; key.style.position = __PRESERVED__9__; } else { key.classList.add(__PRESERVED__10__, __PRESERVED__11__); key.style.boxSizing = __PRESERVED__12__; key.style.width = __PRESERVED__13__; whiteCounter++; } this.container.appendChild(key); this.audioElements[index] = new Audio(__PRESERVED__14__); this.audioElements[index].preload = __PRESERVED__15__; // This tells the browser to load the audio as soon as the page is loaded } } addKeyListeners() { this.container.querySelectorAll(__PRESERVED__16__).forEach(key => { key.addEventListener(__PRESERVED__17__, () => { //console.log(__PRESERVED__18__) let currentTime = Date.now(); const note = key.getAttribute(__PRESERVED__19__); if (this.rootNote === note) { key.classList.add(__PRESERVED__20__); key.classList.remove(__PRESERVED__21__); if (currentTime - this.lastClickTime > 200) { this.lastClickTime = currentTime; //console.log(__PRESERVED__22__+currentTime) } this.rootNote = null; } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) { this.playedNotes = this.playedNotes.filter(n => n !== note); key.classList.remove(__PRESERVED__23__); } else { if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); } key.classList.add(__PRESERVED__24__); this.playSoundLong(note, 0.75); } this.updatePlayedNotesDebounced(); }); key.addEventListener(__PRESERVED__25__, (event) => { //console.log(__PRESERVED__26__) const note = key.getAttribute(__PRESERVED__27__); if (this.rootNote === note) { key.classList.add(__PRESERVED__28__); key.classList.remove(__PRESERVED__29__); this.rootNote = null; } else { if (this.rootNote !== null) { this.container.querySelector(__PRESERVED__30__).classList.remove(__PRESERVED__31__); } let currentTime = Date.now(); if (currentTime - this.lastClickTime < 500) { } else { this.rootNote = note; if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); } key.classList.add(__PRESERVED__32__, __PRESERVED__33__); } } this.updatePlayedNotesDebounced(); }); }); } debounce(func, delay) { let timeoutId; return function (...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => { func.apply(this, args); }, delay); }; } playSoundLong(index, localVolume) { if (this.volume) { const audio = this.audioElements[index]; audio.volume = localVolume * this.globalVolume; // Apply global volume scaling if (!audio.paused) { audio.currentTime = 0; // Reset if it is already playing } audio.play(); } } playChord() { this.playedNotes.sort((a, b) => a - b); const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1); this.playedNotes.forEach((note, index) => { const randomDelay = Math.random() * 20; setTimeout(() => { this.playSoundLong(note, localVolume); }, 20 * index + randomDelay); }); } activateKey(index) { const key = this.container.querySelector(__PRESERVED__34__); if (!key.classList.contains(__PRESERVED__35__)) { key.classList.add(__PRESERVED__36__); this.playedNotes.push(index); this.updatePlayedNotesDebounced(); this.updateVolume(); // Adjust volume based on the new number of active notes } this.playSoundLong(index, 0.75); // Initial play sound with default volume } deactivateKey(index) { const key = this.container.querySelector(__PRESERVED__37__); if (key.classList.contains(__PRESERVED__38__)) { key.classList.remove(__PRESERVED__39__); this.playedNotes = this.playedNotes.filter(n => n !== index); this.updatePlayedNotesDebounced(); // Do not update volume here to keep it consistent with the number of keys pressed } } setRootNote(note) { const key = this.container.querySelector(__PRESERVED__40__); if (this.rootNote !== null) { // Remove rootNote class from the old root note this.container.querySelector(__PRESERVED__41__).classList.remove(__PRESERVED__42__); } this.rootNote = note; // Update the rootNote to the new note key.classList.add(__PRESERVED__43__, __PRESERVED__44__); // Add rootNote class to new root note if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); // Add root note to playedNotes if it__PRESERVED__45__rootNote__PRESERVED__46__notesChanged__PRESERVED__47__.key.selectedKey__PRESERVED__48__.key.rootNote').forEach(key => { key.classList.remove(__PRESERVED__49__); }); this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; }); this.updatePlayedNotes(); } setOctaves(newOctaves) { if (newOctaves !== this.octaves) { this.octaves = newOctaves; this.totalKeys = this.octaves * this.keysPerOctave; this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves); this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234; this.clearPiano(); this.createPiano(); this.addKeyListeners(); } } } export default Piano;

File: main.js
Path: progression-generator\main.js

import { settings, BARRE_RATING } from '../chord-factory/constants.js'; import { parseNotes, removeDuplicateArrays, NOTE_INDEX_MAP } from '../chord-factory/utils.js'; import { ChordFactory } from '../chord-factory/chordfactory.js'; import { Chord } from '../chord-library/script.js'; import { numberToNote } from '../chord-factory/utils.js'; import TabGenerator from "../tab-generator/script.js" import { TabHTML } from './tabhtml.js'; export class ProgressionGenerator { constructor(initialProgression = [], useRoot = true, color, fingerNumbers = "belowString", showOpenStrings = true) { this.tuning = settings.tuning; this.color = color; this.fingerNumbers = fingerNumbers; this.showOpenStrings = showOpenStrings; this.progression = []; this.progressionChords = []; this.useRoot = useRoot; // This flag determines if the root note should be the starting note this.chordFactoryMap = {}; // HashMap to store ChordFactory instances this.keyAnalysis = [] this.setProgression(initialProgression); this.progressionTypes = { basic: this.getProgressionBasic, // Add more progression types as methods here }; } addKeyAnalysis(root, keyscale, prob) { // Push a new object to the array with the analysis data this.keyAnalysis.push({ rootNote: root, scale: keyscale, probability: prob }); } analyzeKey() { this.keyAnalysis = [] //Define Possible Scales //Higher Prioroty means They get artifically boostes at the Raking const scaleStructures = { __PRESERVED__8__: { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 }, // Major Scale: C, D, E, F, G, A, B __PRESERVED__9__: { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 }, // Natural Minor Scale: A, B, C, D, E, F, G __PRESERVED__10__: { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 }, // Minor Pentatonic Scale: A, C, D, E, G __PRESERVED__11__: { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 }, // Major Pentatonic Scale: C, D, E, G, A __PRESERVED__12__: { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 }, // Harmonic Minor Scale: A, B, C, D, E, F, G# __PRESERVED__13__: { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 }, // Blues Scale: A, C, D, D#, E, G __PRESERVED__14__: { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 }, // Mixolydian Mode: G, A, B, C, D, E, F __PRESERVED__15__: { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, // Dorian Mode: D, E, F, G, A, B, C __PRESERVED__16__: { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, // Phrygian Mode: E, F, G, A, B, C, D __PRESERVED__17__: { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, // Lydian Mode: F, G, A, B, C, D, E __PRESERVED__18__: { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 } // Locrian Mode: B, C, D, E, F, G, A }; //Generate an Array of Notes and How often They are present let notesSet = Array(12).fill(0); this.progression.forEach(element => { element.notes.forEach(note => { notesSet[note]++ }) }) console.log(__PRESERVED__19__, notesSet) //Now GO through The NoteSet and Calucalte A Number for The Probability of the Key notesSet.forEach((scopeNote, index) => { //Only Look at occuring Notes if (scopeNote != 0) { //Loop Through the scaleStrucurtres and the notes array Object.keys(scaleStructures).forEach(key => { let ammountWeight = 0.01 let rootWeight = 0.01 //DO NOT CHANGE let distanceToRootWeight = 1 let keyProbability = 0 for (let relativeNote = 0; relativeNote < 11; relativeNote++) { if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) { keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight)) distanceToRootWeight += rootWeight } } this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority) }) } }) this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability); return } // Set initial progression with ChordFactory instances for each chord async setProgression(initialProgression) { //only do this if progression is there... if (!initialProgression) { return } this.progressionChords = initialProgression const newChordFactoryMap = {}; // Create or reuse ChordFactory instances initialProgression.forEach(chord => { if (chord instanceof Chord) { let chordFactory; if (this.chordFactoryMap[chord.name]) { chordFactory = this.chordFactoryMap[chord.name]; console.log(__PRESERVED__20__, chord.name); } else { chordFactory = new ChordFactory(chord, this.useRoot, this.tuning); console.log(__PRESERVED__21__, chord.name); } newChordFactoryMap[chord.name] = chordFactory; } else { console.error(__PRESERVED__22__); } }); // Update the hashmap and clear out unused ChordFactories this.chordFactoryMap = newChordFactoryMap; // Populate this.progression with references from the new map this.progression = initialProgression.map(chord => this.chordFactoryMap[chord.name]); if (this.progression.length > 1) { this.analyzeKey() console.log(__PRESERVED__23__, this.keyAnalysis) const event = new CustomEvent(__PRESERVED__24__, { detail: { scale: __PRESERVED__25__ + numberToNote(this.keyAnalysis[0].rootNote) + __PRESERVED__26__ + this.keyAnalysis[0].scale + __PRESERVED__27__ } }); console.log(__PRESERVED__28__ + numberToNote(this.keyAnalysis[0].rootNote) + __PRESERVED__29__ + this.keyAnalysis[0].scale) window.dispatchEvent(event); } else { const event = new CustomEvent(__PRESERVED__30__, { detail: { scale: __PRESERVED__31__ } }); console.log(__PRESERVED__32__) window.dispatchEvent(event); } } async reloadProgression() { this.tuning = settings.tuning; this.chordFactoryMap = {}; this.progression = [] this.setProgression(this.progressionChords); console.log(__PRESERVED__33__) } getProgression(type = __PRESERVED__34__) { if (this.progressionTypes[type]) { return this.progressionTypes[type].call(this); // Ensures the method is called with correct this context } else { console.error(__PRESERVED__35__); return []; } } getPlaceholderHTML() { const placeholderCount = 4; // Generate 1 to 3 placeholders const diagramsContainer = document.createElement(__PRESERVED__36__); // Container for chord diagrams diagramsContainer.style.opacity = 0.2 diagramsContainer.style.display = __PRESERVED__37__ for (let i = 0; i < placeholderCount; i++) { // Example placeholder data let voicing = [0, 0, 0, 0, 0, 0]; // Create a set to keep track of chosen indices (to ensure uniqueness) let indices = new Set(); // Randomly choose 4 unique indices while (indices.size < 4) { let index = Math.floor(Math.random() * voicing.length); indices.add(index); } // Populate the chosen indices with random numbers between -1 and 4 indices.forEach(index => { voicing[index] = Math.floor(Math.random() * 6) - 1; // Generates values from -1 to 4 }); const fingerPositions = [0, 0, 0, 0, 0, 0]; // Positions for C major const barreSize = 0; // No barre for this example // Assuming TabGenerator can handle this static data try { const chordDiagram = new TabGenerator(voicing, fingerPositions, 0, null, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings); const svg = chordDiagram.generateChordSVG(); diagramsContainer.appendChild(svg); } catch (error) { console.error(__PRESERVED__38__, error); } } const textContent = document.createElement(__PRESERVED__39__) textContent.innerHTML = __PRESERVED__40__ textContent.style.display = __PRESERVED__41__ textContent.style.alignItems = __PRESERVED__42__ diagramsContainer.appendChild(textContent); return diagramsContainer; // Return the container with all placeholder SVGs } getProgressionHTML(desiredClasses = [], progressionType = __PRESERVED__43__) { // Create an instance of ProgressionGenerator with the given progression and tuning const progression = this.getProgression(progressionType); // Get the basic progression const diagramsContainer = document.createElement(__PRESERVED__44__); // Container for chord diagrams desiredClasses.forEach(desiredClass => { diagramsContainer.classList.add(desiredClass) }); progression.forEach(chordVoicing => { // Extract first playable chord from each ChordFactory instance if (chordVoicing) { // Assuming TabGenerator takes chord details and returns an SVG element try { const chordDiagram = new TabGenerator(chordVoicing.voicing, chordVoicing.fingerPositions, chordVoicing.minAboveZero, chordVoicing.barres, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings); const svg = chordDiagram.generateChordSVG(); diagramsContainer.appendChild(svg); } catch (error) { console.error(__PRESERVED__45__, error); } } }); return diagramsContainer; // Return the container with all SVGs } getProgressionBasic() { // Iterate over each entry in the progression and get the first playable chord return this.progression.map(chordFactory => { if (chordFactory.playableChords && chordFactory.playableChords.length > 0) { return chordFactory.playableChords[0]; } else { return null; // Return null if there are no playable chords available } }).filter(chord => chord !== null); // Filter out any null entries } async getProgressionDynamicHTML(soundQuality = 0.5, ammount = 1) { // Check if there are any chords in the progression if (this.progression.length < 1) { return this.getPlaceholderHTML(); } // Create the container for the chord diagrams let diagramsContainer = document.createElement(__PRESERVED__46__); // Container for chord diagrams diagramsContainer.classList.add(__PRESERVED__47__); // Iterate over each ChordFactory instance in the progression this.progression.forEach(chordFactory => { // Create an instance of TabHTML for the current chordFactory const tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings); // Generate the HTML for the current chordFactory const chordDiagrams = tabHTML.generateHTML(soundQuality, ammount); // Append the generated HTML to the main container chordDiagrams.forEach(element => { diagramsContainer.appendChild(element); }) }); // Return the container with all chord diagrams return diagramsContainer; } invertColor(hex) { // Remove the hash at the start if it's there hex = hex.startsWith('#') ? hex.slice(1) : hex; // Convert hex to RGB let r = parseInt(hex.substr(0, 2), 16); let g = parseInt(hex.substr(2, 2), 16); let b = parseInt(hex.substr(4, 2), 16); // Invert each component by subtracting from 255 r = 255 - r; g = 255 - g; b = 255 - b; // Convert the inverted RGB values back to hex return '#' + [r, g, b].map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join(''); } }

File: tabhtml.js
Path: progression-generator\tabhtml.js

import TabGenerator from "../tab-generator/script.js"; export class TabHTML { constructor(chordFactory, color, fingerNumbers = "belowString", showOpenStrings = true) { this.chordFactory = chordFactory; // Pointer to the ChordFactory instance this.color = color; this.fingerNumbers = fingerNumbers; this.showOpenStrings = showOpenStrings; this.currentIndex = 0; // Track the current index of playable chords this.maxChords = chordFactory.playableChords.length } invertColor(hex) { // Remove the hash at the start if it__PRESERVED__2__#__PRESERVED__3__#__PRESERVED__4__0__PRESERVED__5____PRESERVED__6__vibrate__PRESERVED__7__vibrate__PRESERVED__8__next__PRESERVED__9__slide-out-left__PRESERVED__10__slide-in-right__PRESERVED__11__previous__PRESERVED__12__slide-out-right__PRESERVED__13__slide-in-left__PRESERVED__14__slide-in-left__PRESERVED__15__slide-in-right__PRESERVED__16__slide-out-right__PRESERVED__17__slide-out-left__PRESERVED__18____PRESERVED__19__slide-in-left__PRESERVED__20__slide-in-right__PRESERVED__21__slide-out-right__PRESERVED__22__slide-out-left__PRESERVED__23__ammount__PRESERVED__24__div__PRESERVED__25__div__PRESERVED__26__div__PRESERVED__27__div__PRESERVED__28__div__PRESERVED__29__div__PRESERVED__30__<svg xmlns=__PRESERVED__31__ height=__PRESERVED__32__ viewBox=__PRESERVED__33__ ><path fill=__PRESERVED__34__ d=__PRESERVED__35__/></svg>__PRESERVED__36__next__PRESERVED__37__div__PRESERVED__38__<svg xmlns=__PRESERVED__39__ height=__PRESERVED__40__ viewBox=__PRESERVED__41__ ><path fill=__PRESERVED__42__ d=__PRESERVED__43__/></svg>__PRESERVED__44__previous__PRESERVED__45__div__PRESERVED__46__Error generating chord diagram:', error); } } } return diagrams; // Return the container with all SVGs } }

File: settings.js
Path: settings.js

import { settings } from "./chord-factory/constants.js"; import { noteToNumber, numberToNote } from "./chord-factory/utils.js"; document.addEventListener('DOMContentLoaded', () => { })

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Guitar Chord Diagram Generator</title> <link rel="stylesheet" href="styles.css"> </head> <body> <div class="container"> <h1>Guitar Chord Diagram Generator</h1> <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input"> <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)"> <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button> <div id="diagram" class="diagram-container"></div> </div> <script type="module"> import TabGenerator from "./script.js" const fingerPositions = ['-1', '5', '6', '5', '0', '0']; const fingerNumbers = ['1', '1', '2', '1', '', '']; const barre = 10; const minAboveZero = 15 const barres = [[5,1,3], [3,0,5]] const color = "#fff"; const textColor = "#000"; const showOpenStrings = true; try { const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, minAboveZero, barres, color, textColor, 'belowString', showOpenStrings); const svg = chordDiagram.generateChordSVG(); document.getElementById('diagram').appendChild(svg); } catch (error) { console.error('Error generating chord diagram:', error); } </script> </body> </html>

File: script.js
Path: tab-generator\script.js

/** * Represents a TabGenerator for creating guitar chord diagrams as SVG elements. * This class allows the configuration of various aspects of the diagram, including finger positions, * barre chords, string and note visualization, and color customization. */ class TabGenerator { /** * Creates an instance of TabGenerator. * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings. * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string. * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used. * @param {string} [barre=null] - Specific fret where the barre is placed. * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes. * @param {string} [textColor="#fff"] - Color for the text used in the diagram. * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately. * @param {boolean} showOpenStrings - Whether to display open strings in the diagram. */ constructor(fingerPositions, fingerNumbers, minAboveZero = 0, barres = [], elementColor = __PRESERVED__6__, textColor = __PRESERVED__7__, numberPosition = __PRESERVED__8__, showOpenStrings) { if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) { console.error(__PRESERVED__9__); } if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) { console.error(__PRESERVED__10__); } if (typeof elementColor !== __PRESERVED__11__) { console.error(__PRESERVED__12__); } if (typeof textColor !== __PRESERVED__13__) { console.error(__PRESERVED__14__); } if (numberPosition !== __PRESERVED__15__ && numberPosition !== __PRESERVED__16__) { console.error(__PRESERVED__17__); } if (typeof showOpenStrings !== __PRESERVED__18__) { console.error(__PRESERVED__19__); } // Assign instance variables this.fingerPositions = fingerPositions; this.fingerNumbers = fingerNumbers; this.barres = barres; // Specific fret where the barre is placed this.color = elementColor; // Color for diagram elements this.textColor = textColor; // Color for the text this.numberPosition = numberPosition; // Position of the numbers this.showOpenStrings = showOpenStrings; // Whether to display open strings this.maxFret = Math.max(...fingerPositions) // Diagram layout constants this.topSpacing = 25; this.topBarHeight = 7; this.fretSpacing = 25; this.stringSpacing = 25; this.paddingLeft = 10; this.barreSidesOverflow = 10; this.stringOverflowBotom = 10; this.fretCount = 4; this.circleRadius = 10; this.infoPadding = 10; this.openStringRadius = 7; //Offset this.offset = 1 if (this.maxFret > this.fretCount){ this.offset = minAboveZero } //Global Framw Width this.width = 185; this.height = 145 } generateChordSVG() { const svgAttributes = { width: this.width, height: this.height, viewBox: __PRESERVED__20__ + this.width + __PRESERVED__21__ +this.height // This sets the viewBox attribute }; const svg = this.createSVGElement(__PRESERVED__22__, svgAttributes); this.drawDiagramComponents(svg); return svg; } drawDiagramComponents(svg) { this.drawTopBar(svg); if (this.barres) { this.barres.forEach(element => { this.drawBarre(svg, element[0], element[1], element[2]); }); } this.drawStrings(svg); this.drawFrets(svg); if (this.showOpenStrings) { this.drawOpenStrings(svg); } this.drawNotes(svg); this.drawMuteIndicators(svg); this.drawFretHeight(svg) } createSVGElement(tag, attributes) { const element = document.createElementNS(__PRESERVED__23__, tag); for (const attr in attributes) { element.setAttribute(attr, attributes[attr]); } return element; } drawTopBar(svg) { const topBar = this.createSVGElement(__PRESERVED__24__, { x: this.paddingLeft, y: this.topSpacing, width: this.stringSpacing * 5, height: this.topBarHeight, fill: this.color, stroke: this.color, __PRESERVED__25__: __PRESERVED__26__ }); svg.appendChild(topBar); } drawStrings(svg) { for (let i = 0; i < 6; i++) { const line = this.createSVGElement(__PRESERVED__27__, { x1: this.paddingLeft + i * this.stringSpacing, y1: this.topSpacing, x2: this.paddingLeft + i * this.stringSpacing, y2: this.fretSpacing * this.fretCount + this.topSpacing + this.stringOverflowBotom + this.topBarHeight, stroke: this.color, __PRESERVED__28__: ((6 - i) / 3) + 1 }); svg.appendChild(line); } } drawFrets(svg) { for (let j = 0; j < this.fretCount + 1; j++) { const line = this.createSVGElement('line', { x1: this.paddingLeft, y1: this.topSpacing + j * this.fretSpacing + this.topBarHeight, x2: this.paddingLeft + this.stringSpacing * 5, y2: this.topSpacing + j * this.fretSpacing + this.topBarHeight, stroke: this.color, 'stroke-width': '2' }); svg.appendChild(line); } } drawNotes(svg) { for (let string = 0; string < 6; string++) { if (this.fingerPositions[string] > 0) { let fret = parseInt(this.fingerPositions[string]); if (fret > 0) { let position = this.topSpacing + this.topBarHeight + ((fret) - this.offset) * this.fretSpacing - this.circleRadius / 2; let circle = this.createSVGElement(__PRESERVED__32__, { cx: this.paddingLeft + string * this.stringSpacing, cy: position + this.topSpacing - 8, r: this.circleRadius, fill: this.color }); svg.appendChild(circle); if (this.fingerNumbers && this.fingerNumbers[string]) { const textPositionY = this.numberPosition === __PRESERVED__33__ ? position + this.topSpacing : this.topSpacing + this.topBarHeight + (this.fretCount + 1) * this.fretSpacing + this.stringOverflowBotom; const text = this.createSVGElement(__PRESERVED__34__, { x: this.paddingLeft + string * this.stringSpacing, y: textPositionY, __PRESERVED__35__: __PRESERVED__36__, __PRESERVED__37__: __PRESERVED__38__, __PRESERVED__39__: __PRESERVED__40__, fill: this.numberPosition === __PRESERVED__41__ ? this.textColor : this.color, __PRESERVED__42__: __PRESERVED__43__ }); text.textContent = this.fingerNumbers[string]; svg.appendChild(text); } } } } } drawMuteIndicators(svg) { const radius = 10 const height = radius * Math.sqrt(2) for (let i = 0; i < 6; i++) { if (this.fingerPositions[i] == -1) { const line1 = this.createSVGElement(__PRESERVED__44__, { x1: this.paddingLeft + i * this.stringSpacing - height / 2, y1: this.topSpacing - height - this.infoPadding, x2: this.paddingLeft + i * this.stringSpacing + height / 2, y2: this.topSpacing - this.infoPadding, stroke: this.color, __PRESERVED__45__: __PRESERVED__46__ }); const line2 = this.createSVGElement(__PRESERVED__47__, { x1: this.paddingLeft + i * this.stringSpacing - height / 2, y1: this.topSpacing - this.infoPadding, x2: this.paddingLeft + i * this.stringSpacing + height / 2, y2: this.topSpacing - height - this.infoPadding, stroke: this.color, __PRESERVED__48__: __PRESERVED__49__ }); svg.appendChild(line1); svg.appendChild(line2); } } } drawOpenStrings(svg) { for (let i = 0; i < 6; i++) { if (this.fingerPositions[i] === __PRESERVED__50__) { const circle = this.createSVGElement(__PRESERVED__51__, { cx: this.paddingLeft + i * this.stringSpacing, cy: this.topSpacing - this.infoPadding - this.openStringRadius, r: this.openStringRadius, fill: __PRESERVED__52__, stroke: this.color, __PRESERVED__53__: __PRESERVED__54__ }); svg.appendChild(circle); } } } drawBarre(svg, barreFret, barreStartString, barreEndString) { if (barreFret != 0) { barreFret = barreFret - this.offset const barreWidth = barreEndString - barreStartString const barreHeight = 10; const barreX = this.paddingLeft - this.barreSidesOverflow + barreStartString * this.stringSpacing; const barreY = barreFret * this.fretSpacing + this.topSpacing + this.topBarHeight + (this.fretSpacing / 2) - barreHeight / 2; const rect = this.createSVGElement('rect', { x: barreX, y: barreY, width: barreWidth * this.stringSpacing + 2 * this.barreSidesOverflow, height: barreHeight, rx: '5', ry: '5', fill: this.color }); svg.appendChild(rect); } } drawFretHeight(svg) { if (this.offset > 1) { const text = this.createSVGElement('text', { x:this.paddingLeft + this.stringSpacing*5 + this.infoPadding, y: this.topSpacing + this.topBarHeight + this.fretSpacing * 0.5, 'font-family': 'Arial', 'font-size': '20', fill: this.color, 'text-anchor': 'left', "alignment-baseline": "central" }); text.textContent = this.offset + "fr"; svg.appendChild(text); } } } export default TabGenerator;

File: test.html
Path: test.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <style> body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; margin: 0; } .slider-container { position: relative; width: 80%; max-width: 600px; height: 40px; } .slider-container::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 5px; background: #ddd; border-radius: 2.5px; transform: translateY(-50%); } .slider-container::after { content: ''; position: absolute; top: 50%; height: 30px; width: 2px; background: #000; transform: translateY(-50%); } .slider-container .separator:nth-child(1) { left: 20%; } .slider-container .separator:nth-child(2) { left: 60%; } .slider-container .separator:nth-child(3) { left: 80%; } .slider-point { position: absolute; top: 50%; width: 30px; height: 20px; background: #4CAF50; border-radius: 50% 50% 50% 50% / 50% 50% 50% 50%; transform: translateY(-50%); } .slider-point.fixed { left: 0; } .slider-point.slidable { pointer-events: none; } input[type="range"] { -webkit-appearance: none; width: 100%; height: 40px; background: transparent; outline: none; position: absolute; top: 0; left: 0; z-index: 1; } input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 30px; height: 20px; background: #4CAF50; border-radius: 50% 50% 50% 50% / 50% 50% 50% 50%; cursor: pointer; } input[type="range"]::-moz-range-thumb { width: 30px; height: 20px; background: #4CAF50; border-radius: 50% 50% 50% 50% / 50% 50% 50% 50%; cursor: pointer; } </style> <title>Custom Slider</title> </head> <body> <div class="slider-container"> <div class="slider-point fixed"></div> <div class="slider-point slidable"></div> <input type="range" min="0" max="100" value="50" /> </div> </body> </html>

