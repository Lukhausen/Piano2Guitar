Directory Structure:
audio/
chord-factory/
  chordfactory.js (Path: chord-factory\chordfactory.js, Size: 17403 bytes)
  chordvoicing.js (Path: chord-factory\chordvoicing.js, Size: 14477 bytes)
  constants.js (Path: chord-factory\constants.js, Size: 1652 bytes)
  main.js (Path: chord-factory\main.js, Size: 1061 bytes)
  timingtext.js (Path: chord-factory\timingtext.js, Size: 1898 bytes)
  utils.js (Path: chord-factory\utils.js, Size: 1515 bytes)
chord-library/
  script.js (Path: chord-library\script.js, Size: 10574 bytes)
chordviewer/
  index.html (Path: chordviewer\index.html, Size: 4280 bytes)
  index.js (Path: chordviewer\index.js, Size: 2342 bytes)
createChatGPTContext.js (Path: createChatGPTContext.js, Size: 2809 bytes)
css/
drag-drop/
  script.js (Path: drag-drop\script.js, Size: 13797 bytes)
index.html (Path: index.html, Size: 10189 bytes)
index.js (Path: index.js, Size: 11394 bytes)
midi-integration/
  index.html (Path: midi-integration\index.html, Size: 263 bytes)
  script.js (Path: midi-integration\script.js, Size: 3424 bytes)
piano/
  script.js (Path: piano\script.js, Size: 9866 bytes)
progression-generator/
  main.js (Path: progression-generator\main.js, Size: 13062 bytes)
  svg/
  tabhtml.js (Path: progression-generator\tabhtml.js, Size: 8754 bytes)
settings.js (Path: settings.js, Size: 1401 bytes)
svg/
tab-generator/
  index.html (Path: tab-generator\index.html, Size: 1572 bytes)
  script.js (Path: tab-generator\script.js, Size: 11120 bytes)
test.html (Path: test.html, Size: 10532 bytes)

File Contents:
File: chordfactory.js
Path: chord-factory\chordfactory.js

import { settings, MAX_FRETS } from './constants.js';
import { ChordVoicing } from './chordvoicing.js';


export class ChordFactory {
  constructor(chord, startWithRoot = true, tuning = settings.tuning) {
    console.log("ChordFactory Recieved Notes: ", chord.notes)
    this.identifier = chord.name
    this.notes = chord.notes;
    this.startWithRoot = startWithRoot
    this.root = chord.rootNote
    this.tuning = tuning;
    this.fingerPositions = this.calculateValidFingerPositions();
    this.allChords = this.generateAllChordCombinations2()
    this.playableChords = this.filterPlayableChords2(structuredClone(this.allChords))
    //this.getFretSpanStatistics()
    this.sortPlayableChordsByCombinedRating(1)
  }

  getFretSpanStatistics() {
    let spanCounts = {};  // Object to store the count of each span

    // Iterate over all chord combinations
    this.allChords.forEach(chord => {
      // Filter out muted and open strings, keeping only fretted notes
      const frets = chord.filter(fret => fret > 0);
      if (frets.length > 1) { // Ensure there's more than one fretted note to calculate a span
        const minFret = Math.min(...frets);
        const maxFret = Math.max(...frets);
        const span = maxFret - minFret;

        // Update the count for the calculated span
        if (span in spanCounts) {
          spanCounts[span] = spanCounts[span] + 1;
        } else {
          spanCounts[span] = 1;
        }
      }
    });

    // Log the statistics for review
    console.log("Fret Span Statistics:", spanCounts);
    return spanCounts;
  }


  calculateValidFingerPositions() {
    const fingerPositions = [];

    for (let stringIndex of this.tuning) {
      const positions = [];
      for (let chordIndex of this.notes) {
        const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12);
        positions.push(...validPositions);
      }
      if (!positions.includes(0)) { // Check if positions array does not contain 0
        positions.push(-1); // Add -1 only if there is no 0
      }
      positions.sort((a, b) => a - b); // Sort the positions from lowest to highest
      fingerPositions.push(positions);
    }

    return fingerPositions;
  }

  getValidFretPositionsForNote(noteIndex, stringIndex) {
    const baseFret = (noteIndex - stringIndex + 120) % 12;
    return [baseFret, baseFret + 12];
  }

  cartesianProduct(arrays) {
    return arrays.reduce((acc, curr) => {
      return acc.flatMap(a => curr.map(b => [...a, b]));
    }, [[]]);
  }


  //Highly efficent Variant of the Cartesian Product, That will not calulate any position twice
  generateAllChordCombinations2() {

    const startTime = performance.now();

    let chords = [];
    //console.log("Initial chords array:", chords);

    let maskScope = [];
    for (let i = 0; i < 6; i++) {
      //Check If A Zero is present in the Valid Positions. Then We dont need to Mute The String Ever.
      if (this.fingerPositions[i])
        maskScope[i] = [this.fingerPositions[i][0]]; // Each sub-array is separately instantiated
    }
    //console.log("Initial maskScope array:", maskScope);

    const fingerIndexStorage = Array(6).fill(1);
    //console.log("Initial fingerIndexStorage array:", fingerIndexStorage);

    let fingerIndexLength = []
    this.fingerPositions.forEach((element, inndex) => {
      fingerIndexLength[inndex] = element.length - 1
    })

    //console.log("Finger index lengths for all strings:", fingerIndexLength);

    // As the first entry of the chords is allways -1 we can skip this
    for (let fret = 0; fret < 13; fret++) {
      //console.log("generateAllChordCombinations2 - FRET: ", fret)

      for (let string = 0; string < 6; string++) {

        for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) {
          // FIrst remove all Non Fitting Elements From Out current maskScope on All Strings.
          // Exclude The -1 (muted) and 0 (open string) Because they can be used everywhere
          if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) {
            maskScope[string].splice(validPosition, 1);
          }
        }
      }
      //for (let i = 0; i < 6; i++) {
      //console.log("generateAllChordCombinations2 - maskScope: ", i, maskScope[i])

      //}

      //Now We deleted all old ElementInternals, we can start inserting New elements one by one
      for (let string = 0; string < 6; string++) {
        //console.log("generateAllChordCombinations2 Fret, String", fret, string)

        // Add The New Element, if there is one 
        // First Check If there is a New Element inside the Array
        if (fingerIndexStorage[string] < fingerIndexLength[string]) {
          // CHeck if its in range for Valid CHord, if so add it 
          if (this.fingerPositions[string][fingerIndexStorage[string]] <= fret + settings.fingerFretRange - 1) {
            //console.log("generateAllChordCombinations2 Pushing into maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]] ", maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]])

            maskScope[string].push(this.fingerPositions[string][fingerIndexStorage[string]])

            for (let pos1 of maskScope[(string + 1) % 6]) {
              for (let pos2 of maskScope[(string + 2) % 6]) {
                for (let pos3 of maskScope[(string + 3) % 6]) {
                  for (let pos4 of maskScope[(string + 4) % 6]) {
                    for (let pos5 of maskScope[(string + 5) % 6]) {
                      let newVoicing = []
                      newVoicing[string] = this.fingerPositions[string][fingerIndexStorage[string]]
                      newVoicing[(string + 1) % 6] = pos1
                      newVoicing[(string + 2) % 6] = pos2
                      newVoicing[(string + 3) % 6] = pos3
                      newVoicing[(string + 4) % 6] = pos4
                      newVoicing[(string + 5) % 6] = pos5


                      //console.log("NEW: ", newVoicing)
                      chords.push(newVoicing);
                    }
                  }
                }
              }
            }
            //Flag the next index to be looked at later

            fingerIndexStorage[string]++

          } else {
            //Break because the element found is too big to be inserte into the maskScope
          }
        } else {
          //break because there are no more elments left in the Array
        }

        //Calculate the Cartesian Product From the Inserted element

        // Add each element to the chords
      }
    }
    // Track end time
    const endTime = performance.now();

    // Calculate the time taken
    const timeTaken = endTime - startTime;
    console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds");
    return chords;
  }


  filterPlayableChords(allChordsCopy) {
    const startTime = performance.now();

    const playableChordsSet = new Set();

    allChordsCopy.forEach(voicing => {
      // Start By Muting All Chords
      if (this.startWithRoot) {
        for (let string = 0; string < 6; string++) {
          if (voicing[string] == -1) {
            continue;
          } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) {
            voicing[string] = -1;
          } else {
            break;
          }
        }
      }

      // Faster Way to Calculate the MinaboveZero
      let minAboveZero = Infinity;
      for (let i = 0; i < voicing.length; i++) {
        if (voicing[i] > 0 && voicing[i] < minAboveZero) {
          minAboveZero = voicing[i];
        }
      }
      if (minAboveZero === Infinity) {
        minAboveZero = 0;
      }

      let fingersUsed = 0;
      let barreStop = false;
      let barreUseFingers = 0;
      let barreAddFingers = 0;
      for (let i = 5; i >= 0; i--) {
        if (voicing[i] <= 0) {
          barreStop = true;
        }
        if (voicing[i] >= minAboveZero && barreStop == false) {
          barreUseFingers++;
          if (voicing[i] > minAboveZero) {
            barreAddFingers++;
          }
        } else if (voicing[i] > 0 && voicing[i] !== "x") {
          barreAddFingers++;
        }
      }
      if (barreUseFingers) {
        if (barreUseFingers >= 2 && barreAddFingers > 3) {
          return;
        } else if (barreUseFingers < 2) {
          fingersUsed = voicing.filter(fret => fret >= minAboveZero).length;
          barreUseFingers = 0;
        }
      }
      if (fingersUsed <= 4) {
        let newVoicing = new ChordVoicing(
          voicing,
          barreUseFingers > 0 ? minAboveZero : null,
          barreUseFingers > 0 ? barreAddFingers : fingersUsed,
          barreUseFingers,
          minAboveZero,
          this.notes,
          this.startWithRoot ? this.root : -1
        );

        playableChordsSet.add(JSON.stringify(newVoicing));
      }
    });

    // Convert the Set back to an array of unique ChordVoicing objects
    const playableChords = Array.from(playableChordsSet).map(voicingString => JSON.parse(voicingString));

    // Track end time
    const endTime = performance.now();

    // Calculate the time taken
    const timeTaken = endTime - startTime;
    console.log("filterPlayableChords - Time taken:", timeTaken, "milliseconds");

    return playableChords;
  }


  filterPlayableChords2(allChordsCopy) {
    const startTime = performance.now();
    let playableChordsVoicingSet = new Set();
    let playableChordsArray = []
    let totalChordVoicingTime = 0; // Initialize a variable to accumulate time for ChordVoicing creation

    // Pre-create and reuse these objects - Testing Showed This is faster than Creating them newly
    let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => []));
    let barreClassesUsed = new Set();
    let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0);
    let minAboveZero = 99;
    let mutingTillRoot = true;
    let touchedSet = new Set();
    let barres = []
    let touchedIndices = [];
    let fingerPositionsCounter = 0
    let fingerPositions = [-1, -1, -1, -1, -1, -1]
    let fingerPositionsAmmount = 0


    allChordsCopy.forEach(voicing => {
      minAboveZero = 99;
      mutingTillRoot = true;

      // Reset values for each iteration
      barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0));
      barreClassesUsed.clear();
      touchedSet.clear()
      barreSeparatorIndex.fill(0);
      barres = []
      touchedIndices = [];
      fingerPositionsCounter = 0
      fingerPositions = [-1, -1, -1, -1, -1, -1]
      fingerPositionsAmmount = 0


      for (let string = 0; string < 6; string++) {
        //Mute Strings That are not the Root Note
        if (this.startWithRoot && mutingTillRoot) {
          if (voicing[string] == -1) {
            // Do Nothing
          } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) {
            // Mute The String
            voicing[string] = -1;
          } else {
            mutingTillRoot = false;
          }
        }

        //Count Total Fingers Used in this voicing.
        if (voicing[string] > 0) {
          fingerPositionsAmmount++
          if (voicing[string] < minAboveZero) {
            minAboveZero = voicing[string];
          }
        }


      }
      // Check if the voicing is already in the set
      let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5];
      if (playableChordsVoicingSet.has(voicingString)) {
        //console.log("Allready Has Voicing, Skipping...")
        return; // Skip processing if voicing is already in the set
      }

      //Remove Chords Below two fingers used.
      if (fingerPositionsAmmount < 2) {
        return
      }

      //Take a Look at the Ammount of fingers Required. If is less than 5 no barre needs to be caluclated.
      if (fingerPositionsAmmount > 4) {

        for (let string = 0; string < 6; string++) {
          //Mute Strings That are not the Root Note




          //Now, Place the Strings in their Corresponding barreClass
          if (voicing[string] >= 0) {

            barreClassesUsed.forEach((index) => {
              if (voicing[string] < index) {
                barreSeparatorIndex[index] += 1;
              }
            });

            barreClassesUsed.add(voicing[string]);
            barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string);
            const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`;
            if (!touchedSet.has(newIndex)) {
              touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]);
              touchedSet.add(newIndex);
            }
          }
        }


        // Sort touchedIndices from lowest to highest fret
        touchedIndices.sort(([fretA], [fretB]) => fretA - fretB);
        //console.log(touchedIndices)
        touchedIndices.forEach(([fret, index]) => {
          if (barreClass[fret][index].length > 0) {
            if (barreClass[fret][index].length > 1 && fret != 0) {
              barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])])
              fingerPositionsCounter++
              barreClass[fret][index].forEach(element => {
                fingerPositions[element] = fingerPositionsCounter
              })

            } else if (fret != 0) {
              fingerPositionsCounter++
              fingerPositions[barreClass[fret][index]] = fingerPositionsCounter
            }

          }

        });


        //Check if 5 Finger are still used, If so, Remove the CHord.
        if (fingerPositionsCounter > 4) {
          return
        }
      } else {
        //console.log("SkippedBarre Because The Fingers are to less")
        //No Barre Requred, so we can just calulate Where each finger goes.
        for (let fret = 0; fret < settings.fingerFretRange; fret++) {
          for (let string = 0; string < 6; string++) {
            if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) {
              fingerPositionsCounter++
              fingerPositions[string] = fingerPositionsCounter

            }
          }
        }
      }

      //IF minabove Zero Was note set, Set it to zero
      if (minAboveZero == 99) {
        minAboveZero = 0
      }

      const chordVoicingStartTime = performance.now();

      let newVoicing = new ChordVoicing(
        voicing,
        fingerPositions,
        barres,
        minAboveZero,
        fingerPositionsAmmount,
        this.notes,
        this.startWithRoot ? this.root : -1
      );

      const chordVoicingEndTime = performance.now();
      const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime;
      totalChordVoicingTime += chordVoicingTimeTaken;

      playableChordsVoicingSet.add(voicingString);
      playableChordsArray.push(newVoicing);
      //console.log("filterPlayableChords2 - voicing, barres", voicing, barres);
      //Now Check For each Barre Class Starting at MinAboveZero...

    });
    const endTime = performance.now();

    // Calculate the time taken
    const totalTimeTaken = endTime - startTime;

    console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds");
    console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds");
    return playableChordsArray
  }



  /**
   * Sorts the playable chords by a combined rating based on sound quality and 
   * playability. The combined rating is calculated using a weighted sum of 
   * the sound quality rating and the playability rating.
   * 
   * @param {number} soundWeight - A value between 0 and 1 that determines the weight 
   * given to the sound quality rating. The weight given to the playability rating 
   * will be (1 - soundWeight).
   * 
   * Usage example:
   * ```javascript
   * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning);
   * chordFactory.sortPlayableChordsByCombinedRating(0.7);
   * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating
   * ```
   * 
   * @throws {Error} If `soundWeight` is not a number between 0 and 1.
   */
  sortPlayableChordsByCombinedRating(soundWeight = 0) {
    if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) {
      throw new Error("soundWeight must be a number between 0 and 1.");
    }
    console.log("Sorting...")
    this.playableChords.sort((a, b) => {
      let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight));
      let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight));
      return bCombinedRating - aCombinedRating;
    });
  }
}


File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { settings } from './constants.js';


/**
 * Class representing a Chord Voicing.
 * 
 * The `ChordVoicing` class is used to represent a specific way to play a chord on a guitar. It includes
 * properties and methods to calculate and rate the playability and sound quality of the chord voicing.
 * 
 * @class
 */
export class ChordVoicing {
  /**
   * Creates an instance of ChordVoicing.
   * 
   * @constructor
   * @param {Array<number>} voicing - Array representing the fret positions for each string (0-5). `-1` represents a muted string, `0` represents an open string.
   * @param {number|null} barre - The fret position where a barre chord is applied. `null` if no barre chord.
   * @param {number} fingersUsed - The number of fingers used to play the chord.
   * @param {number} minAboveZero - The minimum fret position above zero used in the voicing.
   * @param {Array<number>} chordFactoryNotes - Array of note indices used in the chord (0-11 representing C-B).
   * @param {number} chordFactoryRoot - The root note of the chord.
   */
  constructor(voicing, fingerPositions, barres, minAboveZero, fingersUsed, chordFactoryNotes, chordFactoryRoot) {


    this.voicing = voicing;
    this.barres = barres;

    this.minAboveZero = minAboveZero
    this.fingerPositions = fingerPositions
    this.fingersUsed = fingersUsed
    this.chordSpacing = 0
    this.chordFactoryNotes = chordFactoryNotes
    this.chordFactoryRoot = chordFactoryRoot
    this.actuallyPlayedNotes = [0, 0, 0, 0, 0, 0]

    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] >= 0) {
        this.actuallyPlayedNotes[i] = (this.voicing[i] + settings.tuning[i])
      } else {
        this.actuallyPlayedNotes[i] = this.voicing[i]
      }
    }

    this.playabilityRating = 0;
    this.soundQualityRating = 0; // New property to store sound quality rating

    this.ratingDetails = {
      playability: {
        fingersUsed: 0,
        fingerSpread: 0,
        mutedAmount: 0,
        fretHeight: 0,
        total: 0,
      },
      soundQuality: {
        harmonicCompleteness: 0,
        openStrings: 0,
        playedStrings: 0,
        fretBoardHeight: 0,
        voicingRange: 0,
        doubleNotes: 0,
        total: 0,
      }
    };

    //this.calculateChordSpacing()
    //this.calculateFingerPosition()

    this.rateSoundQuality()
    this.ratePlayability()

    //Send From ChordFactory over

  }

  calculateChordSpacing() {
    if (this.fingerPositions.length !== 6 || this.voicing.length !== 6) {
      throw new Error('Input arrays must each have 6 elements.');
    }

    let notes = this.fingerPositions.map((finger, index) => ({
      string: index + 1,
      fret: this.voicing[index],
      finger
    })).filter(note => note.finger !== 0 && note.fret !== -1);

    // Additional condition for barre chords
    if (this.barre) {
      notes = notes.filter(note => note.finger !== 1);
    }

    notes.sort((a, b) => a.fret - b.fret || a.string - b.string);

    let totalSpacing = 0;
    for (let i = 0; i < notes.length - 1; i++) {
      const stringDistance = Math.abs(notes[i].string - notes[i + 1].string);
      const fretDistance = Math.abs(notes[i].fret - notes[i + 1].fret);
      totalSpacing += stringDistance + fretDistance;
    }

    this.chordSpacing = totalSpacing;
  }

  static PLAYABILITY_WEIGHTS = {
    fingersUsed: 1,
    fingerSpread: 1,
    mutedAmount: 1,
    fretHeight: 1,
    mutedDifficulty: 1,
    mutedReachability: 1,
    barreAmount: 1
  };

  // 0 is Badly Playable and 1 Is good PLayability
  ratePlayability() {
    const details = this.ratingDetails.playability;
    details.fingersUsed = this.assessPlayabilityFingersUsed();
    details.fingerSpread = this.assessPlayabilityFingerSpread();
    details.mutedAmount = this.assessPlayabilityMutedAmount();
    details.fretHeight = this.assessPlayabilityFretHeight();
    details.mutedDifficulty = this.assessPlayabilityMutedDifficulty();
    details.mutedReachability = this.assessPlayabilityMutedReachability();
    details.barreAmount = this.assessPlayabilityBarreAmount();

    details.total = (
      details.fingersUsed * ChordVoicing.PLAYABILITY_WEIGHTS.fingersUsed +
      details.fingerSpread * ChordVoicing.PLAYABILITY_WEIGHTS.fingerSpread +
      details.mutedAmount * ChordVoicing.PLAYABILITY_WEIGHTS.mutedAmount +
      details.fretHeight * ChordVoicing.PLAYABILITY_WEIGHTS.fretHeight +
      details.mutedDifficulty * ChordVoicing.PLAYABILITY_WEIGHTS.mutedDifficulty +
      details.mutedReachability * ChordVoicing.PLAYABILITY_WEIGHTS.mutedReachability +
      details.barreAmount * ChordVoicing.PLAYABILITY_WEIGHTS.barreAmount
    ) / Object.keys(ChordVoicing.PLAYABILITY_WEIGHTS).length;

    this.playabilityRating = details.total;
  }

  assessPlayabilityFingersUsed() {
    // USe FInger Positions because They are MOst realibale and ALgorithmically Safe Way (Becaus of possible future Changes) to asses Finger COunt
    let maxUsableFingers = 4
    // INvert Rating so Many fingers used gets a low score
    let rating = 1 - (this.fingersUsed / maxUsableFingers)
    return rating
  }

  assessPlayabilityFingerSpread() {
    let maxFret = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] > maxFret) {
        maxFret = this.voicing[i]
      }
    }
    return 1 - ((maxFret - this.minAboveZero) / settings.fingerFretRange)
  }

  assessPlayabilityMutedAmount() {
    let mutedCount = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] == -1) {
        mutedCount++
      }
    }
    return 1 - (mutedCount / 6)
  }

  assessPlayabilityFretHeight() {
    return 1 - Math.max((this.minAboveZero / 12), 0)
  }

  assessPlayabilityMutedDifficulty() {
    let mutedDifficulty = 0
    //Check Muting from the top
    for (let i = 0; i < 4; i++) {
      if (this.voicing[i] == -1) {
        mutedDifficulty += (i + 1)
      }
    }
    //Check Muting from the bottom
    for (let i = 0; i < 4; i++) {
      if (this.voicing[5 - i] == -1) {
        mutedDifficulty += (i + 1)
      }
    }

    return 1 - (mutedDifficulty / 12)

  }

  assessPlayabilityBarreAmount() {
    return 1 - ((this.barres.length * this.barres.length) / (3 * 3))
  }

  assessPlayabilityMutedReachability() {
    let mutedDifficulty = 0;
    let totalUnreachableMutes = 0;

    // Loop through the strings to check for muted strings surrounded by open strings
    for (let i = 1; i < this.voicing.length - 1; i++) { // Start from the second string and go to the second-last
      if (this.voicing[i] === -1) { // Check if the current string is muted
        // Check if both neighboring strings are open
        if (this.voicing[i - 1] === 0 && this.voicing[i + 1] === 0) {
          totalUnreachableMutes++;
        }
      }
    }

    // Edge cases: Check the first and last string separately if needed
    if (this.voicing[0] === -1 && this.voicing[1] === 0) { // First string muted and second string open
      totalUnreachableMutes++;
    }
    if (this.voicing[this.voicing.length - 1] === -1 && this.voicing[this.voicing.length - 2] === 0) { // Last string muted and the one before it open
      totalUnreachableMutes++;
    }

    // Normalize the difficulty score: the more muted strings surrounded by open strings, the higher the difficulty
    mutedDifficulty = totalUnreachableMutes / (this.voicing.filter(v => v === -1).length || 1); // Avoid division by zero

    return 1 - mutedDifficulty; // Invert to match scale where 1 is easy and 0 is difficult
  }









  static SOUND_QUALITY_WEIGHTS = {
    harmonicCompleteness: 1,
    openStrings: 1,
    playedStrings: 1,
    fretBoardHeight: 1,
    voicingRange: 1,
    doubleNotes: 1
  };

  // 1 Best Sound, 0 worst sound
  rateSoundQuality() {
    const details = this.ratingDetails.soundQuality;
    details.harmonicCompleteness = this.assessSoundHarmonicCompleteness();
    details.openStrings = this.assessSoundOpenStrings();
    details.playedStrings = this.assessSoundPlayedStrings();
    details.fretBoardHeight = this.assessSoundFretBoardHeight();
    details.voicingRange = this.assessSoundVoicingRange();
    details.doubleNotes = this.assessSoundDoubleNotes();

    details.total = (
      details.harmonicCompleteness * ChordVoicing.SOUND_QUALITY_WEIGHTS.harmonicCompleteness +
      details.openStrings * ChordVoicing.SOUND_QUALITY_WEIGHTS.openStrings +
      details.playedStrings * ChordVoicing.SOUND_QUALITY_WEIGHTS.playedStrings +
      details.fretBoardHeight * ChordVoicing.SOUND_QUALITY_WEIGHTS.fretBoardHeight +
      details.voicingRange * ChordVoicing.SOUND_QUALITY_WEIGHTS.voicingRange +
      details.doubleNotes * ChordVoicing.SOUND_QUALITY_WEIGHTS.doubleNotes
    ) / Object.keys(ChordVoicing.SOUND_QUALITY_WEIGHTS).length;

    this.soundQualityRating = details.total;
  }

  assessSoundHarmonicCompleteness() {
    // Transform chordFactoryNotes to modulo 12 and store as a Set
    const uniqueDesiredNotes = new Set(this.chordFactoryNotes.map(note => note % 12));

    // Transform actuallyPlayedNotes to modulo 12 and store as a Set
    const playedNotesModuloSet = new Set(this.actuallyPlayedNotes.map(note => note % 12));

    // Calculate the number of overlapping notes using set intersection
    let overlapCount = 0;
    uniqueDesiredNotes.forEach(note => {
      if (playedNotesModuloSet.has(note)) {
        overlapCount++;
      }
    });

    // Calculate harmonic completeness score
    const completenessScore = overlapCount / uniqueDesiredNotes.size;
    return completenessScore;
  }

  assessSoundOpenStrings() {
    let openStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] === 0) {
        openStrings++;
      }
    }

    return openStrings / this.voicing.length;
  }

  assessSoundPlayedStrings() {
    let playedStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] >= 0) {
        playedStrings++;
      }
    }

    return playedStrings / this.voicing.length;
  }

  assessSoundFretBoardHeight() {
    return Math.max(0, (1 - (this.minAboveZero / 12)))
  }



  assessSoundVoicingRange() {
    let minIndex = -1
    let maxIndex = -1
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] != -1) {
        minIndex = i
        break;
      }
    }
    //Check if one thing is presen
    if (minIndex < 0) {
      return 0;
    }

    for (let i = 5; i >= 0; i--) {
      if (this.voicing[i] != -1) {
        maxIndex = i
        break;
      }
    }
    let spacing = this.actuallyPlayedNotes[maxIndex] - this.actuallyPlayedNotes[minIndex]
    let maxSpacing = settings.tuning[5] + this.minAboveZero + settings.fingerFretRange - settings.tuning[0] + this.minAboveZero

    // The Higher the number, the better So The higher the Spacing archived, the better
    let spacingRatio = spacing / maxSpacing
    return spacingRatio
  }

  assessSoundDoubleNotes() {
    let doubleNotes = 0
    for (let i = 0; i < 5; i++) {
      if (this.actuallyPlayedNotes[i] == this.actuallyPlayedNotes[i + 1]) {
        doubleNotes++;
      }
    }
    return 1 - (doubleNotes / 5)
  }
}
/*
assessVoicingRange(){
  //TODO: Asses, The Difference Between the Lowest and the highest Played note. Find a Way to normalize the output between 0 (small difference) and 1
}


assessTonalBalance() {
  const noteFrequencies = this.voicing.map((fret, string) =>
    fret !== -1 ? (STANDARD_settings.tuning[string] + fret) % 12 : null
  ).filter(note => note !== null);

  const lowNotes = noteFrequencies.filter(note => note < 5).length;
  const midNotes = noteFrequencies.filter(note => note >= 5 && note < 9).length;
  const highNotes = noteFrequencies.filter(note => note >= 9).length;

  const balance = Math.min(lowNotes, midNotes, highNotes);
  return balance / 3 * 10;
}



assessVoicingRange() {
  const frets = this.voicing.filter(fret => fret !== -1);
  const range = Math.max(...frets) - Math.min(...frets);
  return range > 5 ? 0 : (5 - range) / 5 * 10;
}

assessDissonance() {
  const intervals = [];
  const frets = this.voicing.filter(fret => fret !== -1);

  for (let i = 0; i < frets.length; i++) {
    for (let j = i + 1; j < frets.length; j++) {
      const interval = Math.abs(frets[i] - frets[j]);
      intervals.push(interval);
    }
  }

  const dissonantIntervals = intervals.filter(interval => [1, 2, 6, 10].includes(interval));
  return 10 - dissonantIntervals.length * 2;
}

assessResonanceAndSustain() {
  const openStrings = this.voicing.filter(fret => fret === 0).length;
  return openStrings * 2;
}

assessChordClarity() {
  const clearNotes = this.voicing.filter(fret => fret !== -1 && fret !== 0);
  return clearNotes.length / 6 * 10;
}

assessContextualFit(contextChords) {
  const similarityScores = contextChords.map(contextChord => {
    let score = 0;
    for (let i = 0; i < 6; i++) {
      if (contextChord.voicing[i] === this.voicing[i]) {
        score++;
      }
    }
    return score;
  });

  const maxSimilarity = Math.max(...similarityScores);
  return maxSimilarity / 6 * 10;
}
}*/

/*
Start at Index Finger, represented by fingerPositions 1.
Count the String changes on the Same Fret with the middle finger so if the middle finger is 2 stings below, add 2 to the evalutaion 
if the middle finger is on the next fret over the minAboveZero, add 0, and only add 1 for each string it moved down or upward relative to the index finger
if the index finger is on the same fret as the middle finger, but the index finger is not also on the fret where the ring finger is, add the string count distance between the middle and ring finger 
if the index finger is on one fret more thatn the middle finger, but the middle and the index finger are on the fret below, add only the distance between the ring and the middle finger
if the index finger is on one fret, the middle finger is on +1 fret and the ring finger is on #1 fret, add 3 to the difficulty
if the small finger is on the same fret as the ring finger, but no other finger is on that fret, only add the string distance between the ring and the small finger.


*/

File: constants.js
Path: chord-factory\constants.js

// constants.js

export const BARRE_RATING = 1
export const MAX_FRETS = 24

/**
 * Class representing application settings.
 */
class Settings {
  /**
   * Create a settings object with default values.
   */
  constructor() {
    this._tuning = [40, 45, 50, 55, 59, 64];
    this._fingerFretRange = 4;
  }

  /**
   * Get the current tuning values.
   * @returns {number[]} The current tuning values as an array of integers.
   */
  get tuning() {
    return this._tuning;
  }

  /**
   * Set new tuning values.
   * @param {number[]} value - An array of integers representing the new tuning values.
   * @throws {Error} Throws an error if the value is not an array of integers.
   */
  set tuning(value) {
    if (Array.isArray(value) && value.every(num => Number.isInteger(num))) {
      this._tuning = value;
    } else {
      throw new Error("Invalid tuning value. It must be an array of integers.");
    }
  }

  /**
   * Get the current finger fret range.
   * @returns {number} The current finger fret range as a positive integer.
   */
  get fingerFretRange() {
    return this._fingerFretRange;
  }

  /**
   * Set a new finger fret range.
   * @param {number} value - A positive integer representing the new finger fret range.
   * @throws {Error} Throws an error if the value is not a positive integer.
   */
  set fingerFretRange(value) {
    if (Number.isInteger(value) && value > 0) {
      this._fingerFretRange = value;
    } else {
      throw new Error("Invalid fingerFretRange value. It must be a positive integer.");
    }
  }
}

export const settings = new Settings();


File: main.js
Path: chord-factory\main.js

import { settings } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';

let totalDuration = 0;
const repetitions = 50;
let lastPlayChords;

for (let i = 0; i < repetitions; i++) {
    const startTime = performance.now();
    
    const chord = new ChordFactory("E, G, B", 4, true, settings.tuning);
    const playableChords = chord.playableChords
    
    if (i === repetitions - 1) { // Only save the last result
        lastPlayChords = playableChords;
    }

    const endTime = performance.now();
    totalDuration += endTime - startTime; // Calculate the duration for this iteration
}

// Sort lastPlayChords by difficulty
if (lastPlayChords && lastPlayChords.length > 0) {
    lastPlayChords.sort((a, b) => a.rating - b.rating);
}

lastPlayChords.forEach((chord) => console.log(chord));

// Calculate the average time
const averageTime = totalDuration / repetitions;
console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);


File: timingtext.js
Path: chord-factory\timingtext.js

const MAX_FRETS = 12;

function generateFixedVoicing() {
    return [
        [0, 2, 2, 1, 0, 0],
        [3, 2, 0, 0, 3, 3],
        [0, 3, 2, 0, 1, 0],
        [-1, -1, 0, 2, 3, 2],
        [3, 2, 0, 0, 1, 0]
    ];
}

function generateFixedChords(numChords) {
    const fixedVoicing = generateFixedVoicing();
    const chords = [];
    for (let i = 0; i < numChords; i++) {
        chords.push(fixedVoicing[i % fixedVoicing.length]);
    }
    return chords;
}

function filterPlayableChordsWithSet(allChordsCopy) {
    const startTime = performance.now();

    allChordsCopy.forEach(voicing => {
        let touchedIndices = new Set();

        for (let string = 0; string < 6; string++) {
            if (voicing[string] > 0) {
                touchedIndices.add(`${voicing[string]}-${string}`);
            }
        }
    });

    const endTime = performance.now();
    return endTime - startTime;
}

function filterPlayableChordsWithArrayCheck(allChordsCopy) {
    const startTime = performance.now();

    allChordsCopy.forEach(voicing => {
        let touchedIndices = [];

        for (let string = 0; string < 6; string++) {
            if (voicing[string] > 0) {
                let index = `${voicing[string]}-${string}`;
                if (!touchedIndices.includes(index)) {
                    touchedIndices.push(index);
                }
            }
        }
    });

    const endTime = performance.now();
    return endTime - startTime;
}

const numChords = 10000;
const allChordsCopy = generateFixedChords(numChords);

const timeWithSet = filterPlayableChordsWithSet(allChordsCopy);
const timeWithArrayCheck = filterPlayableChordsWithArrayCheck(allChordsCopy);

console.log(`Time taken with Set: ${timeWithSet} milliseconds`);
console.log(`Time taken with Array Check: ${timeWithArrayCheck} milliseconds`);


File: utils.js
Path: chord-factory\utils.js

// Mapping of musical notes to their respective index numbers
export const NOTE_INDEX_MAP = {
  'C': 0, 'C#': 1, 'DB': 1, 'D': 2, 'D#': 3, 'EB': 3, 'E': 4, 'FB': 4,
  'F': 5, 'F#': 6, 'GB': 6, 'G': 7, 'G#': 8, 'AB': 8, 'A': 9, 'A#': 10,
  'BB': 10, 'B': 11, 'CB': 11
};

// Reverse mapping for number to note conversion
const NOTE_ARRAY = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

// Convert a note to its respective index number
export function noteToNumber(note) {
  if (typeof note !== 'string') {
    return "Invalid input";
  }
  
  const normalizedNote = note.toUpperCase().replace(/[\s#]+/g, '#').replace(/[\sB]+/g, 'B');
  
  return NOTE_INDEX_MAP.hasOwnProperty(normalizedNote) 
    ? NOTE_INDEX_MAP[normalizedNote] 
    : "Invalid note";
}

// Convert a number to its respective musical note
export function numberToNote(number) {
  if (typeof number !== 'number' || number < 0) {
    return "Invalid number";
  }
  
  return NOTE_ARRAY[number % 12];
}

export function parseNotes(input) {
  return input.toUpperCase()
    .replace(/B#/g, 'C').replace(/E#/g, 'F')
    .split(/[\s,]+/)
    .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note));
}

export function removeDuplicateArrays(arrays) {
  const uniqueArrays = new Set();
  return arrays.filter(array => {
    const serialized = JSON.stringify(array);
    if (!uniqueArrays.has(serialized)) {
      uniqueArrays.add(serialized);
      return true;
    }
    return
  });
}


File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js";

export class Chord {
    constructor(rootNote, notes, name, customRoot) {
        this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = notes; // Array of integers representing notes of the chord
        this.name = name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = customRoot 
        console.log("Constructed Chord: " + this.name + " Root: " + this.rootNote + " Notes: " + this.notes)
    }
}

export class ChordLibrary {
    constructor() {
        this.chords = [];
        this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        this.chordStructures = {
            '': { notes: [0, 4, 7], priority: 1 }, // Major
            'm': { notes: [0, 3, 7], priority: 2 }, // Minor
            '7': { notes: [0, 4, 7, 10], priority: 3 }, // Dominant 7th
            'M7': { notes: [0, 4, 7, 11], priority: 4 }, // Major 7th
            'm7': { notes: [0, 3, 7, 10], priority: 5 }, // Minor 7th
            'mM7': { notes: [0, 3, 7, 11], priority: 18 }, // Minor Major 7th
            'sus2': { notes: [0, 2, 7], priority: 7 }, // Suspended 2nd
            'sus4': { notes: [0, 5, 7], priority: 6 }, // Suspended 4th
            'dim': { notes: [0, 3, 6], priority: 9 }, // Diminished
            'aug': { notes: [0, 4, 8], priority: 8 }, // Augmented
            '9': { notes: [0, 4, 7, 10, 14], priority: 11 }, // Dominant 9th
            'M9': { notes: [0, 4, 7, 11, 14], priority: 12 }, // Major 9th
            'm9': { notes: [0, 3, 7, 10, 14], priority: 13 }, // Minor 9th
            '11': { notes: [0, 4, 7, 10, 14, 17], priority: 16 }, // Dominant 11th
            '13': { notes: [0, 4, 7, 10, 14, 17, 21], priority: 24 }, // Dominant 13th
            'add9': { notes: [0, 2, 4, 7], priority: 17 }, // Added 9th
            'm6': { notes: [0, 3, 7, 9], priority: 14 }, // Minor 6th
            '6': { notes: [0, 4, 7, 9], priority: 15 }, // Major 6th
            '5': { notes: [0, 7], priority: 10 }, // Power chord
            '6/9': { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6/9
            'm11': { notes: [0, 3, 7, 10, 14, 17], priority: 39 }, // Minor 11
            'M7#11': { notes: [0, 4, 7, 11, 18], priority: 29 }, // Major 7#11
            'm7b5': { notes: [0, 3, 6, 10], priority: 19 }, // Half-Diminished
            '+7': { notes: [0, 4, 8, 10], priority: 21 }, // Augmented 7th
            'dim7': { notes: [0, 3, 6, 9], priority: 20 }, // Diminished 7th
            'M7+5': { notes: [0, 4, 8, 11], priority: 28 }, // Augmented Major 7th
            'mM9': { notes: [0, 3, 7, 11, 14], priority: 18 }, // Minor Major 9th
            'dimM7': { notes: [0, 3, 6, 11], priority: 22 }, // Diminished Major 7th
            '7alt': { notes: [0, 4, 6, 10, 13], priority: 23 }, // Altered Dominant
            'M13': { notes: [0, 4, 7, 11, 14, 17, 21], priority: 24 }, // Major 13th
            'M11': { notes: [0, 4, 7, 11, 14, 17], priority: 25 }, // Major 11th
            'M7sus4': { notes: [0, 5, 7, 11], priority: 26 }, // Major 7th Suspended 4th
            'm7#5': { notes: [0, 3, 8, 10], priority: 27 }, // Minor 7th #5
            'M#5': { notes: [0, 4, 8], priority: 28 }, // Major #5
            '9#11': { notes: [0, 4, 7, 10, 14, 18], priority: 29 }, // Dominant 9th #11
            '13#11': { notes: [0, 4, 7, 10, 14, 18, 21], priority: 30 }, // Dominant 13th #11
            '7b5': { notes: [0, 4, 6, 10], priority: 31 }, // Dominant 7th Flat Five
            'M7b5': { notes: [0, 4, 6, 11], priority: 32 }, // Major 7th Flat Five
            'M7#5': { notes: [0, 4, 8, 11], priority: 33 }, // Major 7th Sharp Five
            'm7b9': { notes: [0, 3, 7, 10, 13], priority: 34 }, // Minor 7th Flat Nine
            '9b5': { notes: [0, 4, 6, 10, 14], priority: 34 }, // 9th Flat Five
            '9#5': { notes: [0, 4, 8, 10, 14], priority: 35 }, // 9th Sharp Five
            '7b9': { notes: [0, 4, 7, 10, 13], priority: 36 }, // Dominant 7th Flat Nine
            '7#9': { notes: [0, 4, 7, 10, 15], priority: 37 }, // Dominant 7th Sharp Nine
            '7#11': { notes: [0, 4, 7, 10, 18], priority: 38 }, // Dominant 7th Sharp Eleven
            'm7add11': { notes: [0, 3, 7, 10, 17], priority: 39 }, // Minor 7th Add 11
            'add2': { notes: [0, 2, 4, 7], priority: 40 }, // Major Add 2
            'add4': { notes: [0, 4, 5, 7], priority: 41 }, // Major Add 4
            '6add9': { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6 Add 9

            '/C': { notes: [0, 4, 7], root: 0, priority: 43 }, // C Major
            'm/C': { notes: [0, 3, 7], root: 0, priority: 44 }, // C Minor
            '/C#': { notes: [0, 4, 7], root: 1, priority: 43 }, // C# Major
            'm/C#': { notes: [0, 3, 7], root: 1, priority: 44 }, // C# Minor
            '/D': { notes: [0, 4, 7], root: 2, priority: 43 }, // D Major
            'm/D': { notes: [0, 3, 7], root: 2, priority: 44 }, // D Minor
            '/D#': { notes: [0, 4, 7], root: 3, priority: 43 }, // D# Major
            'm/D#': { notes: [0, 3, 7], root: 3, priority: 44 }, // D# Minor
            '/E': { notes: [0, 4, 7], root: 4, priority: 43 }, // E Major
            'm/E': { notes: [0, 3, 7], root: 4, priority: 44 }, // E Minor
            '/F': { notes: [0, 4, 7], root: 5, priority: 43 }, // F Major
            'm/F': { notes: [0, 3, 7], root: 5, priority: 44 }, // F Minor
            '/F#': { notes: [0, 4, 7], root: 6, priority: 43 }, // F# Major
            'm/F#': { notes: [0, 3, 7], root: 6, priority: 44 }, // F# Minor
            '/G': { notes: [0, 4, 7], root: 7, priority: 43 }, // G Major
            'm/G': { notes: [0, 3, 7], root: 7, priority: 44 }, // G Minor
            '/G#': { notes: [0, 4, 7], root: 8, priority: 43 }, // G# Major
            'm/G#': { notes: [0, 3, 7], root: 8, priority: 44 }, // G# Minor
            '/A': { notes: [0, 4, 7], root: 9, priority: 43 }, // A Major
            'm/A': { notes: [0, 3, 7], root: 9, priority: 44 }, // A Minor
            '/A#': { notes: [0, 4, 7], root: 10, priority: 43 }, // A# Major
            'm/A#': { notes: [0, 3, 7], root: 10, priority: 44 }, // A# Minor
            '/B': { notes: [0, 4, 7], root: 11, priority: 43 }, // B Major
            'm/B': { notes: [0, 3, 7], root: 11, priority: 44 } // B Minor
        };

        this.generateChords();
    }

    generateChords() {
        Object.entries(this.chordStructures).forEach(([suffix, structure]) => {
            for (let i = 0; i < 12; i++) {
                let rootNote = i
                let customRoot = false
                let notes = structure.notes.map(interval => (i + interval) % 12);
                const chordName = `${this.noteNames[i]}${suffix}`;
                if (structure.root !== undefined) {
                    // Filter Dumb Chord Like C/C D/D
                    if (structure.root == rootNote) {
                        continue;
                    }
                    rootNote = structure.root;
                    customRoot = true;
                    notes.push(rootNote);
                }

                const chord = new Chord(rootNote, notes, chordName, customRoot);
                chord.priority = structure.priority;
                this.chords.push(chord);
            }
        });

        // Sort chords by priority
        this.chords.sort((a, b) => a.priority - b.priority);
    }

    async searchChords(noteArray, rootNote, threshold = 50) {
        console.log("Searching Chords...")
        const results = [];
        noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave
        if (rootNote) {
            rootNote = rootNote % 12

        }
        const inputNotesSet = new Set(noteArray);

        this.chords.forEach(chord => {
            let chordNotes = [...chord.notes];

            //console.log("Comparing to: " + chord.name)
            //Add the Root note to the Chords For Cases like A/D
            
            //console.log("Input Notes Set: ", inputNotesSet);

            const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note)));
            //console.log("Common Notes with Chord: ", commonNotes);

            const totalUniqueNotes = new Set([...chordNotes, ...noteArray]);
            //console.log("Total Unique Notes: ", totalUniqueNotes);


            let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100;
            //console.log("Searched Root: " + rootNote + " Presen Root: " + chord.rootNote);

            // Adjusting match percentage based on root note comparison
            if (rootNote !== null) {
                if (chord.rootNote == rootNote) {
                    //console.log("Matching Root for: " + chord.name + " Root: " + chord.rootNote + " Notes: " + chordNotes)
                    // If root notes match, this is fine as calculated
                } else {
                    // Penalize the match percentage slightly if root notes don't match
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized for not matching Root")
                }
            } else {
                //If a Custom Root in the CHord Details is specified but the user hasnt put a custom root
                if (chord.customRoot == true) {
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized For Havinng Specific when it shouldnt")

                }
            }



            if (matchPercentage >= threshold) {
                results.push(
                    new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2)))
                );
            }
        });

        // Sort results by probability in descending order
        return results.sort((a, b) => b.probability - a.probability);
    }

    getAllChords() {
        // Return all chord names in a simplified object format
        return this.chords;
    }

    getChordByName(name) {
        const chord = this.chords.find(chord => chord.name === name);
        if (chord) {
            //console.log('Chord found:', chord);
            return chord;
        } else {
            //console.log('No chord found with the name:', name);
            return null;
        }
    }
}



File: index.html
Path: chordviewer\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="../piano/style.css" />
    <link rel="stylesheet" href="../progression-generator/style.css" />
    <link rel="stylesheet" href="../css/output-styles.css" />
    <link rel="stylesheet" href="../css/input-styles.css" />
    <link rel="stylesheet" href="../css/slider-styles.css" />
    <link rel="stylesheet" href="../css/settings-styles.css" />
    <link rel="stylesheet" href="styles.css" />




    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div class="header">
            PianoToGuitar.com - ChordViewer
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="searchContainerWrapper">
                <div class="searchContainer">

                    <div class="searchWordContainer">
                        <div class="blackFadeBottom"></div>
                        <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                        <div class="searchChordList" id="itemsContainer">
                            <!-- Items will be populated here by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="selectedItemWrapper">

                <div class="selectedItemsHeading">
                    <div>Your Selected Chord</div>
                </div>
                <div class="selectedItemsWrapper">
                    <div class="selectedItems" id="selectedItems">
                        <!-- Dragged items will appear here -->
                    </div>

                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()"
                        height="24" viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the
                        most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>

            </div>
        </div>
</body>

</html>

File: index.js
Path: chordviewer\index.js

import DragAndDropList from '../drag-drop/script.js';
import { ChordLibrary } from "../chord-library/script.js"
import { ProgressionGenerator } from '../progression-generator/main.js';
import { settings } from '../chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };



    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems[0]);
        
        await progressionGenerator.setProgression([event.detail.selectedItems[0]])
        await updateProgressionDynamic(soundQualityValue)
        dragAndDropList.clearSelectedList();
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);
        await updateProgressionDynamic(soundQualityValue)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue, 20);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };


    //Update the Progressions to get the PLaceholders:
    updateProgressionDynamic(soundQualityValue)
})


File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs');
const path = require('path');

function isHtmlOrJsFile(file) {
  return file.endsWith('.html') || file.endsWith('.js') ;
}

function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') {
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      fileStructure[item] = {};
      getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      fileStructure[item] = {
        path: fullPath,
        relativePath: path.join(parentPath, item),
        size: stats.size,
        lastModified: stats.mtime
      };
    }
  });
  return fileStructure;
}

function readAllFiles(dir, parentPath = '') {
  let allText = '';
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      allText += readAllFiles(fullPath, path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      allText += `File: ${item}\n`;
      allText += `Path: ${path.join(parentPath, item)}\n\n`;
      allText += fs.readFileSync(fullPath, 'utf8') + '\n\n';
    }
  });
  return allText;
}

function formatStructure(fileStructure, indent = 0) {
  let structureText = '';
  const indentString = ' '.repeat(indent);
  for (const key in fileStructure) {
    if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) {
      const { relativePath, size, lastModified } = fileStructure[key];
      structureText += `${indentString}${key} (Path: ${relativePath}, Size: ${size} bytes)\n`;
    } else {
      structureText += `${indentString}${key}/\n`;
      structureText += formatStructure(fileStructure[key], indent + 2);
    }
  }
  return structureText;
}

try {
  const targetDir = path.join(__dirname, ''); // Change '' to your target folder
  const outputFilePath = path.join(__dirname, 'output.txt');

  // Get the folder and file structure
  const fileStructure = getDirectoryStructure(targetDir);

  // Format the structure to a string
  const structureText = formatStructure(fileStructure);

  // Read all the text from HTML and JS files
  const filesText = readAllFiles(targetDir);

  // Combine structure and file texts
  const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`;

  // Write the final output to a file
  fs.writeFileSync(outputFilePath, finalOutput);

  console.log('Folder structure and file contents have been saved to output.txt');
} catch (error) {
  console.error('Error reading directory:', error.message);
}


File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js";

export class DragAndDropItem extends Chord {
    constructor(chord, probability = -1) {
        super(chord)
        this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = chord.notes; // Array of integers representing notes of the chord
        this.name = chord.name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = chord.customRoot
        this.probability = probability
    }
}

export default class DragAndDropList {
    constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) {
        this.items = []
        this.idCounter = 0;
        items.forEach(item => {
            this.items.push(new DragAndDropItem(item))
        })

        this.dropzoneId = dropzoneId;

        this.selectedItemsEvent = new CustomEvent('selectedItemsUpdated', { bubbles: true, detail: { selectedItems: [] } });

        this.emptyMessageContainer = document.getElementById(emptyMessage);
        this.itemsContainer = document.getElementById(itemsContainer);
        this.selectedItemsContainer = document.getElementById(selectedItems);
        this.itemFilterInput = document.getElementById(itemSearch);
        this.selectedItemsArray = [];

        this.addEventListeners();
        this.populateItemsList();

        this.emptyMessage = "Click on chords to add";
        this.emptyMessageElement = document.createElement('div');
        this.emptyMessageElement.id = "DragAndDrop-EmptyMessage";

        const words = this.emptyMessage.split(' ');

        const baseElement = this.createItemElement({ name: "Sample Word" });
        baseElement.draggable = false;
        baseElement.isSelectable = false;

        words.forEach(word => {
            const clone = baseElement.cloneNode(true);
            clone.innerHTML = word;
            this.emptyMessageElement.appendChild(clone);
        });

        this.selectedItemsContainer.appendChild(this.emptyMessageElement);
    }

    addEventListeners() {
        window.addEventListener('dragover', this.handleWindowDragOver.bind(this));
        window.addEventListener('drop', this.handleWindowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('dragover', this.allowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('drop', this.handleDropOnContainer.bind(this));
        this.itemFilterInput.addEventListener('input', this.filterItems.bind(this));
    }

    handleWindowDragOver(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    handleWindowDrop(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    last100PercentItemIndex() {
        let lastIndex = -1;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].probability === 100) {
                lastIndex = i;
            }
        }
        return lastIndex;
    }

    populateItemsList() {
        const lastIndex100Percent = this.last100PercentItemIndex();
        let first100Percent = false;
        this.items.forEach((item, index) => {
            if (item.probability === 100 && !first100Percent) {
                first100Percent = true;
                const firstElement = document.createElement('div');
                firstElement.style.width = "100%";
                firstElement.innerHTML = "BEST MATCHES FOUND:";
                firstElement.style.backgroundColor = "#ffffff00";
                firstElement.style.color = "var(--light3)";
                firstElement.style.fontSize = "small";

                this.itemsContainer.appendChild(firstElement);
            }
            const itemElement = this.createItemElement(item, true);
            this.itemsContainer.appendChild(itemElement);

            if (index === lastIndex100Percent) {
                const breakElement = document.createElement('div');
                breakElement.style.width = "100%";
                breakElement.style.height = "2px";
                breakElement.style.backgroundColor = "var(--dark1)";
                breakElement.style.boxShadow = "var(--padding) 0px 0px 0px var(--dark1), calc(var(--padding)*-1) 0px 0px 0px var(--dark1)";

                this.itemsContainer.appendChild(breakElement);
            }
        });
    }

    createItemElement(item, isSelectable = false) {
        const itemElement = document.createElement('div');
        itemElement.textContent = item.name;

        itemElement.className = 'dragDropItem';
        itemElement.id = `dragDropItem-${this.idCounter++}`;

        if (item.probability > 0) {
            const probabilitySpan = document.createElement('span');
            probabilitySpan.textContent = `(${item.probability}%)`;
            probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability);
            if (item.probability === 100) {
                itemElement.style.boxShadow = '0px 0px 13px 0px rgba(0,255,0)';
                itemElement.style.fontWeight = "800";
            }

            itemElement.appendChild(probabilitySpan);
        }

        if (isSelectable) {
            itemElement.addEventListener('click', () => this.addSelectedItem(item));
        }
        return itemElement;
    }

    getBackgroundColor(probability) {
        const startColor = [255, 130, 130];
        const endColor = [230, 230, 30];
        const winnerColor = [150, 200, 0];

        probability = Math.max(50, Math.min(100, probability));

        const scaledProbability = (probability - 50) / 50;

        const adjustedProbability = Math.log10(1 + 9 * scaledProbability);

        let blendedColor = startColor.map((component, index) => {
            return Math.round(component + (endColor[index] - component) * adjustedProbability);
        });
        if (probability === 100) {
            blendedColor = winnerColor;
        }
        return `rgb(${blendedColor.join(',')})`;
    }

    createSelectedItemElement(item) {
        const selectedItemElement = document.createElement('div');
        selectedItemElement.className = 'selected-dragDropItem dragDropItem';
        selectedItemElement.draggable = true;
        selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`;
        selectedItemElement.textContent = item.name;
        selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this));
        selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this));
        selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this));
        selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this));
        selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this));
        return selectedItemElement;
    }

    removeSelectedItem(event) {
        event.target.remove();
        this.updateArrayFromList();
    }

    addSelectedItem(item) {

        this.selectedItemsArray.push(item);
        this.updateDisplayArray();
    }

    updateItems(newItems) {
        console.log("Updating Library...");
        this.clearList();
        this.items = newItems;
        this.populateItemsList();
    }

    clearList() {
        this.items = [];
        while (this.itemsContainer.firstChild) {
            this.itemsContainer.removeChild(this.itemsContainer.firstChild);
        }
    }

    clearSelectedList() {
        this.selectedItemsArray = [];
        while (this.selectedItemsContainer.firstChild) {
            this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild);
        }
        this.updateDisplayArray();
    }

    handleDropOnItemList(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) {
            droppedItemElement.remove();
            this.updateDisplayArray();
        }
    }

    handleDragStart(event) {
        event.dataTransfer.setData('text/plain', event.target.id);

        if (event.target.classList.contains('selected-dragDropItem')) {
            event.target.classList.add('dragging');
        }
    }

    handleDragOver(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.add('over');
        }
    }

    handleDragLeave(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.remove('over');
        }
    }

    handleDropReorder(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);
        if (!droppedItemElement) return;

        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            if (droppedItemElement.classList.contains('selected-dragDropItem')) {
                this.insertAtCorrectPosition(droppedItemElement, targetElement);
            }
        } else {
            if (!droppedItemElement.classList.contains('selected-dragDropItem')) {
                const chordName = droppedItemElement.textContent.split(' (')[0];
                const chord = this.items.find(item => item.name === chordName);

                if (chord) {
                    const newClone = this.createSelectedItemElement(chord);
                    this.selectedItemsContainer.appendChild(newClone);
                    this.selectedItemsArray.push(chord);
                }
            } else {
                this.selectedItemsContainer.appendChild(droppedItemElement);
                this.updateDisplayArray();
            }
        }
        this.updateDisplayArray();
    }


    handleDragEnd(event) {
        event.target.classList.remove('dragging');
        const overItems = document.querySelectorAll('.selected-dragDropItem');
        overItems.forEach(item => item.classList.remove('over'));
    }

    allowDrop(event) {
        event.preventDefault();
    }

    handleDropOnContainer(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) {
            const chordName = droppedItemElement.textContent.split(' (')[0];
            const chord = this.items.find(item => item.name === chordName);

            if (chord) {
                const newClone = this.createSelectedItemElement(chord);
                this.selectedItemsContainer.appendChild(newClone);
                this.selectedItemsArray.push(chord);
                this.updateDisplayArray();
            }
        }
    }
    insertAtCorrectPosition(droppedItemElement, targetElement) {
        const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement);
        const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement);

        if (droppedIndex < targetIndex) {
            targetElement.after(droppedItemElement);
        } else {
            targetElement.before(droppedItemElement);
        }
        targetElement.classList.remove('over');
        this.updateArrayFromList();
    }

    updateArrayFromList(){
        this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => {
            const chordName = el.textContent.split(' (')[0];
            return this.items.find(item => item.name === chordName);
        });
        this.updateDisplayArray();

    }

    updateDisplayArray() {

        this.selectedItemsContainer.innerHTML = ""

        if (this.selectedItemsArray.length == 0) {
            if (!this.emptyMessageElement.parentNode) {
                this.selectedItemsContainer.appendChild(this.emptyMessageElement);
            }
        } else {
            this.emptyMessageElement.remove();
        }

        this.selectedItemsArray.forEach(item => {
            const selectedItemElement = this.createSelectedItemElement(item);
            this.selectedItemsContainer.appendChild(selectedItemElement);
        })


        this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray];
        document.dispatchEvent(this.selectedItemsEvent);
        console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`);


    }

    filterItems() {
        const filterValue = this.itemFilterInput.value.toUpperCase();
        const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem');
        itemElements.forEach(itemElement => {
            const itemText = itemElement.textContent.toUpperCase();
            itemElement.style.display = itemText.includes(filterValue) ? '' : 'none';
        });
    }

    getArray() {
        return [...this.selectedItemsArray];
    }
}

File: index.html
Path: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="piano/style.css" />
    <link rel="stylesheet" href="progression-generator/style.css" />
    <link rel="stylesheet" href="css/output-styles.css" />
    <link rel="stylesheet" href="css/input-styles.css" />
    <link rel="stylesheet" href="css/slider-styles.css" />
    <link rel="stylesheet" href="css/settings-styles.css" />



    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div id="settings">
            <div class="settingsheader">Settings</div>
            <div class="settingsitem">
                <div>Guitar Tuning</div>
                <select name="string1" id="string1">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
                <select name="string2" id="string2">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
                <select name="string3" id="string3">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
                <select name="string4" id="string4">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
                <select name="string5" id="string5">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
                <select name="string6" id="string6">
                    <option value="0">C</option>
                    <option value="1">C#</option>
                    <option value="2">D</option>
                    <option value="3">D#</option>
                    <option value="4">E</option>
                    <option value="5">F</option>
                    <option value="6">F#</option>
                    <option value="7">G</option>
                    <option value="8">G#</option>
                    <option value="9">A</option>
                    <option value="10">A#</option>
                    <option value="11">B</option>
                </select>
            </div>
        </div>
        <div class="header">
            PianoToGuitar.com
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="visualPianoContainer">
                <div class="pianoMIDIWrapper">

                    <div class="pianoContainer"></div>
                    <div id="MIDIStatusDiv">
                        Initializing MIDI... </div>
                </div>
                <div class="pianoIconContainer">
                    <svg class="visualPianoIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg"
                        onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24">
                        <path
                            d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path
                            d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
            <div class="searchWordContainer">
                <div class="blackFadeBottom"></div>
                <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                <div class="searchChordList" id="itemsContainer">
                    <!-- Items will be populated here by JavaScript -->
                </div>
            </div>
        </div>
        <div class="selectedItemsHeading">
            <div>Your Selected Progression</div>
            <div id="scaleDisplay"></div>
        </div>
        <div class="selectedItemsWrapper">
            <div class="selectedItems" id="selectedItems">
                <!-- Dragged items will appear here -->
            </div>

            <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24"
                viewBox="0 -960 960 960" width="24">
                <path fill="currentColor"
                    d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
            </svg>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to
                        the
                        most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>

            </div>
        </div>
</body>

</html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js';
import Piano from './piano/script.js';
import { Chord, ChordLibrary } from "./chord-library/script.js"
import MIDIAccessManager from "./midi-integration/script.js"
import { ProgressionGenerator } from './progression-generator/main.js';
import { settings } from './chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {
    function debounce(func, wait) {
        let timeout;
        return function () {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }


    //Make Settings Button functional
    window.toggleSettings = function () {
        let settingsScreen = document.getElementById("settings");
        // Toggle a class that controls the visibility and opacity
        settingsScreen.classList.toggle('visible');
    }



    // Import the MidiManager
    const midiManager = new MIDIAccessManager();

    var visualPianoOctaves = 3


    // Function to calculate the number of octaves based on screen width
    function calculateOctaves() {
        const screenWidth = window.innerWidth;
        console.log((Math.sqrt(screenWidth)))
        const maxOctaves = 3; // Base octaves to start with
        const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25);
        visualPianoOctaves = Math.min(maxOctaves, extraOctaves)
        return visualPianoOctaves;
    }



    // Create a new Piano instance with dynamic number of octaves
    const myPiano = new Piano('.pianoContainer', { octaves: calculateOctaves() });


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);


    var isVolumeOn = localStorage.getItem('volumeState') === 'off' ? false : true;
    const volumeIcon = document.getElementById('volumeIcon');

    updateVolumeIcon(); // Update the icon at load

    window.toggleVolume = function () {

        if (isVolumeOn) {
            myPiano.volumeOff(); // Turn volume off
            isVolumeOn = false;
            localStorage.setItem('volumeState', 'off');
        } else {
            myPiano.volumeOn(); // Turn volume on
            isVolumeOn = true;
            localStorage.setItem('volumeState', 'on');
        }
        updateVolumeIcon();
    };

    function updateVolumeIcon() {
        if (!isVolumeOn) {
            volumeIcon.innerHTML = `<path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"/>`;
        } else {
            volumeIcon.innerHTML = `<path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"/>`;
        }
    }

    window.playPiano = function () {
        myPiano.playChord();
        console.log("Piano played");
    };


    window.clearPiano = function () {
        document.getElementById("itemSearch").value = ""
        myPiano.clearPiano();
        console.log("Piano cleared");
    };

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };

    // Handle window resize to adjust the number of octaves dynamically
    window.onresize = function () {
        const newOctaves = calculateOctaves();
        myPiano.setOctaves(newOctaves); // Assuming there's a method to update the octaves dynamically
    };




    document.querySelector('.pianoContainer').addEventListener('notesChanged', async (e) => {
        console.log('Piano notes changed:', e.detail.notes, e.detail.rootNote);
        let items
        if (e.detail.notes.length > 0) {
            console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote)
            items = await chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50)
        } else {
            items = allChordLibraryItems
        }
        //dragAndDropList.ceateAndInsertElement(e.detail.notes)
        dragAndDropList.updateItems(items)
        // Additional logic to handle the change in notes
    });


    //Midi Integration for Pinao Notes 
    let actualPressedKeys = new Map(); // Maps actual notes to their counts
    let visualPressedKeys = new Set();

    function mapNoteToVisualKey(note) {
        return note % (visualPianoOctaves * 12);
    }

    window.addEventListener('noteOn', (e) => {
        const { note } = e.detail;
        const visualKey = mapNoteToVisualKey(note);
        let count = actualPressedKeys.get(note) || 0;
        actualPressedKeys.set(note, count + 1);
        visualPressedKeys.add(visualKey);
        myPiano.activateKey(visualKey);
        updateRootNote();
    });

    window.addEventListener('noteOff', (e) => {
        const { note } = e.detail;
        if (actualPressedKeys.has(note)) {
            let count = actualPressedKeys.get(note);
            if (count > 1) {
                actualPressedKeys.set(note, count - 1);
            } else {
                actualPressedKeys.delete(note);
                // Check if any other actual key maps to the same visual key
                const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note));
                if (!anyOther) {
                    visualPressedKeys.delete(mapNoteToVisualKey(note));
                    myPiano.deactivateKey(mapNoteToVisualKey(note));
                }
            }
        }
        updateRootNote();
    });

    function updateRootNote() {
        if (actualPressedKeys.size > 0) {
            // Convert actualPressedKeys to an array and sort it
            const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b);

            // Determine if the lowest note should be set as the root note
            const lowestNote = sortedNotes[0];
            const lowestNoteMod12 = lowestNote % 12;
            let setRoot = false;

            // Check if the lowest note is doubled in higher octaves
            if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) {
                setRoot = true;
            }

            // Check if the lowest note is 12 interval steps away from the second lowest note
            if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6)) {
                setRoot = true;
            }

            // Set or clear the root note based on the above conditions
            if (setRoot) {
                const visualKey = mapNoteToVisualKey(lowestNote);
                myPiano.setRootNote(visualKey);
            } else {
                myPiano.clearRootNote();
            }
        } else {
            myPiano.clearRootNote();
        }
    }


    window.addEventListener("statusUpdated", async (e) => {
        document.getElementById("MIDIStatusDiv").innerHTML = e.detail
    })


    //Functionality to autom,atically add Chord when played by midi:
    window.addEventListener('notesOutput', async (e) => {
        const notes = e.detail;
        if (notes.length > 0) {
            const rootNote = Math.min(...notes);
            const searchResults = await chordLibrary.searchChords(notes, rootNote, 100);
            if (searchResults.length > 0) {
                const chord = searchResults[0];
                dragAndDropList.addSelectedItem(chord);
                //popUp.open("Added: " +chord.name, { autoClose: true, duration: 1000 });
            }
        }
    });



    //Scale Detector Listener
    const scaleDisplay = document.getElementById("scaleDisplay")
    window.addEventListener('scaleDetected', async function (event) {
        scaleDisplay.innerHTML = event.detail.scale
    });





    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems);
        await progressionGenerator.setProgression(event.detail.selectedItems)
        await updateProgressionDynamic(soundQualityValue)
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);
        await updateProgressionDynamic(soundQualityValue)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };


    //Update the Progressions to get the PLaceholders:
    updateProgressionDynamic(soundQualityValue)






    // Function to load tuning settings into the select elements
    function loadTuningSettings() {
        const storedTuning = JSON.parse(localStorage.getItem('guitarTuning'));
        const tuning = storedTuning || settings.tuning;
        for (let i = 0; i < tuning.length; i++) {
            const selectElement = document.getElementById(`string${i + 1}`);
            selectElement.value = (tuning[i] % 12).toString();
        }
    }

    // Function to update the tuning settings when select elements change
    function updateTuningSettings() {
        const newTuning = [];
        for (let i = 0; i < 6; i++) {
            const selectElement = document.getElementById(`string${i + 1}`);
            const noteIndex = parseInt(selectElement.value);
            newTuning.push(noteIndex + 28 + (i * 5));
        }
        settings.tuning = newTuning;
        localStorage.setItem('guitarTuning', JSON.stringify(newTuning));
    }

    // Add event listeners to the select elements
    for (let i = 0; i < 6; i++) {
        const selectElement = document.getElementById(`string${i + 1}`);
        selectElement.addEventListener('change', updateTuningSettings);
    }

    // Load the tuning settings on page load
    loadTuningSettings();
})


File: index.html
Path: midi-integration\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Note Logger</title>
</head>
<body>
<h1>MIDI Note Logger</h1>
<div id="status">Waiting for MIDI...</div>
<div id="log"></div>
<script src="script.js"></script>
</body>
</html>


File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 50;
        this.notesPlayed = new Set();
        this.activeNotes = new Set();

        if (navigator.requestMIDIAccess) {
            this.attemptMIDIAccess();
        } else {
            console.log("Web MIDI API not supported!");
        }
    }

    attemptMIDIAccess() {
        navigator.requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))
            .catch(err => {
                console.error('Error accessing MIDI devices:', err);
                this.handleRetry(err);
            });
    }

    onMIDISuccess(midiAccess) {
        this.updateStatus("MIDI ready...");
        this.midiAccess = midiAccess; // Store midiAccess for later use
        midiAccess.onstatechange = this.updateDeviceState.bind(this);
        this.addMIDIInputs(midiAccess.inputs);
    }

    addMIDIInputs(inputs) {
        Array.from(inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this));
    }

    onMIDIFailure() {
        this.updateStatus("");
        this.handleRetry(new Error("Initial connection failed"));
    }

    handleRetry(err) {
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            console.log(`Retrying... Attempt ${this.retryCount}`);
            setTimeout(() => this.attemptMIDIAccess(), 3000); // Retry after 3 seconds
        } else {
            console.error(`Failed to connect after ${this.maxRetries} attempts: ${err.message}`);
            //No Midi Device Found
            this.updateStatus("");
        }
    }

    onMIDIMessage({ data: [command, note, velocity] }) {
        const eventDetail = { command, note, velocity };
        if (command === 144 && velocity > 0) {
            if (this.activeNotes.size === 0) { // New session
                this.notesPlayed.clear();
            }
            this.notesPlayed.add(note);
            this.activeNotes.add(note);
            window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail }));
        } else if (command === 128 || velocity === 0) {
            this.activeNotes.delete(note);
            window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail }));
            if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) {
                this.outputNotes();
            }
        }
    }

    outputNotes() {
        const uniqueNotes = Array.from(this.notesPlayed);
        console.log(uniqueNotes);
        window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes }));
    }

    updateStatus(message) {
        window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message }));
    }

    updateDeviceState({ port }) {
        const status = `MIDI: ${port.name} ${port.state}`;
        this.updateStatus(status);
        window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } }));

        if (port.state === "disconnected" || port.state === "unavailable") {
            this.handleDisconnection();
        }
    }

    handleDisconnection() {
        console.log("MIDI device disconnected. Attempting to reconnect...");
        this.attemptMIDIAccess();
    }
}

export default MIDIAccessManager;


File: script.js
Path: piano\script.js

class Piano {
    constructor(containerSelector, options = {}) {
        this.container = document.querySelector(containerSelector);
        this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50);

        this.octaves = options.octaves || 2;
        this.playedNotes = [];
        this.rootNote = null; // Add a property for the root note

        this.lastClickTime = 0;
        this.clickDelay = 300; // 300 milliseconds delay

        this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        this.keysPerOctave = this.layout.length;
        this.whiteKeyCount = this.layout.filter(x => x === 0).length;
        this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
        this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
        this.blackKeyHeight = 0.63;
        this.totalKeys = this.octaves * this.keysPerOctave;

        this.audioElements = [];
        this.volume = true
        this.globalVolume = 0.7;  // Global volume set to maximum by default


        this.createPiano();
        this.addKeyListeners();
    }

    volumeOff() {
        this.volume = false
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

    }

    volumeOn() {
        this.volume = true
    }

    updateVolume() {
        const activeCount = this.playedNotes.length;
        const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
        this.audioElements.forEach(audio => {
            if (!audio.paused) {  // Only update audio elements that are currently playing
                audio.volume = volume;
            }
        });
    }
    
    

    createPiano() {
        this.container.innerHTML = ''; // Clear existing piano keys
        let whiteCounter = 0;

        for (let index = 0; index < this.totalKeys; index++) {
            let key = document.createElement("div");
            key.setAttribute('data-note', index);
            if (this.layout[index % this.keysPerOctave] === 1) {
                key.classList.add("key", "black");
                key.style.left = `${(whiteCounter * this.whiteKeyWidth) - (this.blackKeyWidth / 2)}%`;
                key.style.width = `${this.blackKeyWidth}%`;
                key.style.height = `${this.blackKeyHeight * 100}%`;
                key.style.boxSizing = "border-box";
                key.style.position = `absolute`;
            } else {
                key.classList.add("key", "white");
                key.style.boxSizing = "border-box";
                key.style.width = `${this.whiteKeyWidth}%`;
                whiteCounter++;
            }
            this.container.appendChild(key);
            this.audioElements[index] = new Audio(`./audio/${index % 24}.mp3`);
            this.audioElements[index].preload = 'auto'; // This tells the browser to load the audio as soon as the page is loaded


        }
    }

    addKeyListeners() {
        this.container.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                //console.log("Click triggered")
                let currentTime = Date.now();



                const note = key.getAttribute('data-note');

                
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    if (currentTime - this.lastClickTime > 200) {
                        this.lastClickTime = currentTime;
                        //console.log("Set Time to: "+currentTime)
                    }

                    this.rootNote = null;

                } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) {
                    this.playedNotes = this.playedNotes.filter(n => n !== note);
                    key.classList.remove("selectedKey");
                } else {
                    if (!this.playedNotes.includes(note)) {
                        this.playedNotes.push(note);
                    }
                    key.classList.add("selectedKey");
                    this.playSoundLong(note, 0.75);
                }
                this.updatePlayedNotesDebounced();
            });

            key.addEventListener('dblclick', (event) => {
                //console.log("Doubleclick triggered")
                const note = key.getAttribute('data-note');
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    this.rootNote = null;
                } else {
                    if (this.rootNote !== null) {
                        this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
                    }
                    let currentTime = Date.now();
                    if (currentTime - this.lastClickTime < 500) {
                    } else {
                        this.rootNote = note;
                        if (!this.playedNotes.includes(note)) {
                            this.playedNotes.push(note);
                        }
                        key.classList.add('rootNote', 'selectedKey');
                    }

                }
                this.updatePlayedNotesDebounced();
            });
        });
    }


    debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }


    playSoundLong(index, localVolume) {
        if (this.volume) {
            const audio = this.audioElements[index];
            audio.volume = localVolume * this.globalVolume; // Apply global volume scaling
            if (!audio.paused) {
                audio.currentTime = 0; // Reset if it is already playing
            }
            audio.play();
        }
    }


    
    playChord() {
        this.playedNotes.sort((a, b) => a - b);
        const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1);
        this.playedNotes.forEach((note, index) => {
            const randomDelay = Math.random() * 20;
            setTimeout(() => {
                this.playSoundLong(note, localVolume);
            }, 20 * index + randomDelay);
        });
    }

    activateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (!key.classList.contains("selectedKey")) {
            key.classList.add("selectedKey");
            this.playedNotes.push(index);
            this.updatePlayedNotesDebounced();
            this.updateVolume(); // Adjust volume based on the new number of active notes
        }
        this.playSoundLong(index, 0.75); // Initial play sound with default volume
    }
    
    

    deactivateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (key.classList.contains("selectedKey")) {
            key.classList.remove("selectedKey");
            this.playedNotes = this.playedNotes.filter(n => n !== index);
            this.updatePlayedNotesDebounced();
            // Do not update volume here to keep it consistent with the number of keys pressed
        }
    }
    
    setRootNote(note) {
        const key = this.container.querySelector(`.key[data-note="${note}"]`);
        if (this.rootNote !== null) {
            // Remove rootNote class from the old root note
            this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
        }
        this.rootNote = note; // Update the rootNote to the new note
        key.classList.add('rootNote', 'selectedKey'); // Add rootNote class to new root note
        if (!this.playedNotes.includes(note)) {
            this.playedNotes.push(note); // Add root note to playedNotes if it's not already there
        }
        this.updatePlayedNotesDebounced();
    }

    clearRootNote() {
        if (this.rootNote !== null) {
            const key = this.container.querySelector(`.key[data-note="${this.rootNote}"]`);
            key.classList.remove('rootNote'); // Remove the rootNote class
            this.rootNote = null; // Reset the rootNote property
            this.updatePlayedNotesDebounced();
        }
    }

    updatePlayedNotes() {
        const event = new CustomEvent('notesChanged', { detail: { notes: this.playedNotes, rootNote: this.rootNote } });
        console.log("Dispatching Note Change Event: " + this.playedNotes + " Root: " + this.rootNote)
        this.container.dispatchEvent(event);
    }
    clearPiano() {

        this.playedNotes = []; // Clear the array of played notes
        this.rootNote = null; // Clear the root note
        this.container.querySelectorAll('.key.selectedKey').forEach(key => {
            key.classList.remove("selectedKey");
        });
        this.container.querySelectorAll('.key.rootNote').forEach(key => {
            key.classList.remove("rootNote");
        });
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });
        this.updatePlayedNotes();
    }

    setOctaves(newOctaves) {
        if (newOctaves !== this.octaves) {
            this.octaves = newOctaves;
            this.totalKeys = this.octaves * this.keysPerOctave;
            this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
            this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
            this.clearPiano();
            this.createPiano();
            this.addKeyListeners();
        }
    }
}

export default Piano;


File: main.js
Path: progression-generator\main.js

import { settings, BARRE_RATING } from '../chord-factory/constants.js';
import { parseNotes, removeDuplicateArrays, NOTE_INDEX_MAP} from '../chord-factory/utils.js';
import { ChordFactory } from '../chord-factory/chordfactory.js';
import { Chord } from '../chord-library/script.js';
import { numberToNote } from '../chord-factory/utils.js';
import TabGenerator from "../tab-generator/script.js"
import { TabHTML } from './tabhtml.js';



export class ProgressionGenerator {
    constructor(initialProgression = [], useRoot = true, tuning = settings.tuning, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.tuning = tuning;
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.progression = [];
        this.useRoot = useRoot; // This flag determines if the root note should be the starting note
        this.chordFactoryMap = {}; // HashMap to store ChordFactory instances
        this.keyAnalysis = []

        this.setProgression(initialProgression);

        this.progressionTypes = {
            basic: this.getProgressionBasic,
            // Add more progression types as methods here
        };
    }

    addKeyAnalysis(root, keyscale, prob) {
        // Push a new object to the array with the analysis data
        this.keyAnalysis.push({
            rootNote: root,
            scale: keyscale,
            probability: prob
        });
    }
    analyzeKey() {

        this.keyAnalysis = []
        //Define Possible Scales
        //Higher Prioroty means They get artifically boostes at the Raking
        const scaleStructures = {
            'Major': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 },  // Major Scale: C, D, E, F, G, A, B
            'Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 },  // Natural Minor Scale: A, B, C, D, E, F, G
            'Minor Pentatonic': { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 },  // Minor Pentatonic Scale: A, C, D, E, G
            'Major Pentatonic': { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 },  // Major Pentatonic Scale: C, D, E, G, A
            'Harmonic Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 },  // Harmonic Minor Scale: A, B, C, D, E, F, G#
            'Blues': { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 },  // Blues Scale: A, C, D, D#, E, G
            'Mixolydian': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 },  // Mixolydian Mode: G, A, B, C, D, E, F
            'Dorian': { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, // Dorian Mode: D, E, F, G, A, B, C
            'Phrygian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, // Phrygian Mode: E, F, G, A, B, C, D
            'Lydian': { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, // Lydian Mode: F, G, A, B, C, D, E
            'Locrian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 }  // Locrian Mode: B, C, D, E, F, G, A
        };


        //Generate an Array of Notes and How often They are present
        let notesSet = Array(12).fill(0);
        this.progression.forEach(element => {
            element.notes.forEach(note => {
                notesSet[note]++
            })
        })
        console.log("analyzeKey - notesSet:", notesSet)





        //Now GO through The NoteSet and Calucalte A Number for The Probability of the Key
        notesSet.forEach((scopeNote, index) => {


            //Only Look at occuring Notes
            if (scopeNote != 0) {
                //Loop Through the scaleStrucurtres and the notes array

                Object.keys(scaleStructures).forEach(key => {
                    let ammountWeight = 0.01
                    let rootWeight = 0.01
                    //DO NOT CHANGE
                    let distanceToRootWeight = 1
                    let keyProbability = 0
                    for (let relativeNote = 0; relativeNote < 11; relativeNote++) {
                        if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) {
                            keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight))
                            distanceToRootWeight += rootWeight
                        }
                    }
                    this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority)
                })

            }
        })
        this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability);
        return
    }


    // Set initial progression with ChordFactory instances for each chord
    async setProgression(initialProgression) {
        const newChordFactoryMap = {};
        // Create or reuse ChordFactory instances
        initialProgression.forEach(chord => {
            if (chord instanceof Chord) {
                let chordFactory;
                if (this.chordFactoryMap[chord.name]) {
                    chordFactory = this.chordFactoryMap[chord.name];
                    console.log('ChordFactory retrieved for:', chord.name);

                } else {
                    chordFactory = new ChordFactory(chord, this.useRoot, this.tuning);
                    console.log('New ChordFactory created for:', chord.name);
                }
                newChordFactoryMap[chord.name] = chordFactory;
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
            }
        });

        // Update the hashmap and clear out unused ChordFactories
        this.chordFactoryMap = newChordFactoryMap;

        // Populate this.progression with references from the new map
        this.progression = initialProgression.map(chord => this.chordFactoryMap[chord.name]);
        if (this.progression.length > 1) {
            this.analyzeKey()
            console.log("analyzeKey: ", this.keyAnalysis)
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: <b>" + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale + "</b>" } });
            console.log("Key Change Event: " + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale)
            window.dispatchEvent(event);
        } else {
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: ..." } });
            console.log("Key Change Event: none")
            window.dispatchEvent(event);
        }

    }

    getProgression(type = 'basic') {
        if (this.progressionTypes[type]) {
            return this.progressionTypes[type].call(this); // Ensures the method is called with correct this context
        } else {
            console.error('ProgressionGenerator: Invalid progression type requested.');
            return [];
        }
    }

    getPlaceholderHTML() {
        const placeholderCount = 4; // Generate 1 to 3 placeholders
        const diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.style.opacity = 0.2
        diagramsContainer.style.display = "flex"

        for (let i = 0; i < placeholderCount; i++) {
            // Example placeholder data


            let voicing = [0, 0, 0, 0, 0, 0];

            // Create a set to keep track of chosen indices (to ensure uniqueness)
            let indices = new Set();

            // Randomly choose 4 unique indices
            while (indices.size < 4) {
                let index = Math.floor(Math.random() * voicing.length);
                indices.add(index);
            }

            // Populate the chosen indices with random numbers between -1 and 4
            indices.forEach(index => {
                voicing[index] = Math.floor(Math.random() * 6) - 1; // Generates values from -1 to 4
            });

            const fingerPositions = [0, 0, 0, 0, 0, 0]; // Positions for C major
            const barreSize = 0; // No barre for this example

            // Assuming TabGenerator can handle this static data
            try {
                const chordDiagram = new TabGenerator(voicing, fingerPositions, 0, null, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                const svg = chordDiagram.generateChordSVG();
                diagramsContainer.appendChild(svg);
            } catch (error) {
                console.error('Error generating placeholder chord diagram:', error);
            }
        }
        const textContent = document.createElement('div')
        textContent.innerHTML = "Search for chords using the piano keys, the search bar, or connect your MIDI device."
        textContent.style.display = "flex"
        textContent.style.alignItems = "center"
        diagramsContainer.appendChild(textContent);
        return diagramsContainer; // Return the container with all placeholder SVGs
    }

    getProgressionHTML(desiredClasses = [], progressionType = "basic") {
        // Create an instance of ProgressionGenerator with the given progression and tuning
        const progression = this.getProgression(progressionType); // Get the basic progression

        const diagramsContainer = document.createElement('div'); // Container for chord diagrams
        desiredClasses.forEach(desiredClass => {
            diagramsContainer.classList.add(desiredClass)
        });

        progression.forEach(chordVoicing => {
            // Extract first playable chord from each ChordFactory instance
            if (chordVoicing) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    const chordDiagram = new TabGenerator(chordVoicing.voicing, chordVoicing.fingerPositions, chordVoicing.minAboveZero, chordVoicing.barres, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                    const svg = chordDiagram.generateChordSVG();
                    diagramsContainer.appendChild(svg);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        });

        return diagramsContainer; // Return the container with all SVGs
    }

    getProgressionBasic() {
        // Iterate over each entry in the progression and get the first playable chord
        return this.progression.map(chordFactory => {
            if (chordFactory.playableChords && chordFactory.playableChords.length > 0) {
                return chordFactory.playableChords[0];
            } else {
                return null; // Return null if there are no playable chords available
            }
        }).filter(chord => chord !== null); // Filter out any null entries
    }


    async getProgressionDynamicHTML(soundQuality = 0.5, ammount = 1) {
        // Check if there are any chords in the progression
        if (this.progression.length < 1) {
            return this.getPlaceholderHTML();
        }
    
        // Create the container for the chord diagrams
        let diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.classList.add("progressionGeneratorContainer");
    
        // Iterate over each ChordFactory instance in the progression
        this.progression.forEach(chordFactory => {
            // Create an instance of TabHTML for the current chordFactory
            const tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);
    
            // Generate the HTML for the current chordFactory
            const chordDiagrams = tabHTML.generateHTML(soundQuality, ammount);
    
            // Append the generated HTML to the main container
            chordDiagrams.forEach(element=>{
                diagramsContainer.appendChild(element);

            })
        });
    
        // Return the container with all chord diagrams
        return diagramsContainer;
    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
}

File: tabhtml.js
Path: progression-generator\tabhtml.js

import TabGenerator from "../tab-generator/script.js";

export class TabHTML {
    constructor(chordFactory, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.chordFactory = chordFactory; // Pointer to the ChordFactory instance
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.currentIndex = 0; // Track the current index of playable chords
        this.maxChords = chordFactory.playableChords.length

    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }

    vibrateElement(element) {
        element.classList.add('vibrate');
        setTimeout(() => {
            element.classList.remove('vibrate');
        }, 200); // Match this duration with the animation duration in CSS
    }

    updateChordDiagram(svgContainer, svgNameContainer,voicingInfoDiv, direction) {
        const playableChords = this.chordFactory.playableChords;
        voicingInfoDiv.innerHTML=this.currentIndex+1 + " / " + this.maxChords
        if (this.currentIndex < playableChords.length && this.currentIndex >= 0) {
            let slideOutClass, slideInClass;

            if (direction === 'next') {
                slideOutClass = 'slide-out-left';
                slideInClass = 'slide-in-right';
            } else if (direction === 'previous') {
                slideOutClass = 'slide-out-right';
                slideInClass = 'slide-in-left';
            }

            // Apply slide-out animation to the current SVG
            svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
            svgContainer.classList.add(slideOutClass);

            // Wait for the slide-out animation to complete
            setTimeout(() => {
                const chord = playableChords[this.currentIndex];
                const chordDiagram = new TabGenerator(
                    chord.voicing,
                    chord.fingerPositions,
                    chord.minAboveZero,
                    chord.barres,
                    this.color,
                    this.invertColor(this.color),
                    this.fingerNumbers,
                    this.showOpenStrings
                );
                const newSvg = chordDiagram.generateChordSVG();

                // Replace the old SVG with the new one
                svgContainer.innerHTML = '';
                svgContainer.appendChild(newSvg);
                svgNameContainer.innerHTML = this.chordFactory.identifier;

                // Apply slide-in animation to the new SVG
                svgContainer.classList.remove(slideOutClass);
                svgContainer.classList.add(slideInClass);
                setTimeout(() => {
                    svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
                },100)
            }, 100); // Match this duration with the animation duration in CSS

        }
    }

    generateHTML(soundQuality = 0.5, ammount = 1) {
        // Sort the playable chords by combined rating
        this.chordFactory.sortPlayableChordsByCombinedRating(soundQuality);

        let diagrams = [];

        // Extract first 'ammount' playable chords from the ChordFactory instance
        for (let i = 0; i < ammount; i++) {
            if (this.chordFactory.playableChords[i]) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    this.currentIndex = i;
                    const chord = this.chordFactory.playableChords[this.currentIndex];
                    const chordDiagram = new TabGenerator(
                        chord.voicing,
                        chord.fingerPositions,
                        chord.minAboveZero,
                        chord.barres,
                        this.color,
                        this.invertColor(this.color),
                        this.fingerNumbers,
                        this.showOpenStrings
                    );
                    const svg = chordDiagram.generateChordSVG();
                    let svgInfoContainer = document.createElement('div');
                    svgInfoContainer.classList.add("progressionGeneratorSvgInfoContainer");

                    let voicingInfoContainer = document.createElement('div');
                    voicingInfoContainer.classList.add("progressionGeneratorVoicingInfoContainer");

                    let voicingInfoDiv = document.createElement('div');
                    voicingInfoDiv.innerHTML = this.currentIndex + 1 + " / " + this.maxChords;

                    let svgContainer = document.createElement('div'); // Container for chord diagrams
                    svgContainer.classList.add("progressionGeneratorSvgContainer");

                    let svgNameContainer = document.createElement('div'); // Container for chord diagrams
                    svgNameContainer.innerHTML = this.chordFactory.identifier;
                    svgNameContainer.classList.add("progressionGeneratorSvgChordName");

                    // SVG for next button
                    const nextButton = document.createElement('div');
                    nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="M579-480 285-774q-15-15-14.5-35.5T286-845q15-15 35.5-15t35.5 15l307 308q12 12 18 27t6 30q0 15-6 30t-18 27L356-115q-15 15-35 14.5T286-116q-15-15-15-35.5t15-35.5l293-293Z"/></svg>';

                    nextButton.classList.add("progressionGeneratorChordButton");

                    nextButton.onclick = () => {
                        if (this.currentIndex + 1 < this.chordFactory.playableChords.length) {
                            this.currentIndex++;
                            this.updateChordDiagram(svgContainer, svgNameContainer, voicingInfoDiv, 'next');
                        } else {
                            this.vibrateElement(svgContainer);
                        }
                    };

                    // SVG for previous button
                    const prevButton = document.createElement('div');
                    prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="m142-480 294 294q15 15 14.5 35T435-116q-15 15-35 15t-35-15L57-423q-12-12-18-27t-6-30q0-15 6-30t18-27l308-308q15-15 35.5-14.5T436-844q15 15 15 35t-15 35L142-480Z"/></svg>';
                    prevButton.classList.add("progressionGeneratorChordButton");

                    prevButton.onclick = () => {
                        if (this.currentIndex > 0) {
                            this.currentIndex--;
                            this.updateChordDiagram(svgContainer, svgNameContainer, voicingInfoDiv, 'previous');
                        } else {
                            this.vibrateElement(svgContainer);
                        }
                    };

                    svgContainer.appendChild(svg);
                    voicingInfoContainer.appendChild(prevButton);
                    voicingInfoContainer.appendChild(voicingInfoDiv);
                    svgInfoContainer.appendChild(svgNameContainer);
                    voicingInfoContainer.appendChild(nextButton);
                    let diagramsContainer = document.createElement('div');
                    diagramsContainer.classList.add("progressionGeneratorDiagramsContainer");


                    diagramsContainer.appendChild(svgContainer);
                    diagramsContainer.appendChild(voicingInfoContainer);
                    diagramsContainer.appendChild(svgInfoContainer);
                    diagrams.push(diagramsContainer);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        }

        return diagrams; // Return the container with all SVGs
    }
}

File: settings.js
Path: settings.js

import { noteToNumber, numberToNote } from "./chord-factory/utils.js";

document.addEventListener('DOMContentLoaded', () => {

    // Function to load tuning settings into the select elements
    function loadTuningSettings() {
        const storedTuning = JSON.parse(localStorage.getItem('guitarTuning'));
        const tuning = storedTuning || settings.tuning;
        for (let i = 0; i < tuning.length; i++) {
            const selectElement = document.getElementById(`string${i + 1}`);
            selectElement.value = (tuning[i] % 12);
        }
    }

    // Function to update the tuning settings when select elements change
    function updateTuningSettings() {
        const newTuning = [];
        for (let i = 0; i < 6; i++) {
            const selectElement = document.getElementById(`string${i + 1}`);
            const noteIndex = parseInt(selectElement.value);
            newTuning.push(noteIndex + 28 + (i * 5));
        }
        settings.tuning = newTuning;
        localStorage.setItem('guitarTuning', JSON.stringify(newTuning));
    }

    // Add event listeners to the select elements
    for (let i = 0; i < 6; i++) {
        const selectElement = document.getElementById(`string${i + 1}`);
        selectElement.addEventListener('change', updateTuningSettings);
    }

    // Load the tuning settings on page load
    loadTuningSettings();
})

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Diagram Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>Guitar Chord Diagram Generator</h1>
        <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input">
        <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)">
        <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button>
        <div id="diagram" class="diagram-container"></div>
    </div>
    <script type="module">
        import TabGenerator from "./script.js"

        const fingerPositions = ['-1', '5', '6', '5', '0', '0'];
        const fingerNumbers = ['1', '1', '2', '1', '', ''];
        const barre = 10;
        const minAboveZero = 15
        const barres = [[5,1,3], [3,0,5]]
        const color = "#fff";
        const textColor = "#000";
        const showOpenStrings = true;

        try {
            const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, minAboveZero, barres, color, textColor, 'belowString', showOpenStrings);
            const svg = chordDiagram.generateChordSVG();
            document.getElementById('diagram').appendChild(svg);
        } catch (error) {
            console.error('Error generating chord diagram:', error);
        }
    </script>
</body>

</html>

File: script.js
Path: tab-generator\script.js

/**
 * Represents a TabGenerator for creating guitar chord diagrams as SVG elements.
 * This class allows the configuration of various aspects of the diagram, including finger positions,
 * barre chords, string and note visualization, and color customization.
 */
class TabGenerator {
    /**
     * Creates an instance of TabGenerator.
     * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings.
     * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string.
     * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used.
     * @param {string} [barre=null] - Specific fret where the barre is placed.
     * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes.
     * @param {string} [textColor="#fff"] - Color for the text used in the diagram.
     * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately.
     * @param {boolean} showOpenStrings - Whether to display open strings in the diagram.
     */
    constructor(fingerPositions, fingerNumbers, minAboveZero = 0, barres = [], elementColor = "#000", textColor = "#fff", numberPosition = 'onNote', showOpenStrings) {

        if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) {
            console.error("Error: fingerPositions must be an array of length 6.");
        }
        if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) {
            console.error("Error: fingerNumbers must be an array of length 6 or null.");
        }
        if (typeof elementColor !== 'string') {
            console.error("Error: elementColor must be a string.");
        }
        if (typeof textColor !== 'string') {
            console.error("Error: textColor must be a string.");
        }
        if (numberPosition !== 'onNote' && numberPosition !== 'belowString') {
            console.error("Error: numberPosition must be either 'onNote' or 'belowString'.");
        }
        if (typeof showOpenStrings !== 'boolean') {
            console.error("Error: showOpenStrings must be a boolean.");
        }
        // Assign instance variables
        this.fingerPositions = fingerPositions;
        this.fingerNumbers = fingerNumbers;
        this.barres = barres;               // Specific fret where the barre is placed
        this.color = elementColor; // Color for diagram elements
        this.textColor = textColor;       // Color for the text
        this.numberPosition = numberPosition; // Position of the numbers
        this.showOpenStrings = showOpenStrings; // Whether to display open strings
        this.maxFret = Math.max(...fingerPositions)



        // Diagram layout constants
        this.topSpacing = 25;
        this.topBarHeight = 7;
        this.fretSpacing = 25;
        this.stringSpacing = 25;
        this.paddingLeft = 10;
        this.barreSidesOverflow = 10;
        this.stringOverflowBotom = 10;
        this.fretCount = 4;
        this.circleRadius = 10;
        this.infoPadding = 10;
        this.openStringRadius = 7;


        //Offset
        this.offset = 1
        if (this.maxFret > this.fretCount){
            this.offset = minAboveZero
        }

        //Global Framw Width
        this.width = 185;
        this.height = 145
    }

    generateChordSVG() {
        const svgAttributes = {
            width:  this.width,
            height: this.height,
            viewBox: "0 0 " +  this.width + " " +this.height  // This sets the viewBox attribute
        };
        const svg = this.createSVGElement('svg', svgAttributes);
        this.drawDiagramComponents(svg);
        return svg;
    }

    drawDiagramComponents(svg) {
        this.drawTopBar(svg);
        if (this.barres) {
            this.barres.forEach(element => {
                this.drawBarre(svg, element[0], element[1], element[2]);

            });
        }
        this.drawStrings(svg);
        this.drawFrets(svg);
        if (this.showOpenStrings) {
            this.drawOpenStrings(svg);
        }
        this.drawNotes(svg);
        this.drawMuteIndicators(svg);
        this.drawFretHeight(svg)
    }


    createSVGElement(tag, attributes) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const attr in attributes) {
            element.setAttribute(attr, attributes[attr]);
        }
        return element;
    }

    drawTopBar(svg) {
        const topBar = this.createSVGElement('rect', {
            x: this.paddingLeft,
            y: this.topSpacing,
            width: this.stringSpacing * 5,
            height: this.topBarHeight,
            fill: this.color,
            stroke: this.color,
            'stroke-width': '2'
        });
        svg.appendChild(topBar);
    }

    drawStrings(svg) {
        for (let i = 0; i < 6; i++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft + i * this.stringSpacing, y1: this.topSpacing,
                x2: this.paddingLeft + i * this.stringSpacing, y2: this.fretSpacing * this.fretCount + this.topSpacing + this.stringOverflowBotom + this.topBarHeight,
                stroke: this.color, 'stroke-width': ((6 - i) / 3) + 1
            });
            svg.appendChild(line);
        }
    }

    drawFrets(svg) {
        for (let j = 0; j < this.fretCount + 1; j++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft, y1: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                x2: this.paddingLeft + this.stringSpacing * 5, y2: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                stroke: this.color, 'stroke-width': '2'
            });
            svg.appendChild(line);
        }
    }

    drawNotes(svg) {
        for (let string = 0; string < 6; string++) {
            if (this.fingerPositions[string] > 0) {
                let fret = parseInt(this.fingerPositions[string]);
                if (fret > 0) {
                    let position = this.topSpacing + this.topBarHeight + ((fret) - this.offset) * this.fretSpacing - this.circleRadius / 2;
                    let circle = this.createSVGElement('circle', {
                        cx: this.paddingLeft + string * this.stringSpacing, cy: position + this.topSpacing - 8,
                        r: this.circleRadius, fill: this.color
                    });
                    svg.appendChild(circle);

                    if (this.fingerNumbers && this.fingerNumbers[string]) {
                        const textPositionY = this.numberPosition === 'onNote' ? position + this.topSpacing : this.topSpacing + this.topBarHeight + (this.fretCount + 1) * this.fretSpacing + this.stringOverflowBotom;
                        const text = this.createSVGElement('text', {
                            x: this.paddingLeft + string * this.stringSpacing,
                            y: textPositionY,
                            'font-family': 'Arial',
                            'font-size': '20',
                            'font-weight': '500',
                            fill: this.numberPosition === 'onNote' ? this.textColor : this.color,
                            'text-anchor': 'middle'
                        });
                        text.textContent = this.fingerNumbers[string];
                        svg.appendChild(text);
                    }
                }
            }
        }
    }

    drawMuteIndicators(svg) {
        const radius = 10
        const height = radius * Math.sqrt(2)

        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] == -1) {
                const line1 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - height - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                const line2 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - height - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(line1);
                svg.appendChild(line2);
            }
        }
    }

    drawOpenStrings(svg) {
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] === '0') {
                const circle = this.createSVGElement('circle', {
                    cx: this.paddingLeft + i * this.stringSpacing,
                    cy: this.topSpacing - this.infoPadding - this.openStringRadius,
                    r: this.openStringRadius,
                    fill: 'none',
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(circle);
            }
        }
    }

    drawBarre(svg, barreFret, barreStartString, barreEndString) {
        if (barreFret != 0) {
            barreFret = barreFret - this.offset 
            const barreWidth = barreEndString - barreStartString
            const barreHeight = 10;
            const barreX = this.paddingLeft - this.barreSidesOverflow + barreStartString * this.stringSpacing;
            const barreY = barreFret * this.fretSpacing + this.topSpacing + this.topBarHeight + (this.fretSpacing / 2) - barreHeight / 2;

            const rect = this.createSVGElement('rect', {
                x: barreX, y: barreY,
                width: barreWidth * this.stringSpacing + 2 * this.barreSidesOverflow, height: barreHeight,
                rx: '5', ry: '5',
                fill: this.color
            });
            svg.appendChild(rect);


        }
    }

    drawFretHeight(svg) {
        if (this.offset  > 1) {
            const text = this.createSVGElement('text', {
                x:this.paddingLeft + this.stringSpacing*5 + this.infoPadding, y: this.topSpacing + this.topBarHeight + this.fretSpacing * 0.5,
                'font-family': 'Arial', 'font-size': '20', fill: this.color,
                'text-anchor': 'left',
                "alignment-baseline": "central"
            });
            text.textContent = this.offset  + "fr";
            svg.appendChild(text);
        }
    }
}

export default TabGenerator;

File: test.html
Path: test.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Tuning Selector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        
        .container {
            width: 300px;
            margin: 50px auto;
            text-align: center;
        }
        
        #tuning-search {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
        }
        
        .dropdown-content {
            display: none;
            position: relative;
            background-color: #f9f9f9;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            z-index: 1;
            transition: max-height 0.3s ease;
        }
        
        .dropdown-content a {
            padding: 8px 16px;
            text-decoration: none;
            display: block;
            text-align: left;
        }
        
        .dropdown-content a:hover,
        .dropdown-content a:focus {
            background-color: #f1f1f1;
        }
        
        .dropdown-content a.active {
            background-color: #e0e0e0;
        }
        
        button {
            padding: 8px 16px;
            margin-top: 10px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            margin: 15% auto;
            width: 80%;
            max-width: 400px;
            position: relative;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 20px;
            cursor: pointer;
        }

        .feedback {
            display: none;
            color: green;
            margin-top: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <label for="tuning-search">Select Guitar Tuning:</label>
        <input type="text" id="tuning-search" placeholder="Search or Add Custom Tuning" aria-haspopup="listbox" aria-expanded="false" aria-controls="tuning-dropdown">
        <div id="tuning-dropdown" class="dropdown-content" role="listbox">
            <!-- Dynamically populated options -->
        </div>
        <button id="add-custom-btn">Add Custom Tuning</button>
        <div class="feedback" id="feedback-message">Custom tuning added successfully! (Click to dismiss)</div>
    </div>

    <!-- Modal for Custom Tuning -->
    <div id="custom-modal" class="modal" aria-hidden="true">
        <div class="modal-content">
            <span class="close-btn" role="button" aria-label="Close">&times;</span>
            <h2>Add Custom Tuning</h2>
            <form id="custom-tuning-form">
                <label for="string1">String 1:</label>
                <input type="text" id="string1" name="string1" required>
                <label for="string2">String 2:</label>
                <input type="text" id="string2" name="string2" required>
                <label for="string3">String 3:</label>
                <input type="text" id="string3" name="string3" required>
                <label for="string4">String 4:</label>
                <input type="text" id="string4" name="string4" required>
                <label for="string5">String 5:</label>
                <input type="text" id="string5" name="string5" required>
                <label for="string6">String 6:</label>
                <input type="text" id="string6" name="string6" required>
                <button type="submit">Save Tuning</button>
            </form>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const tuningSearch = document.getElementById('tuning-search');
            const tuningDropdown = document.getElementById('tuning-dropdown');
            const addCustomBtn = document.getElementById('add-custom-btn');
            const customModal = document.getElementById('custom-modal');
            const closeBtn = document.querySelector('.close-btn');
            const customTuningForm = document.getElementById('custom-tuning-form');
            const feedbackMessage = document.getElementById('feedback-message');

            const tunings = [
                'Standard E',
                'Drop D',
                'DADGAD',
                'Open G',
                'Open D',
                'Half Step Down',
                'Full Step Down',
                // Add more predefined tunings here
            ];

            let activeOptionIndex = -1;

            function populateDropdown(tunings) {
                tuningDropdown.innerHTML = '';
                tunings.forEach((tuning, index) => {
                    const option = document.createElement('a');
                    option.href = '#';
                    option.textContent = tuning;
                    option.setAttribute('role', 'option');
                    option.tabIndex = 0;
                    option.addEventListener('click', () => selectTuning(tuning));
                    tuningDropdown.appendChild(option);
                });
            }

            function selectTuning(tuning) {
                tuningSearch.value = tuning;
                toggleDropdownVisibility(false);
                activeOptionIndex = -1;
            }

            function toggleDropdownVisibility(visible) {
                tuningDropdown.style.display = visible ? 'block' : 'none';
                tuningSearch.setAttribute('aria-expanded', visible.toString());
                tuningDropdown.style.maxHeight = visible ? '200px' : '0';
            }

            function handleArrowKeys(event) {
                const options = tuningDropdown.getElementsByTagName('a');
                if (options.length > 0) {
                    if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        activeOptionIndex = (activeOptionIndex + 1) % options.length;
                        updateActiveOption(options);
                    } else if (event.key === 'ArrowUp') {
                        event.preventDefault();
                        activeOptionIndex = (activeOptionIndex - 1 + options.length) % options.length;
                        updateActiveOption(options);
                    } else if (event.key === 'Enter' && activeOptionIndex > -1) {
                        event.preventDefault();
                        selectTuning(options[activeOptionIndex].textContent);
                    }
                }
            }

            function updateActiveOption(options) {
                Array.from(options).forEach(option => option.classList.remove('active'));
                if (activeOptionIndex > -1) {
                    options[activeOptionIndex].classList.add('active');
                    options[activeOptionIndex].focus();
                }
            }

            tuningSearch.addEventListener('input', function() {
                const filter = tuningSearch.value.toLowerCase();
                const filteredTunings = tunings.filter(tuning => tuning.toLowerCase().includes(filter));
                populateDropdown(filteredTunings);
                toggleDropdownVisibility(filteredTunings.length > 0);
            });

            tuningSearch.addEventListener('focus', function() {
                const filter = tuningSearch.value.toLowerCase();
                const filteredTunings = tunings.filter(tuning => tuning.toLowerCase().includes(filter));
                populateDropdown(filteredTunings);
                toggleDropdownVisibility(filteredTunings.length > 0);
            });

            tuningSearch.addEventListener('keydown', handleArrowKeys);

            addCustomBtn.addEventListener('click', function() {
                customModal.style.display = 'block';
                customModal.setAttribute('aria-hidden', 'false');
                closeBtn.focus();
            });

            closeBtn.addEventListener('click', function() {
                customModal.style.display = 'none';
                customModal.setAttribute('aria-hidden', 'true');
            });

            window.addEventListener('click', function(event) {
                if (event.target === customModal) {
                    customModal.style.display = 'none';
                    customModal.setAttribute('aria-hidden', 'true');
                }
            });

            window.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && customModal.style.display === 'block') {
                    customModal.style.display = 'none';
                    customModal.setAttribute('aria-hidden', 'true');
                }
            });

            customTuningForm.addEventListener('submit', function(event) {
                event.preventDefault();
                const customTuning = Array.from(new FormData(customTuningForm)).map(([key, value]) => value).join(' ');
                tunings.push(customTuning);
                customModal.style.display = 'none';
                customModal.setAttribute('aria-hidden', 'true');
                tuningSearch.value = customTuning;
                populateDropdown(tunings);
                feedbackMessage.style.display = 'block';
                setTimeout(() => {
                    feedbackMessage.style.display = 'none';
                }, 3000);
                customTuningForm.reset();
            });

            feedbackMessage.addEventListener('click', function() {
                feedbackMessage.style.display = 'none';
            });

            // Close dropdown when clicking outside
            window.addEventListener('click', function(event) {
                if (!event.target.matches('#tuning-search')) {
                    toggleDropdownVisibility(false);
                }
            });

            populateDropdown(tunings);
        });
    </script>
</body>
</html>


