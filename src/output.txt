Directory Structure:
audio/
chord-factory/
  chordfactory.js (Path: chord-factory\chordfactory.js, Size: 11864 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  chordvoicing.js (Path: chord-factory\chordvoicing.js, Size: 11247 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  constants.js (Path: chord-factory\constants.js, Size: 343 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  main.js (Path: chord-factory\main.js, Size: 1096 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  utils.js (Path: chord-factory\utils.js, Size: 754 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
chord-library/
  script.js (Path: chord-library\script.js, Size: 9395 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
createChatGPTContext.js (Path: createChatGPTContext.js, Size: 2867 bytes, Last Modified: Mon May 20 2024 01:01:16 GMT+0200 (Mitteleuropäische Sommerzeit))
drag-drop/
  script.js (Path: drag-drop\script.js, Size: 14001 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  styles.css (Path: drag-drop\styles.css, Size: 1343 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
index.html (Path: index.html, Size: 5806 bytes, Last Modified: Sun May 19 2024 23:30:40 GMT+0200 (Mitteleuropäische Sommerzeit))
index.js (Path: index.js, Size: 10016 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
input-styles.css (Path: input-styles.css, Size: 8963 bytes, Last Modified: Sun May 19 2024 23:30:53 GMT+0200 (Mitteleuropäische Sommerzeit))
midi-integration/
  index.html (Path: midi-integration\index.html, Size: 263 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  script.js (Path: midi-integration\script.js, Size: 2996 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
output-styles.css (Path: output-styles.css, Size: 2807 bytes, Last Modified: Sun May 19 2024 23:24:01 GMT+0200 (Mitteleuropäische Sommerzeit))
piano/
  script.js (Path: piano\script.js, Size: 9866 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  style.css (Path: piano\style.css, Size: 1122 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
progression-generator/
  main.js (Path: progression-generator\main.js, Size: 13948 bytes, Last Modified: Mon May 20 2024 00:49:04 GMT+0200 (Mitteleuropäische Sommerzeit))
  style.css (Path: progression-generator\style.css, Size: 952 bytes, Last Modified: Mon May 20 2024 00:19:56 GMT+0200 (Mitteleuropäische Sommerzeit))
slider-style.css (Path: slider-style.css, Size: 1167 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
svg/
tab-generator/
  index.html (Path: tab-generator\index.html, Size: 1524 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  script.js (Path: tab-generator\script.js, Size: 9496 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))
  styles.css (Path: tab-generator\styles.css, Size: 1094 bytes, Last Modified: Sun May 19 2024 20:16:23 GMT+0200 (Mitteleuropäische Sommerzeit))

File Contents:
File: chordfactory.js
Path: chord-factory\chordfactory.js

import { STANDARD_TUNING, NOTE_INDEX_MAP, TUNING, FINGER_FRET_RANGE, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordVoicing } from './chordvoicing.js';


export class ChordFactory {
  constructor(chord, startWithRoot = true, tuning = TUNING) {
    console.log("ChordFactory Recieved Notes: ", chord.notes)
    this.identifier = chord.name
    this.notes = chord.notes;
    this.startWithRoot = startWithRoot
    this.root = chord.rootNote
    this.tuning = tuning;
    this.fingerPositions = this.calculateFingerPositions();
    this.allChords = this.generateAllChordCombinations2()
    this.playableChords = this.filterPlayableChords(structuredClone(this.allChords))
    //this.getFretSpanStatistics()
    this.sortPlayableChordsByCombinedRating(1)
  }

  getFretSpanStatistics() {
    let spanCounts = {};  // Object to store the count of each span

    // Iterate over all chord combinations
    this.allChords.forEach(chord => {
      // Filter out muted and open strings, keeping only fretted notes
      const frets = chord.filter(fret => fret > 0);
      if (frets.length > 1) { // Ensure there's more than one fretted note to calculate a span
        const minFret = Math.min(...frets);
        const maxFret = Math.max(...frets);
        const span = maxFret - minFret;

        // Update the count for the calculated span
        if (span in spanCounts) {
          spanCounts[span] = spanCounts[span] + 1;
        } else {
          spanCounts[span] = 1;
        }
      }
    });

    // Log the statistics for review
    console.log("Fret Span Statistics:", spanCounts);
    return spanCounts;
  }


  calculateFingerPositions() {
    const fingerPositions = [];

    for (let stringIndex of this.tuning) {
      const positions = [];
      for (let chordIndex of this.notes) {
        const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12);
        positions.push(...validPositions);
      }
      positions.push(-1); // Add -1 once for each string index
      positions.sort((a, b) => a - b); // Sort the positions from lowest to highest
      fingerPositions.push(positions);
    }

    return fingerPositions;
  }

  getValidFretPositionsForNote(noteIndex, stringIndex) {
    const baseFret = (noteIndex - stringIndex + 120) % 12;
    return [baseFret, baseFret + 12];
  }

  cartesianProduct(arrays) {
    return arrays.reduce((acc, curr) => {
      return acc.flatMap(a => curr.map(b => [...a, b]));
    }, [[]]);
  }

  generateAllChordCombinations() {
    const chords = [];
    // All 12 Frets
    for (let startFret = 0; startFret <= 12; startFret++) {
      let positionsInRange = []
      let endFret = startFret + FINGER_FRET_RANGE - 1
      for (let string = 0; string < 6; string++) {
        let possibleStringPlacements = []
        //Push -1 to every String Because it could be muted
        possibleStringPlacements.push(-1)
        // As The First Index of The this.fingerPositions[string] String Array ALLWAYS is 1 -1, we can skip it and add it separately
        //THis is why we start a t 1
        for (let finger = 1; finger < this.fingerPositions[string].length; finger++) {
          // As the this.fingerPositions[string][finger] Array is sorted, we can break out, once we hit a higher position than endFret
          if (this.fingerPositions[string][finger] > endFret) {
            break;
          } else if (this.fingerPositions[string][finger] == endFret) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
            break;
          } else if (this.fingerPositions[string][finger] >= startFret) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
          } else if (this.fingerPositions[string][finger] == 0) {
            possibleStringPlacements.push(this.fingerPositions[string][finger])
          }
        }
        positionsInRange[string] = possibleStringPlacements
      }
      chords.push(...this.cartesianProduct(positionsInRange))

    }

    return chords;
  }


  generateAllChordCombinations2() {

    const startTime = performance.now();

    let chords = [];
    //console.log("Initial chords array:", chords);

    let maskScope = [];
    for (let i = 0; i < 6; i++) {
      maskScope[i] = [-1]; // Each sub-array is separately instantiated
    }
    //console.log("Initial maskScope array:", maskScope);

    const fingerIndexStorage = Array(6).fill(1);
    //console.log("Initial fingerIndexStorage array:", fingerIndexStorage);

    let fingerIndexLength = []
    this.fingerPositions.forEach((element, inndex) => {
      fingerIndexLength[inndex] = element.length - 1
    })

    //console.log("Finger index lengths for all strings:", fingerIndexLength);

    // As the first entry of the chords is allways -1 we can skip this
    for (let fret = 0; fret < 13; fret++) {
      //console.log("generateAllChordCombinations2 - FRET: ", fret)

      for (let string = 0; string < 6; string++) {

        for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) {
          // FIrst remove all Non Fitting Elements From Out current maskScope on All Strings.
          // Exclude The -1 (muted) and 0 (open string) Because they can be used everywhere
          if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) {
            maskScope[string].splice(validPosition, 1);
          }
        }
      }
      //for (let i = 0; i < 6; i++) {
      //console.log("generateAllChordCombinations2 - maskScope: ", i, maskScope[i])

      //}

      //Now We deleted all old ElementInternals, we can start inserting New elements one by one
      for (let string = 0; string < 6; string++) {
        //console.log("generateAllChordCombinations2 Fret, String", fret, string)

        // Add The New Element, if there is one 
        // First Check If there is a New Element inside the Array
        if (fingerIndexStorage[string] < fingerIndexLength[string]) {
          // CHeck if its in range for Valid CHord, if so add it 
          if (this.fingerPositions[string][fingerIndexStorage[string]] <= fret + FINGER_FRET_RANGE) {
            //console.log("generateAllChordCombinations2 Pushing into maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]] ", maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]])

            maskScope[string].push(this.fingerPositions[string][fingerIndexStorage[string]])

            for (let pos1 of maskScope[(string + 1) % 6]) {
              for (let pos2 of maskScope[(string + 2) % 6]) {
                for (let pos3 of maskScope[(string + 3) % 6]) {
                  for (let pos4 of maskScope[(string + 4) % 6]) {
                    for (let pos5 of maskScope[(string + 5) % 6]) {
                      let newVoicing = []
                      newVoicing[string] = this.fingerPositions[string][fingerIndexStorage[string]]
                      newVoicing[(string + 1) % 6] = pos1
                      newVoicing[(string + 2) % 6] = pos2
                      newVoicing[(string + 3) % 6] = pos3
                      newVoicing[(string + 4) % 6] = pos4
                      newVoicing[(string + 5) % 6] = pos5


                      //console.log("NEW: ", newVoicing)
                      chords.push(newVoicing);
                    }
                  }
                }
              }
            }
            //Flag the next index to be looked at later

            fingerIndexStorage[string]++

          } else {
            //Break because the element found is too big to be inserte into the maskScope
          }
        } else {
          //break because there are no more elments left in the Array
        }

        //Calculate the Cartesian Product From the Inserted element

        // Add each element to the chords
      }
    }
    // Track end time
    const endTime = performance.now();

    // Calculate the time taken
    const timeTaken = endTime - startTime;
    console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds");
    return chords;
  }


  filterPlayableChords(allChordsCopyCopy) {
    let allChordsCopy = [...allChordsCopyCopy]
    const playableChords = allChordsCopy.map(voicing => {
      if (this.startWithRoot) {
        for (let string = 0; string <= 5; string++) {
          if (voicing[string] == -1) {
            continue;
          }
          else if (((voicing[string] + this.tuning[string]) % 12) != this.root) {
            voicing[string] = -1;
          } else {
            break;
          }
        }
      }

      //Faster Way to Calculate the MinaboveZero
      let minAboveZero = Infinity;

      for (let i = 0; i < voicing.length; i++) {
        if (voicing[i] > 0 && voicing[i] < minAboveZero) {
          minAboveZero = voicing[i];
        }
      }

      if (minAboveZero === Infinity) {
        minAboveZero = 0;
      }


      let fingersUsed = 0;
      let barreStop = false;
      let barreUseFingers = 0;
      let barreAddFingers = 0;
      for (let i = 5; i >= 0; i--) {
        if (voicing[i] <= 0) {
          barreStop = true;
        }
        if (voicing[i] >= minAboveZero && barreStop == false) {
          barreUseFingers++;
          if (voicing[i] > minAboveZero) {
            barreAddFingers++;
          }
        } else if (voicing[i] > 0 && voicing[i] !== "x") {
          barreAddFingers++;
        }
      }
      if (barreUseFingers)
        if (barreUseFingers >= 2 && barreAddFingers > 3) {
          return null;
        } else if (barreUseFingers < 2) {
          fingersUsed = voicing.filter(fret => fret >= minAboveZero).length;
          barreUseFingers = 0
        }
      if (fingersUsed <= 4) {
        let newVoicing = new ChordVoicing(voicing, barreUseFingers > 0 ? minAboveZero : null, barreUseFingers > 0 ? barreAddFingers : fingersUsed, barreUseFingers, minAboveZero, this.notes, this.startWithRoot ? this.root : -1)

        return newVoicing;
      }
      return null;
    }
    ).filter(chordVoicing => chordVoicing !== null);
    return playableChords;
  }


  /**
   * Sorts the playable chords by a combined rating based on sound quality and 
   * playability. The combined rating is calculated using a weighted sum of 
   * the sound quality rating and the playability rating.
   * 
   * @param {number} soundWeight - A value between 0 and 1 that determines the weight 
   * given to the sound quality rating. The weight given to the playability rating 
   * will be (1 - soundWeight).
   * 
   * Usage example:
   * ```javascript
   * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning);
   * chordFactory.sortPlayableChordsByCombinedRating(0.7);
   * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating
   * ```
   * 
   * @throws {Error} If `soundWeight` is not a number between 0 and 1.
   */
  sortPlayableChordsByCombinedRating(soundWeight = 0) {
    if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) {
      throw new Error("soundWeight must be a number between 0 and 1.");
    }
    console.log("Sorting...")
    this.playableChords.sort((a, b) => {
      let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight));
      let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight));
      return bCombinedRating - aCombinedRating;
    });
  }
}


File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { STANDARD_TUNING, TUNING, FINGER_FRET_RANGE, NOTE_INDEX_MAP, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';

export class ChordVoicing {
  constructor(voicing, barre, fingersUsed, barreSize, minAboveZero, chordFactoryNotes, chordFactoryRoot) {
    this.voicing = voicing;
    this.barre = barre;

    this.fingersUsed = fingersUsed
    this.barreSize = barreSize
    this.minAboveZero = minAboveZero
    this.fingerPositions = [0, 0, 0, 0, 0, 0]
    this.chordSpacing = 0
    this.chordFactoryNotes = chordFactoryNotes
    this.chordFactoryRoot = chordFactoryRoot
    this.actuallyPlayedNotes = [0, 0, 0, 0, 0, 0]

    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] >= 0) {
        this.actuallyPlayedNotes[i] = (this.voicing[i] + TUNING[i])
      } else {
        this.actuallyPlayedNotes[i] = this.voicing[i]
      }
    }

    this.playabilityRating = 0;
    this.soundQualityRating = 0; // New property to store sound quality rating

    this.ratingDetails = {
      playability: {
        fingersUsed: 0,
        fingerSpread: 0,
        mutedAmount: 0,
        fretHeight: 0,
        total: 0,
      },
      soundQuality: {
        harmonicCompleteness: 0,
        openStrings: 0,
        playedStrings: 0,
        fretBoardHeight: 0,
        voicingRange: 0,
        doubleNotes: 0,
        total: 0,
      }
    };

    this.calculateChordSpacing()
    this.calculateFingerPosition()

    this.rateSoundQuality()
    this.ratePlayability()

    //Send From ChordFactory over

  }

  calculateChordSpacing() {
    if (this.fingerPositions.length !== 6 || this.voicing.length !== 6) {
      throw new Error('Input arrays must each have 6 elements.');
    }

    let notes = this.fingerPositions.map((finger, index) => ({
      string: index + 1,
      fret: this.voicing[index],
      finger
    })).filter(note => note.finger !== 0 && note.fret !== -1);

    // Additional condition for barre chords
    if (this.barre) {
      notes = notes.filter(note => note.finger !== 1);
    }

    notes.sort((a, b) => a.fret - b.fret || a.string - b.string);

    let totalSpacing = 0;
    for (let i = 0; i < notes.length - 1; i++) {
      const stringDistance = Math.abs(notes[i].string - notes[i + 1].string);
      const fretDistance = Math.abs(notes[i].fret - notes[i + 1].fret);
      totalSpacing += stringDistance + fretDistance;
    }

    this.chordSpacing = totalSpacing;
  }


  calculateFingerPosition() {
    let startPosition = this.minAboveZero
    let finger = 1

    //Make the start Position the BArre Position and If there is an Barre, Set all The according Things to Barre
    if (this.barre) {
      for (let i = this.barreSize; i > 0; i--) {
        if (this.voicing[6 - i] == this.barre) {
          this.fingerPositions[6 - i] = 1
        }

        finger = 2
      }
    }
    //Now go through each Fret, Start With the lowest fret above zero or with the barre fret.

    for (let fret = 0; fret < 4; fret++) {
      for (let string = 0; string < 6; string++) {
        if (startPosition + fret == this.voicing[string] && this.fingerPositions[string] !== 1 && this.voicing[string] !== 0) {
          this.fingerPositions[string] = finger
          finger++
        }
      }
    }

    return;
  }

  // 0 is Badly Playable and 1 Is good PLayability
  ratePlayability() {
    const details = this.ratingDetails.playability;
    details.fingersUsed = this.assessPlayabilityFingersUsed();
    details.fingerSpread = this.assessPlayabilityFingerSpread();
    details.mutedAmount = this.assessPlayabilityMuttedAmount();
    details.fretHeight = this.assessPlayabilityFretHeight();
    details.total = (details.fingersUsed + details.fingerSpread + details.mutedAmount + details.fretHeight) / 4;

    this.playabilityRating = details.total;
  }

  assessPlayabilityFingersUsed() {
    // USe FInger Positions because They are MOst realibale and ALgorithmically Safe Way (Becaus of possible future Changes) to asses Finger COunt
    let maxUsableFingers = 4
    let usedFingers = 0
    for (let i = 0; i < 6; i++) {
      if (this.fingerPositions[i] > usedFingers) {
        usedFingers = this.fingerPositions[i]
      }
    }
    // INvert Rating so Many fingers used gets a low score
    let rating = 1 - (usedFingers / maxUsableFingers)
    return rating
  }

  assessPlayabilityFingerSpread() {
    let maxFret = this.minAboveZero
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] > this.minAboveZero) {
        maxFret = this.voicing[i]
      }
    }
    return 1-((maxFret-this.minAboveZero) / FINGER_FRET_RANGE)
  }

  assessPlayabilityMuttedAmount(){
    let mutedCount = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] == -1) {
        mutedCount++
      }
    }
    return 1-(mutedCount/6)
  }

  assessPlayabilityFretHeight(){
    return 1-(this.minAboveZero/24)
  }







  //1 Best SOund, 0 worst sound
  rateSoundQuality() {
    const details = this.ratingDetails.soundQuality;
    details.harmonicCompleteness = this.assessSoundHarmonicCompleteness();
    details.openStrings = this.assessSoundOpenStrings();
    details.playedStrings = this.assessSoundPlayedStrings();
    details.fretBoardHeight = this.assessSoundFretBoardHeight();
    details.voicingRange = this.assessSoundVoicingRange();
    details.doubleNotes = this.assessSoundDoubleNotes();
    details.total = ((details.harmonicCompleteness + details.openStrings + details.playedStrings + details.fretBoardHeight + details.voicingRange + details.doubleNotes)/6);

    this.soundQualityRating = details.total;
  }

  assessSoundHarmonicCompleteness() {
    // Transform chordFactoryNotes to modulo 12 and store as a Set
    const uniqueDesiredNotes = new Set(this.chordFactoryNotes.map(note => note % 12));
  
    // Transform actuallyPlayedNotes to modulo 12 and store as a Set
    const playedNotesModuloSet = new Set(this.actuallyPlayedNotes.map(note => note % 12));
  
    // Calculate the number of overlapping notes using set intersection
    let overlapCount = 0;
    uniqueDesiredNotes.forEach(note => {
      if (playedNotesModuloSet.has(note)) {
        overlapCount++;
      }
    });
  
    // Calculate harmonic completeness score
    const completenessScore = overlapCount / uniqueDesiredNotes.size;
    return completenessScore;
  }

  assessSoundOpenStrings() {
    let openStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] === 0) {
        openStrings++;
      }
    }

    return openStrings / this.voicing.length;
  }

  assessSoundPlayedStrings() {
    let playedStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] >= 0) {
        playedStrings++;
      }
    }

    return playedStrings / this.voicing.length;
  }

  assessSoundFretBoardHeight() {
    return Math.max(0, (1 - (this.minAboveZero / 12)))
  }



  assessSoundVoicingRange() {
    let minIndex = -1
    let maxIndex = -1
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] != -1) {
        minIndex = i
        break;
      }
    }
    //Check if one thing is presen
    if (minIndex < 0) {
      return 0;
    }

    for (let i = 5; i >= 0; i--) {
      if (this.voicing[i] != -1) {
        maxIndex = i
        break;
      }
    }
    let spacing = this.actuallyPlayedNotes[maxIndex] - this.actuallyPlayedNotes[minIndex]
    let maxSpacing = TUNING[5] + this.minAboveZero + FINGER_FRET_RANGE - TUNING[0] + this.minAboveZero

    // The Higher the number, the better So The higher the Spacing archived, the better
    let spacingRatio = spacing / maxSpacing
    return spacingRatio
  }

  assessSoundDoubleNotes() {
    let doubleNotes = 0
    for (let i = 0; i < 5; i++) {
      if (this.actuallyPlayedNotes[i] == this.actuallyPlayedNotes[i + 1]) {
        doubleNotes++;
      }
    }
    return 1 - (doubleNotes / 5)
  }
}
/*
assessVoicingRange(){
  //TODO: Asses, The Difference Between the Lowest and the highest Played note. Find a Way to normalize the output between 0 (small difference) and 1
}


assessTonalBalance() {
  const noteFrequencies = this.voicing.map((fret, string) =>
    fret !== -1 ? (STANDARD_TUNING[string] + fret) % 12 : null
  ).filter(note => note !== null);

  const lowNotes = noteFrequencies.filter(note => note < 5).length;
  const midNotes = noteFrequencies.filter(note => note >= 5 && note < 9).length;
  const highNotes = noteFrequencies.filter(note => note >= 9).length;

  const balance = Math.min(lowNotes, midNotes, highNotes);
  return balance / 3 * 10;
}



assessVoicingRange() {
  const frets = this.voicing.filter(fret => fret !== -1);
  const range = Math.max(...frets) - Math.min(...frets);
  return range > 5 ? 0 : (5 - range) / 5 * 10;
}

assessDissonance() {
  const intervals = [];
  const frets = this.voicing.filter(fret => fret !== -1);

  for (let i = 0; i < frets.length; i++) {
    for (let j = i + 1; j < frets.length; j++) {
      const interval = Math.abs(frets[i] - frets[j]);
      intervals.push(interval);
    }
  }

  const dissonantIntervals = intervals.filter(interval => [1, 2, 6, 10].includes(interval));
  return 10 - dissonantIntervals.length * 2;
}

assessResonanceAndSustain() {
  const openStrings = this.voicing.filter(fret => fret === 0).length;
  return openStrings * 2;
}

assessChordClarity() {
  const clearNotes = this.voicing.filter(fret => fret !== -1 && fret !== 0);
  return clearNotes.length / 6 * 10;
}

assessContextualFit(contextChords) {
  const similarityScores = contextChords.map(contextChord => {
    let score = 0;
    for (let i = 0; i < 6; i++) {
      if (contextChord.voicing[i] === this.voicing[i]) {
        score++;
      }
    }
    return score;
  });

  const maxSimilarity = Math.max(...similarityScores);
  return maxSimilarity / 6 * 10;
}
}*/

/*
Start at Index Finger, represented by fingerPositions 1.
Count the String changes on the Same Fret with the middle finger so if the middle finger is 2 stings below, add 2 to the evalutaion 
if the middle finger is on the next fret over the minAboveZero, add 0, and only add 1 for each string it moved down or upward relative to the index finger
if the index finger is on the same fret as the middle finger, but the index finger is not also on the fret where the ring finger is, add the string count distance between the middle and ring finger 
if the index finger is on one fret more thatn the middle finger, but the middle and the index finger are on the fret below, add only the distance between the ring and the middle finger
if the index finger is on one fret, the middle finger is on +1 fret and the ring finger is on #1 fret, add 3 to the difficulty
if the small finger is on the same fret as the ring finger, but no other finger is on that fret, only add the string distance between the ring and the small finger.


*/

File: constants.js
Path: chord-factory\constants.js

// constants.js
export const STANDARD_TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
export const TUNING = [40, 45, 50, 55, 59, 64];
export const NOTE_INDEX_MAP = {
  'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4,
  'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9,
  'A#': 10, 'B': 11
};
export const BARRE_RATING = 1
export const FINGER_FRET_RANGE = 4

File: main.js
Path: chord-factory\main.js

import { STANDARD_TUNING,TUNING, NOTE_INDEX_MAP, BARRE_RATING } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';

let totalDuration = 0;
const repetitions = 50;
let lastPlayChords;

for (let i = 0; i < repetitions; i++) {
    const startTime = performance.now();
    
    const chord = new ChordFactory("E, G, B", 4, true, TUNING);
    const playableChords = chord.playableChords
    
    if (i === repetitions - 1) { // Only save the last result
        lastPlayChords = playableChords;
    }

    const endTime = performance.now();
    totalDuration += endTime - startTime; // Calculate the duration for this iteration
}

// Sort lastPlayChords by difficulty
if (lastPlayChords && lastPlayChords.length > 0) {
    lastPlayChords.sort((a, b) => a.rating - b.rating);
}

lastPlayChords.forEach((chord) => console.log(chord));

// Calculate the average time
const averageTime = totalDuration / repetitions;
console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);


File: utils.js
Path: chord-factory\utils.js

import { STANDARD_TUNING, NOTE_INDEX_MAP } from './constants.js';

export function parseNotes(input) {
  return input.toUpperCase()
    .replace(/B#/g, 'C').replace(/E#/g, 'F')
    .split(/[\s,]+/)
    .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note));
}

export function removeDuplicateArrays(arrays) {
  const uniqueArrays = new Set();
  return arrays.filter(array => {
    const serialized = JSON.stringify(array);
    if (!uniqueArrays.has(serialized)) {
      uniqueArrays.add(serialized);
      return true;
    }
    return
  });
}

export function numberToNote(number) {
  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  return number >= 0 ? notes[number % 12] : "Invalid number";
}


File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js";

export class Chord {
    constructor(rootNote, notes, name, customRoot) {
        this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = notes; // Array of integers representing notes of the chord
        this.name = name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = customRoot 
        console.log("Constructed Chord: " + this.name + " Root: " + this.rootNote + " Notes: " + this.notes)
    }
}

export class ChordLibrary {
    constructor() {
        this.chords = [];
        this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        this.chordStructures = {
            '': { notes: [0, 4, 7] }, // Major
            'm': { notes: [0, 3, 7] }, // Minor
            '7': { notes: [0, 4, 7, 10] }, // Dominant 7th
            'M7': { notes: [0, 4, 7, 11] }, // Major 7th
            'm7': { notes: [0, 3, 7, 10] }, // Minor 7th
            'mM7': { notes: [0, 3, 7, 11] }, // Minor Major 7th
            'sus2': { notes: [0, 2, 7] }, // Suspended 2nd
            'sus4': { notes: [0, 5, 7] }, // Suspended 4th
            'dim': { notes: [0, 3, 6] }, // Diminished
            'aug': { notes: [0, 4, 8] }, // Augmented
            '9': { notes: [0, 4, 7, 10, 14] }, // Dominant 9th
            'M9': { notes: [0, 4, 7, 11, 14] }, // Major 9th
            'm9': { notes: [0, 3, 7, 10, 14] }, // Minor 9th
            '11': { notes: [0, 4, 7, 10, 14, 17] }, // Dominant 11th
            '13': { notes: [0, 4, 7, 10, 14, 17, 21] }, // Dominant 13th
            'add9': { notes: [0, 2, 4, 7] }, // Added 9th
            'm6': { notes: [0, 3, 7, 9] }, // Minor 6th
            '6': { notes: [0, 4, 7, 9] }, // Major 6th
            '5': { notes: [0, 7] }, // Power chord
            '6/9': { notes: [0, 4, 7, 9, 14] }, // Major 6/9
            'm11': { notes: [0, 3, 7, 10, 14, 17] }, // Minor 11
            'M7#11': { notes: [0, 4, 7, 11, 18] }, // Major 7#11
            'm7b5': { notes: [0, 3, 6, 10] }, // Half-Diminished
            '+7': { notes: [0, 4, 8, 10] }, // Augmented 7th
            'dim7': { notes: [0, 3, 6, 9] }, // Diminished 7th
            'M7+5': { notes: [0, 4, 8, 11] }, // Augmented Major 7th
            'mM9': { notes: [0, 3, 7, 11, 14] }, // Minor Major 9th
            'dimM7': { notes: [0, 3, 6, 11] }, // Diminished Major 7th - check if real
            '7alt': { notes: [0, 4, 6, 10, 13] }, // Altered Dominant (using 6 and 13)
            'M13': { notes: [0, 4, 7, 11, 14, 17, 21] }, // Major 13th
            'M11': { notes: [0, 4, 7, 11, 14, 17] }, // Major 11th
            'M7sus4': { notes: [0, 5, 7, 11] }, // Major 7th Suspended 4th
            'm7#5': { notes: [0, 3, 8, 10] }, // Minor 7th #5
            'M#5': { notes: [0, 4, 8] }, // Major #5
            '9#11': { notes: [0, 4, 7, 10, 14, 18] }, // Dominant 9th #11
            '13#11': { notes: [0, 4, 7, 10, 14, 18, 21] }, // Dominant 13th #11
            '7b5': { notes: [0, 4, 6, 10] }, // Dominant 7th Flat Five
            'M7b5': { notes: [0, 4, 6, 11] }, // Major 7th Flat Five
            'M7#5': { notes: [0, 4, 8, 11] }, // Major 7th Sharp Five
            'm7b9': { notes: [0, 3, 7, 10, 13] }, // Minor 7th Flat Nine
            '9b5': { notes: [0, 4, 6, 10, 14] }, // 9th Flat Five
            '9#5': { notes: [0, 4, 8, 10, 14] }, // 9th Sharp Five
            '7b9': { notes: [0, 4, 7, 10, 13] }, // Dominant 7th Flat Nine
            '7#9': { notes: [0, 4, 7, 10, 15] }, // Dominant 7th Sharp Nine
            '7#11': { notes: [0, 4, 7, 10, 18] }, // Dominant 7th Sharp Eleven
            'm7add11': { notes: [0, 3, 7, 10, 17] }, // Minor 7th Add 11
            'add2': { notes: [0, 2, 4, 7] }, // Major Add 2
            'add4': { notes: [0, 4, 5, 7] }, // Major Add 4
            '6add9': { notes: [0, 4, 7, 9, 14] }, // Major 6 Add 9

            '/C': { notes: [0, 4, 7], root: 0 }, // C Major
            'm/C': { notes: [0, 3, 7], root: 0 }, // C Minor
            '/C#': { notes: [0, 4, 7], root: 1 }, // C# Major
            'm/C#': { notes: [0, 3, 7], root: 1 }, // C# Minor
            '/D': { notes: [0, 4, 7], root: 2 }, // D Major
            'm/D': { notes: [0, 3, 7], root: 2 }, // D Minor
            '/D#': { notes: [0, 4, 7], root: 3 }, // D# Major
            'm/D#': { notes: [0, 3, 7], root: 3 }, // D# Minor
            '/E': { notes: [0, 4, 7], root: 4 }, // E Major
            'm/E': { notes: [0, 3, 7], root: 4 }, // E Minor
            '/F': { notes: [0, 4, 7], root: 5 }, // F Major
            'm/F': { notes: [0, 3, 7], root: 5 }, // F Minor
            '/F#': { notes: [0, 4, 7], root: 6 }, // F# Major
            'm/F#': { notes: [0, 3, 7], root: 6 }, // F# Minor
            '/G': { notes: [0, 4, 7], root: 7 }, // G Major
            'm/G': { notes: [0, 3, 7], root: 7 }, // G Minor
            '/G#': { notes: [0, 4, 7], root: 8 }, // G# Major
            'm/G#': { notes: [0, 3, 7], root: 8 }, // G# Minor
            '/A': { notes: [0, 4, 7], root: 9 }, // A Major
            'm/A': { notes: [0, 3, 7], root: 9 }, // A Minor
            '/A#': { notes: [0, 4, 7], root: 10 }, // A# Major
            'm/A#': { notes: [0, 3, 7], root: 10 }, // A# Minor
            '/B': { notes: [0, 4, 7], root: 11 }, // B Major
            'm/B': { notes: [0, 3, 7], root: 11 } // B Minor

        };

        this.generateChords();
    }

    generateChords() {
        Object.entries(this.chordStructures).forEach(([suffix, structure]) => {
            for (let i = 0; i < 12; i++) {
                let rootNote = i
                let customRoot = false
                let notes = structure.notes.map(interval => (i + interval) % 12);
                const chordName = `${this.noteNames[i]}${suffix}`;
                if (structure.root !== undefined) {
                    //Filter Dumb Chord Like C/C D/D
                    if (structure.root == rootNote) {
                        continue
                    }
                    rootNote = structure.root
                    customRoot = true
                    notes.push(rootNote)
                }


                this.chords.push(new Chord(rootNote, notes, chordName, customRoot));
            }
        });
    }

    searchChords(noteArray, rootNote, threshold = 50) {
        console.log("Searching Chords...")
        const results = [];
        noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave
        if (rootNote) {
            rootNote = rootNote % 12

        }
        const inputNotesSet = new Set(noteArray);

        this.chords.forEach(chord => {
            let chordNotes = [...chord.notes];

            //console.log("Comparing to: " + chord.name)
            //Add the Root note to the Chords For Cases like A/D
            
            //console.log("Input Notes Set: ", inputNotesSet);

            const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note)));
            //console.log("Common Notes with Chord: ", commonNotes);

            const totalUniqueNotes = new Set([...chordNotes, ...noteArray]);
            //console.log("Total Unique Notes: ", totalUniqueNotes);


            let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100;
            //console.log("Searched Root: " + rootNote + " Presen Root: " + chord.rootNote);

            // Adjusting match percentage based on root note comparison
            if (rootNote !== null) {
                if (chord.rootNote == rootNote) {
                    //console.log("Matching Root for: " + chord.name + " Root: " + chord.rootNote + " Notes: " + chordNotes)
                    // If root notes match, this is fine as calculated
                } else {
                    // Penalize the match percentage slightly if root notes don't match
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized for not matching Root")
                }
            } else {
                //If a Custom Root in the CHord Details is specified but the user hasnt put a custom root
                if (chord.customRoot == true) {
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized For Havinng Specific when it shouldnt")

                }
            }



            if (matchPercentage >= threshold) {
                results.push(
                    new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2)))
                );
            }
        });

        // Sort results by probability in descending order
        return results.sort((a, b) => b.probability - a.probability);
    }

    getAllChords() {
        // Return all chord names in a simplified object format
        return this.chords;
    }

    getChordByName(name) {
        const chord = this.chords.find(chord => chord.name === name);
        if (chord) {
            //console.log('Chord found:', chord);
            return chord;
        } else {
            //console.log('No chord found with the name:', name);
            return null;
        }
    }
}



File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs');
const path = require('path');

function isHtmlOrJsFile(file) {
  return file.endsWith('.html') || file.endsWith('.js') || file.endsWith('.css')  ;
}

function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') {
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      fileStructure[item] = {};
      getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      fileStructure[item] = {
        path: fullPath,
        relativePath: path.join(parentPath, item),
        size: stats.size,
        lastModified: stats.mtime
      };
    }
  });
  return fileStructure;
}

function readAllFiles(dir, parentPath = '') {
  let allText = '';
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      allText += readAllFiles(fullPath, path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      allText += `File: ${item}\n`;
      allText += `Path: ${path.join(parentPath, item)}\n\n`;
      allText += fs.readFileSync(fullPath, 'utf8') + '\n\n';
    }
  });
  return allText;
}

function formatStructure(fileStructure, indent = 0) {
  let structureText = '';
  const indentString = ' '.repeat(indent);
  for (const key in fileStructure) {
    if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) {
      const { relativePath, size, lastModified } = fileStructure[key];
      structureText += `${indentString}${key} (Path: ${relativePath}, Size: ${size} bytes, Last Modified: ${lastModified})\n`;
    } else {
      structureText += `${indentString}${key}/\n`;
      structureText += formatStructure(fileStructure[key], indent + 2);
    }
  }
  return structureText;
}

try {
  const targetDir = path.join(__dirname, ''); // Change '' to your target folder
  const outputFilePath = path.join(__dirname, 'output.txt');

  // Get the folder and file structure
  const fileStructure = getDirectoryStructure(targetDir);

  // Format the structure to a string
  const structureText = formatStructure(fileStructure);

  // Read all the text from HTML and JS files
  const filesText = readAllFiles(targetDir);

  // Combine structure and file texts
  const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`;

  // Write the final output to a file
  fs.writeFileSync(outputFilePath, finalOutput);

  console.log('Folder structure and file contents have been saved to output.txt');
} catch (error) {
  console.error('Error reading directory:', error.message);
}


File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js";

export class DragAndDropItem extends Chord {
    constructor(chord, probability = -1) {
        super(chord)
        this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = chord.notes; // Array of integers representing notes of the chord
        this.name = chord.name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = chord.customRoot
        this.probability = probability
    }
}

export default class DragAndDropList {
    constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) {
        this.items = []
        this.idCounter = 0;
        items.forEach(item => {
            this.items.push(new DragAndDropItem(item))
        })

        this.dropzoneId = dropzoneId;

        this.selectedItemsEvent = new CustomEvent('selectedItemsUpdated', { bubbles: true, detail: { selectedItems: [] } });

        this.emptyMessageContainer = document.getElementById(emptyMessage);
        this.itemsContainer = document.getElementById(itemsContainer);
        this.selectedItemsContainer = document.getElementById(selectedItems);
        this.itemFilterInput = document.getElementById(itemSearch);
        this.selectedItemsArray = [];

        this.addEventListeners();
        this.populateItemsList();

        this.emptyMessage = "Click on chords to add";
        this.emptyMessageElement = document.createElement('div');
        this.emptyMessageElement.id = "DragAndDrop-EmptyMessage";

        const words = this.emptyMessage.split(' ');

        const baseElement = this.createItemElement({ name: "Sample Word" });
        baseElement.draggable = false;
        baseElement.isSelectable = false;

        words.forEach(word => {
            const clone = baseElement.cloneNode(true);
            clone.innerHTML = word;
            this.emptyMessageElement.appendChild(clone);
        });

        this.selectedItemsContainer.appendChild(this.emptyMessageElement);
    }

    addEventListeners() {
        window.addEventListener('dragover', this.handleWindowDragOver.bind(this));
        window.addEventListener('drop', this.handleWindowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('dragover', this.allowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('drop', this.handleDropOnContainer.bind(this));
        this.itemFilterInput.addEventListener('input', this.filterItems.bind(this));
    }

    handleWindowDragOver(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    handleWindowDrop(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    last100PercentItemIndex() {
        let lastIndex = -1;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].probability === 100) {
                lastIndex = i;
            }
        }
        return lastIndex;
    }

    populateItemsList() {
        const lastIndex100Percent = this.last100PercentItemIndex();
        let first100Percent = false;
        this.items.forEach((item, index) => {
            if (item.probability === 100 && !first100Percent) {
                first100Percent = true;
                const firstElement = document.createElement('div');
                firstElement.style.width = "100%";
                firstElement.innerHTML = "BEST MATCHES FOUND:";
                firstElement.style.backgroundColor = "#ffffff00";
                firstElement.style.color = "var(--light3)";
                firstElement.style.fontSize = "small";
                firstElement.style.marginBottom = "var(--padding)";

                this.itemsContainer.appendChild(firstElement);
            }
            const itemElement = this.createItemElement(item, true);
            this.itemsContainer.appendChild(itemElement);

            if (index === lastIndex100Percent) {
                const breakElement = document.createElement('div');
                breakElement.style.width = "100%";
                breakElement.style.height = "2px";
                breakElement.style.backgroundColor = "var(--dark1)";
                breakElement.style.marginTop = "var(--padding)";
                breakElement.style.marginBottom = "var(--padding)";
                breakElement.style.boxShadow = "var(--padding) 0px 0px 0px var(--dark1), calc(var(--padding)*-1) 0px 0px 0px var(--dark1)";

                this.itemsContainer.appendChild(breakElement);
            }
        });
    }

    createItemElement(item, isSelectable = false) {
        const itemElement = document.createElement('div');
        itemElement.textContent = item.name;

        itemElement.className = 'dragDropItem';
        itemElement.id = `dragDropItem-${this.idCounter++}`;

        if (item.probability > 0) {
            const probabilitySpan = document.createElement('span');
            probabilitySpan.textContent = `(${item.probability}%)`;
            probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability);
            if (item.probability === 100) {
                itemElement.style.boxShadow = '0px 0px 13px 0px rgba(0,255,0)';
                itemElement.style.fontWeight = "800";
            }

            itemElement.appendChild(probabilitySpan);
        }

        if (isSelectable) {
            itemElement.addEventListener('click', () => this.addSelectedItem(item));
        }
        return itemElement;
    }

    getBackgroundColor(probability) {
        const startColor = [255, 130, 130];
        const endColor = [230, 230, 30];
        const winnerColor = [150, 200, 0];

        probability = Math.max(50, Math.min(100, probability));

        const scaledProbability = (probability - 50) / 50;

        const adjustedProbability = Math.log10(1 + 9 * scaledProbability);

        let blendedColor = startColor.map((component, index) => {
            return Math.round(component + (endColor[index] - component) * adjustedProbability);
        });
        if (probability === 100) {
            blendedColor = winnerColor;
        }
        return `rgb(${blendedColor.join(',')})`;
    }

    createSelectedItemElement(item) {
        const selectedItemElement = document.createElement('div');
        selectedItemElement.className = 'selected-dragDropItem dragDropItem';
        selectedItemElement.draggable = true;
        selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`;
        selectedItemElement.textContent = item.name;
        selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this));
        selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this));
        selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this));
        selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this));
        selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this));
        return selectedItemElement;
    }

    removeSelectedItem(event) {
        event.target.remove();
        this.updateArrayFromList();
    }

    addSelectedItem(item) {

        this.selectedItemsArray.push(item);
        this.updateDisplayArray();
    }

    updateItems(newItems) {
        console.log("Updating Library...");
        this.clearList();
        this.items = newItems;
        this.populateItemsList();
    }

    clearList() {
        this.items = [];
        while (this.itemsContainer.firstChild) {
            this.itemsContainer.removeChild(this.itemsContainer.firstChild);
        }
    }

    clearSelectedList() {
        this.selectedItemsArray = [];
        while (this.selectedItemsContainer.firstChild) {
            this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild);
        }
        this.updateDisplayArray();
    }

    handleDropOnItemList(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) {
            droppedItemElement.remove();
            this.updateDisplayArray();
        }
    }

    handleDragStart(event) {
        event.dataTransfer.setData('text/plain', event.target.id);

        if (event.target.classList.contains('selected-dragDropItem')) {
            event.target.classList.add('dragging');
        }
    }

    handleDragOver(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.add('over');
        }
    }

    handleDragLeave(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.remove('over');
        }
    }

    handleDropReorder(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);
        if (!droppedItemElement) return;

        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            if (droppedItemElement.classList.contains('selected-dragDropItem')) {
                this.insertAtCorrectPosition(droppedItemElement, targetElement);
            }
        } else {
            if (!droppedItemElement.classList.contains('selected-dragDropItem')) {
                const chordName = droppedItemElement.textContent.split(' (')[0];
                const chord = this.items.find(item => item.name === chordName);

                if (chord) {
                    const newClone = this.createSelectedItemElement(chord);
                    this.selectedItemsContainer.appendChild(newClone);
                    this.selectedItemsArray.push(chord);
                }
            } else {
                this.selectedItemsContainer.appendChild(droppedItemElement);
                this.updateDisplayArray();
            }
        }
        this.updateDisplayArray();
    }


    handleDragEnd(event) {
        event.target.classList.remove('dragging');
        const overItems = document.querySelectorAll('.selected-dragDropItem');
        overItems.forEach(item => item.classList.remove('over'));
    }

    allowDrop(event) {
        event.preventDefault();
    }

    handleDropOnContainer(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) {
            const chordName = droppedItemElement.textContent.split(' (')[0];
            const chord = this.items.find(item => item.name === chordName);

            if (chord) {
                const newClone = this.createSelectedItemElement(chord);
                this.selectedItemsContainer.appendChild(newClone);
                this.selectedItemsArray.push(chord);
                this.updateDisplayArray();
            }
        }
    }
    insertAtCorrectPosition(droppedItemElement, targetElement) {
        const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement);
        const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement);

        if (droppedIndex < targetIndex) {
            targetElement.after(droppedItemElement);
        } else {
            targetElement.before(droppedItemElement);
        }
        targetElement.classList.remove('over');
        this.updateArrayFromList();
    }

    updateArrayFromList(){
        this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => {
            const chordName = el.textContent.split(' (')[0];
            return this.items.find(item => item.name === chordName);
        });
        this.updateDisplayArray();

    }

    updateDisplayArray() {

        this.selectedItemsContainer.innerHTML = ""

        if (this.selectedItemsArray.length == 0) {
            if (!this.emptyMessageElement.parentNode) {
                this.selectedItemsContainer.appendChild(this.emptyMessageElement);
            }
        } else {
            this.emptyMessageElement.remove();
        }

        this.selectedItemsArray.forEach(item => {
            const selectedItemElement = this.createSelectedItemElement(item);
            this.selectedItemsContainer.appendChild(selectedItemElement);
        })


        this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray];
        document.dispatchEvent(this.selectedItemsEvent);
        console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`);


    }

    filterItems() {
        const filterValue = this.itemFilterInput.value.toUpperCase();
        const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem');
        itemElements.forEach(itemElement => {
            const itemText = itemElement.textContent.toUpperCase();
            itemElement.style.display = itemText.includes(filterValue) ? '' : 'none';
        });
    }

    getArray() {
        return [...this.selectedItemsArray];
    }
}

File: styles.css
Path: drag-drop\styles.css

/* General body styles */
body {
    font-family: 'Arial', sans-serif;
    background-color: #f4f4f4;
    margin: 0;
    padding: 20px;
    color: #333;
}

/* Styling for the container */
.container {
    max-width: 600px;
    margin: auto;
    background: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    padding: 20px;
    border-radius: 8px;
}

/* Search box styling */
.search-box input[type="text"] {
    width: 100%;
    padding: 10px;
    border: 2px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
    margin-bottom: 20px;
}

/* Item list styling */
.items, .selected-items {
    border: 1px solid #ddd;
    padding: 10px;
    min-height: 50px;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #fafafa;
}

.item, .selected-item {
    padding: 8px 16px;
    margin: 5px;
    display: inline-block;
    background-color: #eee;
    border-radius: 4px;
    cursor: pointer;
    border: 2px solid #00000000;

}

.item:hover, .selected-item:hover {
    background-color: #ddd;
}

/* Dragging and dropping styles */
.dragging {
    opacity: 0.5;
}

.over {
    border: 2px dashed #00000043;
}

/* Display array box */
#displayArray {
    padding: 10px;
    background-color: #ddd;
    border-radius: 4px;
    margin-top: 20px;
}


File: index.html
Path: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="piano/style.css" />
    <link rel="stylesheet" href="progression-generator/style.css" />
    <link rel="stylesheet" href="./output-styles.css" />
    <link rel="stylesheet" href="./input-styles.css" />
    <link rel="stylesheet" href="./slider-style.css" />



    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div id="settings">
            Settings
        </div>
        <div class="header">
            PianoToGuitar.com
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="visualPianoContainer">
                <div class="pianoMIDIWrapper">

                    <div class="pianoContainer"></div>
                    <div id="MIDIStatusDiv">
                        Initializing MIDI... </div>
                </div>
                <div class="pianoIconContainer">
                    <svg class="visualPianoIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg"
                        onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24">
                        <path
                            d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path
                            d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
            <div class="searchWordContainer">
                <div class="blackFadeBottom"></div>
                <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                <div class="searchChordList" id="itemsContainer">
                    <!-- Items will be populated here by JavaScript -->
                </div>
            </div>
        </div>
        <div class="selectedItemsHeading">
            <div>Your Selected Progression</div>
            <div id="scaleDisplay"></div>
        </div>
        <div class="selectedItemsWrapper">
            <div class="selectedItems" id="selectedItems">
                <!-- Dragged items will appear here -->
            </div>

            <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24"
                viewBox="0 -960 960 960" width="24">
                <path fill="currentColor"
                    d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
            </svg>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>

            </div>
        </div>
</body>

</html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js';
import Piano from './piano/script.js';
import { Chord, ChordLibrary } from "./chord-library/script.js"
import MIDIAccessManager from "./midi-integration/script.js"
import { ProgressionGenerator } from './progression-generator/main.js';
import { TUNING } from './chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {
    function debounce(func, wait) {
        let timeout;
        return function () {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }


    //Make Settings Button functional
    window.toggleSettings = function () {
        let settingsScreen = document.getElementById("settings");
        // Toggle a class that controls the visibility and opacity
        settingsScreen.classList.toggle('visible');
    }



    // Import the MidiManager
    const midiManager = new MIDIAccessManager();

    var visualPianoOctaves = 3


    // Function to calculate the number of octaves based on screen width
    function calculateOctaves() {
        const screenWidth = window.innerWidth;
        console.log((Math.sqrt(screenWidth)))
        const maxOctaves = 3; // Base octaves to start with
        const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25);
        visualPianoOctaves = Math.min(maxOctaves, extraOctaves)
        return visualPianoOctaves;
    }



    // Create a new Piano instance with dynamic number of octaves
    const myPiano = new Piano('.pianoContainer', { octaves: calculateOctaves() });


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);


    var isVolumeOn = localStorage.getItem('volumeState') === 'off' ? false : true;
    const volumeIcon = document.getElementById('volumeIcon');

    updateVolumeIcon(); // Update the icon at load

    window.toggleVolume = function () {

        if (isVolumeOn) {
            myPiano.volumeOff(); // Turn volume off
            isVolumeOn = false;
            localStorage.setItem('volumeState', 'off');
        } else {
            myPiano.volumeOn(); // Turn volume on
            isVolumeOn = true;
            localStorage.setItem('volumeState', 'on');
        }
        updateVolumeIcon();
    };

    function updateVolumeIcon() {
        if (!isVolumeOn) {
            volumeIcon.innerHTML = `<path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"/>`;
        } else {
            volumeIcon.innerHTML = `<path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"/>`;
        }
    }

    window.playPiano = function () {
        myPiano.playChord();
        console.log("Piano played");
    };


    window.clearPiano = function () {
        document.getElementById("itemSearch").value = ""
        myPiano.clearPiano();
        console.log("Piano cleared");
    };

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };

    // Handle window resize to adjust the number of octaves dynamically
    window.onresize = function () {
        const newOctaves = calculateOctaves();
        myPiano.setOctaves(newOctaves); // Assuming there's a method to update the octaves dynamically
    };




    document.querySelector('.pianoContainer').addEventListener('notesChanged', (e) => {
        console.log('Piano notes changed:', e.detail.notes, e.detail.rootNote);
        let items
        if (e.detail.notes.length > 0) {
            console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote)
            items = chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50)
        } else {
            items = allChordLibraryItems
        }
        //dragAndDropList.ceateAndInsertElement(e.detail.notes)
        dragAndDropList.updateItems(items)
        // Additional logic to handle the change in notes
    });


    //Midi Integration for Pinao Notes 
    let actualPressedKeys = new Map(); // Maps actual notes to their counts
    let visualPressedKeys = new Set();

    function mapNoteToVisualKey(note) {
        return note % (visualPianoOctaves * 12);
    }

    window.addEventListener('noteOn', (e) => {
        const { note } = e.detail;
        const visualKey = mapNoteToVisualKey(note);
        let count = actualPressedKeys.get(note) || 0;
        actualPressedKeys.set(note, count + 1);
        visualPressedKeys.add(visualKey);
        myPiano.activateKey(visualKey);
        updateRootNote();
    });

    window.addEventListener('noteOff', (e) => {
        const { note } = e.detail;
        if (actualPressedKeys.has(note)) {
            let count = actualPressedKeys.get(note);
            if (count > 1) {
                actualPressedKeys.set(note, count - 1);
            } else {
                actualPressedKeys.delete(note);
                // Check if any other actual key maps to the same visual key
                const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note));
                if (!anyOther) {
                    visualPressedKeys.delete(mapNoteToVisualKey(note));
                    myPiano.deactivateKey(mapNoteToVisualKey(note));
                }
            }
        }
        updateRootNote();
    });

    function updateRootNote() {
        if (actualPressedKeys.size > 0) {
            // Convert actualPressedKeys to an array and sort it
            const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b);

            // Determine if the lowest note should be set as the root note
            const lowestNote = sortedNotes[0];
            const lowestNoteMod12 = lowestNote % 12;
            let setRoot = false;

            // Check if the lowest note is doubled in higher octaves
            if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) {
                setRoot = true;
            }

            // Check if the lowest note is 12 interval steps away from the second lowest note
            if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6)) {
                setRoot = true;
            }

            // Set or clear the root note based on the above conditions
            if (setRoot) {
                const visualKey = mapNoteToVisualKey(lowestNote);
                myPiano.setRootNote(visualKey);
            } else {
                myPiano.clearRootNote();
            }
        } else {
            myPiano.clearRootNote();
        }
    }


    window.addEventListener("statusUpdated", (e) => {
        document.getElementById("MIDIStatusDiv").innerHTML = e.detail

    })


    //Functionality to autom,atically add Chord when played by midi:
    window.addEventListener('notesOutput', (e) => {
        const notes = e.detail;
        if (notes.length > 0) {
            const rootNote = Math.min(...notes);
            const searchResults = chordLibrary.searchChords(notes, rootNote, 100);
            if (searchResults.length > 0) {
                const chord = searchResults[0];
                dragAndDropList.addSelectedItem(chord);
                //popUp.open("Added: " +chord.name, { autoClose: true, duration: 1000 });
            }
        }
    });



    //Scale Detector Listener
    const scaleDisplay = document.getElementById("scaleDisplay")
    window.addEventListener('scaleDetected', function (event) {
        scaleDisplay.innerHTML = event.detail.scale
    });





    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, TUNING, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems);
        progressionGenerator.setProgression(event.detail.selectedItems)
        updateProgressionDynamic(soundQualityValue)
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);
        updateProgressionDynamic(soundQualityValue)
    });

    function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = progressionGenerator.getProgressionDynamicHTML(soundQualityValue);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };


    //Update the Progressions to get the PLaceholders:
    updateProgressionDynamic(soundQualityValue)
})


File: input-styles.css
Path: input-styles.css

:root {
    --light0: rgb(240, 240, 240);
    --light1: rgb(220, 220, 220);
    --light2: rgb(208, 208, 208);
    --light3: rgb(143, 142, 142);
    --dark1: rgb(50, 57, 57);
    --dark2: rgb(35, 42, 42);
    --dark3: rgb(10, 20, 20);
    --accent1: rgb(255, 136, 0);
    --padding: 10px;
    --rounding: 7px;
}



/* width */
::-webkit-scrollbar {
    width: 5px;
}

/* Track */
::-webkit-scrollbar-track {
    background: var(--dark3);
}

/* Handle */
::-webkit-scrollbar-thumb {
    background: var(--dark1);
    border-radius: var(--rounding);
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
    background: var(--light3);
}

svg path {
    fill: var(--light1)
}

html {
    background-color: var(--dark3);
    color: #fff;
    font-size: larger;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    font-family: "Manrope", sans-serif;
    background: radial-gradient(circle, rgba(7, 24, 27, 1) 0%, rgba(9, 9, 9, 1) 100%);
    background-color: #171f1f;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='70' height='46' viewBox='0 0 70 46'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.09'%3E%3Cpolygon points='68 44 62 44 62 46 56 46 56 44 52 44 52 46 46 46 46 44 40 44 40 46 38 46 38 44 32 44 32 46 26 46 26 44 22 44 22 46 16 46 16 44 12 44 12 46 6 46 6 44 0 44 0 42 8 42 8 28 6 28 6 0 12 0 12 28 10 28 10 42 18 42 18 28 16 28 16 0 22 0 22 28 20 28 20 42 28 42 28 28 26 28 26 0 32 0 32 28 30 28 30 42 38 42 38 0 40 0 40 42 48 42 48 28 46 28 46 0 52 0 52 28 50 28 50 42 58 42 58 28 56 28 56 0 62 0 62 28 60 28 60 42 68 42 68 0 70 0 70 46 68 46'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: end;
    font-size: max(1.6vw, 3vh);
    font-weight: 100;
}

body {
    margin: 0;
    box-shadow: 0 0 10vw rgba(6, 6, 6, 0.552);
    box-sizing: border-box;
    width: 80vw;
    height: 90vh;
    display: flex;
    flex-direction: column;
}

#settings {
    height: calc(100% - var(--padding) * 2);
    position: absolute;
    z-index: 5;
    width: calc(100% - var(--padding) * 2);
    box-sizing: border-box;
    box-shadow: 0px 0px 50px max(100vh, 100vw) #0000006a;
    border-radius: var(--rounding);
    padding: var(--padding);
    background-color: #00000077;
    backdrop-filter: blur(15px);
    display: flex;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
}

#settings.visible {
    opacity: 1;
    visibility: visible;
}


#settingsIcon {
    z-index: 10;
}

.inputWrapper {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex: 1.3;
    background-color: var(--dark1);
    gap: var(--padding);
    padding: var(--padding);
    box-sizing: border-box;
    position: relative;
    flex-basis: 0px;
    box-shadow: 0 0 min(5vw, 5vh) rgba(0, 0, 0, 0.212);
    background-color: #323939;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%23575757' fill-opacity='0.4' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
    border-top-left-radius: var(--rounding);
    border-top-right-radius: var(--rounding);

}


.searchContainer {
    display: flex;
    flex-direction: row;
    gap: var(--padding);
    flex: 1
}



.visualPianoContainer {
    flex: 1.5;
    display: flex;
    flex-direction: row;
    align-items: end;
    padding: calc(var(--padding)/2);
    background-color: var(--dark2);
    border-radius: var(--rounding);
    gap: calc(var(--padding)/2);
    flex-basis: 10px;
    box-shadow: inset 0 0 1vw rgba(0, 0, 0, 0.197);

}

.visualPianoIcon {
    width: max(3vh, 1.5vw);
    height: auto;
    transition: 0.2s;
}

.visualPianoIcon:hover {
    cursor: pointer;
    transform: scale(1.05);
}

.visualPianoIcon:active {
    cursor: pointer;
    transform: scale(0.8);
}

.pianoContainer {
    position: relative;
    display: flex;
    width: 100%;
    height: 100%;
    box-shadow: 0 0 1vw rgba(7, 0, 53, 0.25);
    border: none;
    flex: 1;
    border-radius: var(--rounding);

}

.pianoIconContainer {
    display: flex;
    flex-direction: column;
    gap: var(--padding);
    padding: calc(var(--padding)/2);
    max-height: 100%;
}

.pianoMIDIWrapper {
    display: flex;
    width: 100%;
    height: 100%;
    border: none;
    flex-direction: column;
    gap: calc(var(--padding)/2)
}

#MIDIStatusDiv {
    color: var(--light3);
}

.searchWordContainer {
    flex: 1;
    display: flex;
    position: relative;
    flex-direction: column;
    background-color: var(--dark2);
    border-radius: var(--rounding);
    overflow: hidden;
    flex-basis: 10px;
    /* Hides content that overflows the element's box */


}

.blackFadeBottom {
    width: 100%;
    position: absolute;
    border-radius: var(--rounding);
    background: linear-gradient(0deg, rgb(31, 31, 31) 0%, rgba(63, 63, 63, 0) 10%, rgba(0, 0, 0, 0) 100%);
    z-index: 3;
    pointer-events: none;
    height: 100%;
}

.searchBox {
    width: 100%;
    height: auto;
    background-color: var(--dark2);
    box-sizing: border-box;
    border: none;
    border-bottom: 2px solid var(--dark1);
    /* Same bottom border on focus */
    padding: var(--padding);
    /* Padding around text */
    border-radius: var(--rounding) var(--rounding) 0 0;
    color: var(--light1);
}



.searchBox:focus {
    outline: none;
}

.searchChordList {
    display: flex;
    flex-direction: row;
    align-content: flex-start;
    height: 100%;
    gap: var(--padding);
    flex-wrap: wrap;
    box-sizing: border-box;
    padding: var(--padding);
    overflow-y: auto;
    user-select: none;
    flex: 1 1 10px;

}

.selectedItemsHeading {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
}

#scaleDisplay {
    color: var(--light1);
    font-weight: 100;
    padding-top: calc(var(--padding)/2);
    padding-left: var(--padding);
    padding-right: var(--padding);
    border-top-left-radius: var(--rounding);
    border-top-right-radius: var(--rounding);

    background-color: var(--dark2);
    box-shadow: 0 var(--padding) 0 var(--dark2);
    filter: contrast(1.05);
}

.selectedItemsWrapper {
    display: flex;
    flex-direction: row;
    background-color: var(--dark2);
    padding: var(--padding);
    gap: var(--padding);
    border-radius: var(--rounding);
    overflow-y: auto;
    max-height: 15%;
    box-shadow: inset 0 0 1vw rgba(0, 0, 0, 0.197);
    border-top-right-radius: 0;
}

.selectedItems {
    width: 100%;
    height: auto;
    display: flex;
    flex-direction: row;
    align-content: flex-start;
    justify-content: center;
    gap: var(--padding);
    flex-wrap: wrap;
    box-sizing: border-box;
    transition: 1s;
    user-select: none;
    overflow-y: auto;
    border-radius: var(--rounding);
}



.dragDropItem {
    background-color: var(--light0);
    padding: calc(var(--padding) / 2) var(--padding);
    border-radius: var(--rounding);
    font-weight: 800;
    box-sizing: border-box;
    color: var(--dark2);
    position: relative;
    cursor: pointer;
    transition: 0.15s;
    box-shadow: 0 0 10px #00000056, inset 0 0 3px #ffffff6e;
}

.dragDropItem:hover {
    transform: scale(1.05) rotate(-0.001turn);
    filter: contrast(1.1);
    z-index: 10;
}

.dragDropItem:active {
    transform: scale(0.5) translate(-50);
}

.dragDropItem span {
    position: relative;
    background-color: var(--light2);
    color: var(--dark1);
    border-radius: 0 var(--rounding) var(--rounding) 0;
    margin-left: var(--padding);
    padding: calc(var(--padding) / 2) var(--padding);
    z-index: 2;
    top: 0%;
    left: var(--padding);
    height: 100%;
    box-shadow: 0 0 10px rgb(6, 6, 6);

}

.dragDropItem.dragging {
    transform: scale(1.05);
    transition: 0.2s;
    opacity: 0.5;
    cursor: grabbing;
}

.dragDropItem.over {
    transform: scale(0.95);
    transition: 0.2s;
    opacity: 0.5;
}

.selected-dragDropItem {
    box-shadow: 0 0 10px #00000096;
    /* Add a glowing effect */
    cursor: grab;
}

#DragAndDrop-EmptyMessage {
    opacity: 0.2;
    display: flex;
    gap: var(--padding);
}




@media only screen and (max-width: 1200px) {
    .searchContainer {
        flex-direction: column;
    }

    .visualPianoContainer {
        flex: 1;
        flex-basis: 10px;
    }

    html {
        font-size: small;
    }

    body {
        width: 100vw;
    }

    :root {
        --padding: 10px;
    }

    body {
        height: 100dvh;
    }
}

File: index.html
Path: midi-integration\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Note Logger</title>
</head>
<body>
<h1>MIDI Note Logger</h1>
<div id="status">Waiting for MIDI...</div>
<div id="log"></div>
<script src="script.js"></script>
</body>
</html>


File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 5;
        this.notesPlayed = new Set();
        this.activeNotes = new Set();

        if (navigator.requestMIDIAccess) {
            this.attemptMIDIAccess();
        } else {
            console.log("Web MIDI API not supported!");
        }
    }

    attemptMIDIAccess() {
        navigator.requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))
            .catch(err => {
                console.error('Error accessing MIDI devices:', err);
                this.handleRetry(err);
            });
    }

    onMIDISuccess(midiAccess) {
        this.updateStatus("MIDI ready!");
        midiAccess.onstatechange = this.updateDeviceState.bind(this);
        Array.from(midiAccess.inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this));
    }

    onMIDIFailure() {
        this.updateStatus("No MIDI Devices found...");
        this.handleRetry(new Error("Initial connection failed"));
    }

    handleRetry(err) {
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            console.log(`Retrying... Attempt ${this.retryCount}`);
            setTimeout(() => this.attemptMIDIAccess(), 1000); // Retry after 1 second
        } else {
            console.error(`Failed to connect after ${this.maxRetries} attempts: ${err.message}`);
            this.updateStatus(`No MIDI Devices found.`);
        }
    }

    onMIDIMessage({ data: [command, note, velocity] }) {
        const eventDetail = { command, note, velocity };
        if (command === 144 && velocity > 0) {
            if (this.activeNotes.size === 0) { // New session
                this.notesPlayed.clear();
            }
            this.notesPlayed.add(note);
            this.activeNotes.add(note);
            window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail }));
        } else if (command === 128 || velocity === 0) {
            this.activeNotes.delete(note);
            window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail }));
            if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) {
                this.outputNotes();
            }
        }
    }

    outputNotes() {
        const uniqueNotes = Array.from(this.notesPlayed);
        console.log(uniqueNotes);
        window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes }));
    }

    updateStatus(message) {
        window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message }));
    }

    updateDeviceState({ port }) {
        const status = `MIDI: ${port.name} ${port.state}`;
        this.updateStatus(status);
        window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } }));
    }
}

export default MIDIAccessManager

File: output-styles.css
Path: output-styles.css

:root {
    --light0: rgb(240, 240, 240);
    --light1: rgb(220, 220, 220);
    --light2: rgb(208, 208, 208);
    --light3: rgb(143, 142, 142);
    --dark1: #323939;
    --dark2: rgb(35, 42, 42);
    --dark3: rgb(10, 20, 20);
    --accent1: rgb(255, 136, 0);
    --padding: 10px;
    --rounding: 7px;
}

.outputWrapper {
    background-color: var(--dark1);
    flex: 1;
    padding: var(--padding);
    flex-basis: 0px;
    overflow-y: auto;
    background-color: var(--dark2);
    border-radius: 0 0 var(--rounding) var(--rounding);
}

.progression {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    border-radius: var(--rounding);
    background-color: var(--dark1);
    border: 4px solid var(--dark1);
    box-shadow: 0 0 1vw rgba(0, 0, 0, 0.474);
    padding: var(--padding);
    gap: var(--padding);
    background-color: #323939;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%236d6d6d' fill-opacity='0.4' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");


}

.progressionInfo {
    gap: calc(2*var(--padding));
    justify-content: space-between;
    display: flex;
    flex-direction: column;
    /*background: linear-gradient(90deg, rgba(141, 141, 141, 0) 0%, var(--dark2) 100%);*/
    border-radius: 0 var(--rounding) var(--rounding) 0;
    max-width: 25%;
}

.progressionInfoText {
    display: flex;
    flex-direction: column;
    color: var(--accent1);
}

.progressionInfoTextName {
    font-size: x-large;
    font-weight: 900;
    justify-content: baseline;
}

.progressionInfoTextSubtitle {
    color: var(--light2);
}


.soundQualityLables {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    font-size: small;
    font-weight: 1;
    color: var(--light2);

}

.soundQualityWrapper {
    display: flex;
    flex-direction: column;
    justify-content: end;
}

.progressionWrapper {
    display: flex;
    flex: 1;
    align-items: center;
    user-select: none;

}

.progressionWrapper div svg {
    height: max(10vh, 7vw);
    width: auto;
    filter: drop-shadow(0 0 0.5vw #00000058);

}

.progressionWrapper div svg::after{
    content: "AM";
    color: green;
}

@media only screen and (max-width: 1200px) {
    .progression {
        flex-direction: column;
    }

    .progressionInfo {
        flex-direction: row;
        max-width: 100%;
        border-radius: 0 0 var(--rounding) var(--rounding);
    }

    .progressionInfoText {
        max-width: 50%;
    }

    .soundQualityWrapper {
        flex: 1;
    }

    .progressionInfoTextSubtitle {
        font-size: small;
    }
}

File: script.js
Path: piano\script.js

class Piano {
    constructor(containerSelector, options = {}) {
        this.container = document.querySelector(containerSelector);
        this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50);

        this.octaves = options.octaves || 2;
        this.playedNotes = [];
        this.rootNote = null; // Add a property for the root note

        this.lastClickTime = 0;
        this.clickDelay = 300; // 300 milliseconds delay

        this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        this.keysPerOctave = this.layout.length;
        this.whiteKeyCount = this.layout.filter(x => x === 0).length;
        this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
        this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
        this.blackKeyHeight = 0.63;
        this.totalKeys = this.octaves * this.keysPerOctave;

        this.audioElements = [];
        this.volume = true
        this.globalVolume = 0.7;  // Global volume set to maximum by default


        this.createPiano();
        this.addKeyListeners();
    }

    volumeOff() {
        this.volume = false
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

    }

    volumeOn() {
        this.volume = true
    }

    updateVolume() {
        const activeCount = this.playedNotes.length;
        const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
        this.audioElements.forEach(audio => {
            if (!audio.paused) {  // Only update audio elements that are currently playing
                audio.volume = volume;
            }
        });
    }
    
    

    createPiano() {
        this.container.innerHTML = ''; // Clear existing piano keys
        let whiteCounter = 0;

        for (let index = 0; index < this.totalKeys; index++) {
            let key = document.createElement("div");
            key.setAttribute('data-note', index);
            if (this.layout[index % this.keysPerOctave] === 1) {
                key.classList.add("key", "black");
                key.style.left = `${(whiteCounter * this.whiteKeyWidth) - (this.blackKeyWidth / 2)}%`;
                key.style.width = `${this.blackKeyWidth}%`;
                key.style.height = `${this.blackKeyHeight * 100}%`;
                key.style.boxSizing = "border-box";
                key.style.position = `absolute`;
            } else {
                key.classList.add("key", "white");
                key.style.boxSizing = "border-box";
                key.style.width = `${this.whiteKeyWidth}%`;
                whiteCounter++;
            }
            this.container.appendChild(key);
            this.audioElements[index] = new Audio(`./audio/${index % 24}.mp3`);
            this.audioElements[index].preload = 'auto'; // This tells the browser to load the audio as soon as the page is loaded


        }
    }

    addKeyListeners() {
        this.container.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                //console.log("Click triggered")
                let currentTime = Date.now();



                const note = key.getAttribute('data-note');

                
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    if (currentTime - this.lastClickTime > 200) {
                        this.lastClickTime = currentTime;
                        //console.log("Set Time to: "+currentTime)
                    }

                    this.rootNote = null;

                } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) {
                    this.playedNotes = this.playedNotes.filter(n => n !== note);
                    key.classList.remove("selectedKey");
                } else {
                    if (!this.playedNotes.includes(note)) {
                        this.playedNotes.push(note);
                    }
                    key.classList.add("selectedKey");
                    this.playSoundLong(note, 0.75);
                }
                this.updatePlayedNotesDebounced();
            });

            key.addEventListener('dblclick', (event) => {
                //console.log("Doubleclick triggered")
                const note = key.getAttribute('data-note');
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    this.rootNote = null;
                } else {
                    if (this.rootNote !== null) {
                        this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
                    }
                    let currentTime = Date.now();
                    if (currentTime - this.lastClickTime < 500) {
                    } else {
                        this.rootNote = note;
                        if (!this.playedNotes.includes(note)) {
                            this.playedNotes.push(note);
                        }
                        key.classList.add('rootNote', 'selectedKey');
                    }

                }
                this.updatePlayedNotesDebounced();
            });
        });
    }


    debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }


    playSoundLong(index, localVolume) {
        if (this.volume) {
            const audio = this.audioElements[index];
            audio.volume = localVolume * this.globalVolume; // Apply global volume scaling
            if (!audio.paused) {
                audio.currentTime = 0; // Reset if it is already playing
            }
            audio.play();
        }
    }


    
    playChord() {
        this.playedNotes.sort((a, b) => a - b);
        const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1);
        this.playedNotes.forEach((note, index) => {
            const randomDelay = Math.random() * 20;
            setTimeout(() => {
                this.playSoundLong(note, localVolume);
            }, 20 * index + randomDelay);
        });
    }

    activateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (!key.classList.contains("selectedKey")) {
            key.classList.add("selectedKey");
            this.playedNotes.push(index);
            this.updatePlayedNotesDebounced();
            this.updateVolume(); // Adjust volume based on the new number of active notes
        }
        this.playSoundLong(index, 0.75); // Initial play sound with default volume
    }
    
    

    deactivateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (key.classList.contains("selectedKey")) {
            key.classList.remove("selectedKey");
            this.playedNotes = this.playedNotes.filter(n => n !== index);
            this.updatePlayedNotesDebounced();
            // Do not update volume here to keep it consistent with the number of keys pressed
        }
    }
    
    setRootNote(note) {
        const key = this.container.querySelector(`.key[data-note="${note}"]`);
        if (this.rootNote !== null) {
            // Remove rootNote class from the old root note
            this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
        }
        this.rootNote = note; // Update the rootNote to the new note
        key.classList.add('rootNote', 'selectedKey'); // Add rootNote class to new root note
        if (!this.playedNotes.includes(note)) {
            this.playedNotes.push(note); // Add root note to playedNotes if it's not already there
        }
        this.updatePlayedNotesDebounced();
    }

    clearRootNote() {
        if (this.rootNote !== null) {
            const key = this.container.querySelector(`.key[data-note="${this.rootNote}"]`);
            key.classList.remove('rootNote'); // Remove the rootNote class
            this.rootNote = null; // Reset the rootNote property
            this.updatePlayedNotesDebounced();
        }
    }

    updatePlayedNotes() {
        const event = new CustomEvent('notesChanged', { detail: { notes: this.playedNotes, rootNote: this.rootNote } });
        console.log("Dispatching Note Change Event: " + this.playedNotes + " Root: " + this.rootNote)
        this.container.dispatchEvent(event);
    }
    clearPiano() {
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

        this.playedNotes = []; // Clear the array of played notes
        this.rootNote = null; // Clear the root note
        this.container.querySelectorAll('.key.selectedKey').forEach(key => {
            key.classList.remove("selectedKey");
        });
        this.container.querySelectorAll('.key.rootNote').forEach(key => {
            key.classList.remove("rootNote");
        });
        this.updatePlayedNotes();
    }

    setOctaves(newOctaves) {
        if (newOctaves !== this.octaves) {
            this.octaves = newOctaves;
            this.totalKeys = this.octaves * this.keysPerOctave;
            this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
            this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
            this.clearPiano();
            this.createPiano();
            this.addKeyListeners();
        }
    }
}

export default Piano;


File: style.css
Path: piano\style.css



.key.white {
  background-color: #ffffff;
  border-radius: 0 0 0.3vw 0.3vw;
  margin: 1px;
  cursor: pointer;
  z-index: 1;
  transition: 0.3s;

}

.key.black {
  background-color: #000000;
  border-radius: 0 0 0.3vw 0.3vw;
  cursor: pointer;
  z-index: 2;
  box-shadow: -10px 10px 10px rgba(0, 0, 0, 0.131);
  transition: 0.3s;

}

.key:hover {
  filter: invert(0.1);
  transition: 0.1s;
}

.black.key.selectedKey {
  background-color: #a97c00;
  transition: 0.2s;
  transform: scaleY(0.99) translateY(-0.5%);
  box-shadow: 0 0 10px #ffbb006e; /* Add a glowing effect */


}

.white.key.selectedKey {
  background-color: #ffbb00;
  transition: 0.2s;
  transform: scaleY(0.99) translateY(-0.5%);
  box-shadow: 0 0 10px #ffbb006e; /* Add a glowing effect */


}

.key.selectedKey.rootNote, .key.rootNote {
  background-color: #ff1100; /* Red background for the root note */
  transform: scaleY(1.01) translateY(0.5%);  box-shadow: 0 0 10px rgba(255, 0, 0, 0.732); /* Add a glowing effect */
  transition: background-color 0.3s, transform 0.3s; /* Smooth transitions */
}


File: main.js
Path: progression-generator\main.js

import { TUNING, NOTE_INDEX_MAP, BARRE_RATING } from '../chord-factory/constants.js';
import { parseNotes, removeDuplicateArrays } from '../chord-factory/utils.js';
import { ChordFactory } from '../chord-factory/chordfactory.js';
import { Chord } from '../chord-library/script.js';
import { numberToNote } from '../chord-factory/utils.js';
import TabGenerator from "../tab-generator/script.js"



export class ProgressionGenerator {
    constructor(initialProgression = [], useRoot = true, tuning = TUNING, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.tuning = tuning;
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.progression = [];
        this.useRoot = useRoot; // This flag determines if the root note should be the starting note
        this.chordFactoryMap = {}; // HashMap to store ChordFactory instances
        this.keyAnalysis = []

        this.setProgression(initialProgression);

        this.progressionTypes = {
            basic: this.getProgressionBasic,
            // Add more progression types as methods here
        };
    }

    addKeyAnalysis(root, keyscale, prob) {
        // Push a new object to the array with the analysis data
        this.keyAnalysis.push({
            rootNote: root,
            scale: keyscale,
            probability: prob
        });
    }
    analyzeKey() {

        this.keyAnalysis = []
        //Define Possible Scales
        //Higher Prioroty means They get artifically boostes at the Raking
        const scaleStructures = {
            'Major': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 },  // Major Scale: C, D, E, F, G, A, B
            'Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 },  // Natural Minor Scale: A, B, C, D, E, F, G
            'Minor Pentatonic': { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 },  // Minor Pentatonic Scale: A, C, D, E, G
            'Major Pentatonic': { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 },  // Major Pentatonic Scale: C, D, E, G, A
            'Harmonic Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 },  // Harmonic Minor Scale: A, B, C, D, E, F, G#
            'Blues': { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 },  // Blues Scale: A, C, D, D#, E, G
            'Mixolydian': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 },  // Mixolydian Mode: G, A, B, C, D, E, F
            'Dorian': { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, // Dorian Mode: D, E, F, G, A, B, C
            'Phrygian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, // Phrygian Mode: E, F, G, A, B, C, D
            'Lydian': { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, // Lydian Mode: F, G, A, B, C, D, E
            'Locrian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 }  // Locrian Mode: B, C, D, E, F, G, A
        };


        //Generate an Array of Notes and How often They are present
        let notesSet = Array(12).fill(0);
        this.progression.forEach(element => {
            element.notes.forEach(note => {
                notesSet[note]++
            })
        })
        console.log("analyzeKey - notesSet:", notesSet)





        //Now GO through The NoteSet and Calucalte A Number for The Probability of the Key
        notesSet.forEach((scopeNote, index) => {


            //Only Look at occuring Notes
            if (scopeNote != 0) {
                //Loop Through the scaleStrucurtres and the notes array

                Object.keys(scaleStructures).forEach(key => {
                    let ammountWeight = 0.01
                    let rootWeight = 0.01
                    //DO NOT CHANGE
                    let distanceToRootWeight = 1
                    let keyProbability = 0
                    for (let relativeNote = 0; relativeNote < 11; relativeNote++) {
                        if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) {
                            keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight))
                            distanceToRootWeight += rootWeight
                        }
                    }
                    this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority)
                })

            }
        })
        this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability);
        return
    }


    // Set initial progression with ChordFactory instances for each chord
    setProgression(initialProgression) {
        const newChordFactoryMap = {};
        // Create or reuse ChordFactory instances
        initialProgression.forEach(chord => {
            if (chord instanceof Chord) {
                let chordFactory;
                if (this.chordFactoryMap[chord.name]) {
                    chordFactory = this.chordFactoryMap[chord.name];
                    console.log('ChordFactory retrieved for:', chord.name);

                } else {
                    chordFactory = new ChordFactory(chord, this.useRoot, this.tuning);
                    console.log('New ChordFactory created for:', chord.name);
                }
                newChordFactoryMap[chord.name] = chordFactory;
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
            }
        });

        // Update the hashmap and clear out unused ChordFactories
        this.chordFactoryMap = newChordFactoryMap;

        // Populate this.progression with references from the new map
        this.progression = initialProgression.map(chord => this.chordFactoryMap[chord.name]);
        if (this.progression.length > 1) {
            this.analyzeKey()
            console.log("analyzeKey: ", this.keyAnalysis)
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: <b>" + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale + "</b>" } });
            console.log("Key Change Event: " + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale)
            window.dispatchEvent(event);
        } else {
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: ..." } });
            console.log("Key Change Event: none")
            window.dispatchEvent(event);
        }

    }

    getProgression(type = 'basic') {
        if (this.progressionTypes[type]) {
            return this.progressionTypes[type].call(this); // Ensures the method is called with correct this context
        } else {
            console.error('ProgressionGenerator: Invalid progression type requested.');
            return [];
        }
    }

    getPlaceholderHTML() {
        const placeholderCount = 4; // Generate 1 to 3 placeholders
        const diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.style.opacity = 0.2
        diagramsContainer.style.display = "flex"

        for (let i = 0; i < placeholderCount; i++) {
            // Example placeholder data


            let voicing = [0, 0, 0, 0, 0, 0];

            // Create a set to keep track of chosen indices (to ensure uniqueness)
            let indices = new Set();

            // Randomly choose 4 unique indices
            while (indices.size < 4) {
                let index = Math.floor(Math.random() * voicing.length);
                indices.add(index);
            }

            // Populate the chosen indices with random numbers between -1 and 4
            indices.forEach(index => {
                voicing[index] = Math.floor(Math.random() * 6) - 1; // Generates values from -1 to 4
            });

            const fingerPositions = [0, 0, 0, 0, 0, 0]; // Positions for C major
            const barreSize = 0; // No barre for this example

            // Assuming TabGenerator can handle this static data
            try {
                const chordDiagram = new TabGenerator(voicing, fingerPositions, barreSize, null, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                const svg = chordDiagram.generateChordSVG();
                diagramsContainer.appendChild(svg);
            } catch (error) {
                console.error('Error generating placeholder chord diagram:', error);
            }
        }
        const textContent = document.createElement('div')
        textContent.innerHTML = "Search for chords using the piano keys, the search bar, or connect your MIDI device."
        textContent.style.display = "flex"
        textContent.style.alignItems = "center"
        diagramsContainer.appendChild(textContent);
        return diagramsContainer; // Return the container with all placeholder SVGs
    }

    getProgressionHTML(desiredClasses = [], progressionType = "basic") {
        // Create an instance of ProgressionGenerator with the given progression and tuning
        const progression = this.getProgression(progressionType); // Get the basic progression

        const diagramsContainer = document.createElement('div'); // Container for chord diagrams
        desiredClasses.forEach(desiredClass => {
            diagramsContainer.classList.add(desiredClass)
        });

        progression.forEach(chordVoicing => {
            // Extract first playable chord from each ChordFactory instance
            if (chordVoicing) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    const chordDiagram = new TabGenerator(chordVoicing.voicing, chordVoicing.fingerPositions, chordVoicing.barreSize, chordVoicing.barre, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                    const svg = chordDiagram.generateChordSVG();
                    diagramsContainer.appendChild(svg);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        });

        return diagramsContainer; // Return the container with all SVGs
    }

    getProgressionBasic() {
        // Iterate over each entry in the progression and get the first playable chord
        return this.progression.map(chordFactory => {
            if (chordFactory.playableChords && chordFactory.playableChords.length > 0) {
                return chordFactory.playableChords[0];
            } else {
                return null; // Return null if there are no playable chords available
            }
        }).filter(chord => chord !== null); // Filter out any null entries
    }


    getProgressionDynamicHTML(soundQuality = 0.5) {
        // Iterate over each entry in the progression, sort by combined rating, and get the first playable chord
        if (this.progression.length < 1) {
            return this.getPlaceholderHTML()
        }
        this.progression.forEach(chordFactory => {
            chordFactory.sortPlayableChordsByCombinedRating(soundQuality);
        });

        let diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.classList.add("progressionGeneratorContainer")
        console.log(this.progression)


        this.progression.forEach(chordFactory => {
            // Extract first playable chord from each ChordFactory instance
            if (chordFactory.playableChords[0]) {
                // Assuming TabGenerator takes chord details and returns an SVG element
                try {
                    const chordDiagram = new TabGenerator(chordFactory.playableChords[0].voicing, chordFactory.playableChords[0].fingerPositions, chordFactory.playableChords[0].barreSize, chordFactory.playableChords[0].barre, this.color, this.invertColor(this.color), this.fingerNumbers, this.showOpenStrings);
                    const svg = chordDiagram.generateChordSVG();
                    let svgContainer = document.createElement('div'); // Container for chord diagrams
                    svgContainer.classList.add("progressionGeneratorSvgContainer")

                    let svgNameContainer = document.createElement('div'); // Container for chord diagrams
                    svgNameContainer.innerHTML = chordFactory.identifier
                    svgNameContainer.classList.add("progressionGeneratorSvgChordName")


                    svgContainer.appendChild(svg);
                    svgContainer.appendChild(svgNameContainer)
                    diagramsContainer.appendChild(svgContainer)
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        });

        return diagramsContainer; // Return the container with all SVGs
    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
}

File: style.css
Path: progression-generator\style.css

:root {
    --light0: rgb(240, 240, 240);
    --light1: rgb(220, 220, 220);
    --light2: rgb(208, 208, 208);
    --light3: rgb(143, 142, 142);
    --dark1: rgb(50, 57, 57);
    --dark2: rgb(35, 42, 42);
    --dark3: rgb(10, 20, 20);
    --accent1: rgb(255, 136, 0);
    --padding: 10px;
    --rounding: 7px;
}


.progressionGeneratorContainer{
    display: flex;
    gap: var(--padding);
    
}

.progressionGeneratorSvgChordName {
    background-color: var(--light0);
    padding: calc(var(--padding) / 2) var(--padding);
    border-radius: var(--rounding);
    font-weight: 800;
    box-sizing: border-box;
    color: var(--dark2);
    box-shadow: 0 0 10px #00000056, inset 0 0 3px #ffffff6e;
    position: relative;
    margin-right: calc(max(10vh, 7vw)/10);
    top:calc(calc(max(10vh, 7vw)/10)*-1)
}

.progressionGeneratorSvgContainer{
    display: flex;
    flex-direction: column;
    align-items: center;
}

File: slider-style.css
Path: slider-style.css

:root {
    --light0: rgb(240, 240, 240);
    --light1: rgb(220, 220, 220);
    --light2: rgb(208, 208, 208);
    --light3: rgb(143, 142, 142);
    --dark1: rgb(50, 57, 57);
    --dark2: rgb(35, 42, 42);
    --dark3: rgb(10, 20, 20);
    --padding: 10px;
    --rounding: 7px;
}

input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: var(--padding);
    background: var(--light1);
    border-radius: var(--rounding);
    outline: none;
    opacity: 0.7;
    -webkit-transition: .2s;
    transition: opacity .2s;
    margin:  calc(var(--padding)/2) 0px;
    padding: 0;
    border: 0;
    box-shadow: 0 0 1vw rgba(0, 0, 0, 0.312);

}

input[type="range"]:hover {
    opacity: 1;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    height: calc(2*var(--padding));
    width: calc(2*var(--padding));
    background: #ffa600;
    cursor: pointer;
    border-radius: 100%;
    box-shadow: 0 0 1vw rgba(0, 0, 0, 0.312);

}

input[type="range"]::-moz-range-thumb {
    width: 25px;
    height: 25px;
    background: #04AA6D;
    cursor: pointer;
}

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Diagram Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>Guitar Chord Diagram Generator</h1>
        <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input">
        <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)">
        <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button>
        <div id="diagram" class="diagram-container"></div>
    </div>
    <script type="module">
        import TabGenerator from "./script.js"

        const fingerPositions = ['-1', '13', '12', '5', '0', '0'];
        const fingerNumbers = ['9', '1', '2', '1', '', ''];
        const barreSize = 3;
        const barre = 10;
        const color = "#fff";
        const textColor = "#000";
        const showOpenStrings = true;

        try {
            const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, barreSize, barre, color, textColor, 'belowString', showOpenStrings);
            const svg = chordDiagram.generateChordSVG();
            document.getElementById('diagram').appendChild(svg);
        } catch (error) {
            console.error('Error generating chord diagram:', error);
        }
    </script>
</body>

</html>

File: script.js
Path: tab-generator\script.js

/**
 * Represents a TabGenerator for creating guitar chord diagrams as SVG elements.
 * This class allows the configuration of various aspects of the diagram, including finger positions,
 * barre chords, string and note visualization, and color customization.
 */
class TabGenerator {
    /**
     * Creates an instance of TabGenerator.
     * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings.
     * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string.
     * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used.
     * @param {string} [barre=null] - Specific fret where the barre is placed.
     * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes.
     * @param {string} [textColor="#fff"] - Color for the text used in the diagram.
     * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately.
     * @param {boolean} showOpenStrings - Whether to display open strings in the diagram.
     */
    constructor(fingerPositions, fingerNumbers, barreSize = null, barre = null, elementColor = "#000", textColor = "#fff", numberPosition = 'onNote', showOpenStrings) {

        if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) {
            console.error("Error: fingerPositions must be an array of length 6.");
        }
        if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) {
            console.error("Error: fingerNumbers must be an array of length 6 or null.");
        }
        if (barreSize !== null && (typeof barreSize !== 'number' || barreSize < 1 || barreSize > 6)) {
            console.error("Error: barreSize must be a number between 1 and 6 or null.");
        }
        if (barre !== null && (typeof barre !== 'number' || !/^\d+$/.test(barre))) {
            console.error("Error: barre must be a string representing a number or null.");
        }
        if (typeof elementColor !== 'string') {
            console.error("Error: elementColor must be a string.");
        }
        if (typeof textColor !== 'string') {
            console.error("Error: textColor must be a string.");
        }
        if (numberPosition !== 'onNote' && numberPosition !== 'belowString') {
            console.error("Error: numberPosition must be either 'onNote' or 'belowString'.");
        }
        if (typeof showOpenStrings !== 'boolean') {
            console.error("Error: showOpenStrings must be a boolean.");
        }

        this.fingerPositions = fingerPositions;
        this.fingerNumbers = fingerNumbers;
        this.barreSize = barreSize;
        this.barre = barre;
        this.numberPosition = numberPosition;
        this.showOpenStrings = showOpenStrings;
        this.topSpacing = 25;
        this.indicatorTopSpacing = 19;
        this.textTopSpacing = 190
        this.topBarHeight = 5
        this.color = elementColor
        this.textColor = textColor
    }

    generateChordSVG() {
        const svgAttributes = {
            width: '200',
            height: '200',
            viewBox: '0 0 200 200'  // This sets the viewBox attribute
        };
        const svg = this.createSVGElement('svg', svgAttributes);
        this.drawDiagramComponents(svg);
        return svg;
    }

    drawDiagramComponents(svg) {
        this.drawTopBar(svg);
        if (this.barreSize !== null) {
            this.drawBarre(svg);
        }
        this.drawStrings(svg);
        this.drawFrets(svg);
        if (this.showOpenStrings) {
            this.drawOpenStrings(svg);
        }
        this.drawNotes(svg);
        this.drawMuteIndicators(svg);
    }


    createSVGElement(tag, attributes) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const attr in attributes) {
            element.setAttribute(attr, attributes[attr]);
        }
        return element;
    }

    drawTopBar(svg) {
        const topBar = this.createSVGElement('rect', {
            x: "29.5",
            y: 14 + this.topSpacing,
            width: '125',
            height: this.topBarHeight,
            fill: this.color,
            stroke: this.color,
            'stroke-width': '2'
        });
        svg.appendChild(topBar);
    }

    drawStrings(svg) {
        for (let i = 0; i < 6; i++) {
            const line = this.createSVGElement('line', {
                x1: 30 + i * 25, y1: this.topSpacing + 13,
                x2: 30 + i * 25, y2: 140 + this.topSpacing,
                stroke: this.color, 'stroke-width': ((6 - i) / 3) + 1
            });
            svg.appendChild(line);
        }
    }

    drawFrets(svg) {
        for (let j = 0; j < 5; j++) {
            const line = this.createSVGElement('line', {
                x1: '30', y1: 20 + this.topSpacing + j * 25,
                x2: '155', y2: 20 + this.topSpacing + j * 25,
                stroke: this.color, 'stroke-width': '2'
            });
            svg.appendChild(line);
        }
    }

    drawNotes(svg) {
        const barreFret = this.barre ? parseInt(this.barre) : 1;
        for (let k = 0; k < 6; k++) {
            if (this.fingerPositions[k] !== 'x') {
                const fret = parseInt(this.fingerPositions[k]);
                if (fret > 0) {
                    const position = 40 + (fret - barreFret) * 25;
                    const circle = this.createSVGElement('circle', {
                        cx: 30 + k * 25, cy: position + this.topSpacing - 8,
                        r: '10', fill: this.color
                    });
                    svg.appendChild(circle);

                    if (this.fingerNumbers && this.fingerNumbers[k]) {
                        const textPositionY = this.numberPosition === 'onNote' ? position + this.topSpacing : this.textTopSpacing;
                        const text = this.createSVGElement('text', {
                            x: 30 + k * 25,
                            y: textPositionY,
                            'font-family': 'Arial',
                            'font-size': '20',
                            'font-weight': '500',
                            fill: this.numberPosition === 'onNote' ? this.textColor : this.color,
                            'text-anchor': 'middle'
                        });
                        text.textContent = this.fingerNumbers[k];
                        svg.appendChild(text);
                    }
                }
            }
        }
    }

    drawMuteIndicators(svg) {
        const ofsetX = 0;
        const ofsetY = -15 + this.indicatorTopSpacing;
        const strokeLength = 13;
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] == -1) {
                const halfStroke = strokeLength / 2;
                const line1 = this.createSVGElement('line', {
                    x1: 30 + i * 25 - halfStroke + ofsetX,
                    y1: 10 + ofsetY,
                    x2: 30 + i * 25 + halfStroke + ofsetX,
                    y2: 10 + strokeLength + ofsetY,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                const line2 = this.createSVGElement('line', {
                    x1: 30 + i * 25 + halfStroke + ofsetX,
                    y1: 10 + ofsetY,
                    x2: 30 + i * 25 - halfStroke + ofsetX,
                    y2: 10 + strokeLength + ofsetY,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(line1);
                svg.appendChild(line2);
            }
        }
    }

    drawOpenStrings(svg) {
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] === '0') {
                const circle = this.createSVGElement('circle', {
                    cx: 30 + i * 25,
                    cy: this.indicatorTopSpacing,
                    r: '7',
                    fill: 'none',
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(circle);
            }
        }
    }

    drawBarre(svg) {
        const index = 6 - this.barreSize;
        const barreWidth = this.barreSize * 25 - 15;
        const barreHeight = 10;
        const barreX = 25 + index * 25 - 5;
        const barreY = 25 + (7.5 - barreHeight / 2) + this.topSpacing;

        const rect = this.createSVGElement('rect', {
            x: barreX, y: barreY,
            width: barreWidth + 10, height: barreHeight,
            rx: '5', ry: '5',
            fill: this.color
        });
        svg.appendChild(rect);

        if (this.barre) {
            const text = this.createSVGElement('text', {
                x: barreX + barreWidth + 15, y: barreY + barreHeight,
                'font-family': 'Arial', 'font-size': '20', fill: this.color,
                'text-anchor': 'left'
            });
            text.textContent = this.barre + "fr";
            svg.appendChild(text);
        }
    }
}

export default TabGenerator;

File: styles.css
Path: tab-generator\styles.css

body,
html {
    height: 100%;
    margin: 0;
    font-family: 'Arial', sans-serif;
    background-color: #333333;
    display: flex;
    align-items: center;
    justify-content: center;
}

.container {
    width: 90%;
    max-width: 600px;
    text-align: center;
    padding: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(36, 36, 36);
    border-radius: 8px;
}

h1 {
    color: #333;
}

.chord-input,
.generate-btn {
    padding: 10px;
    width: calc(50% - 20px);
    margin: 10px;
    border: 2px solid #333333;
    border-radius: 5px;
    font-size: 16px;
}

.chord-input:focus,
.generate-btn:hover {
    border-color: #0056b3;
}

.generate-btn {
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border-color: #007bff;
}

.diagram-container {
    margin-top: 20px;
    background-color: #333333;
    border: 1px solid #333333;
    padding: 10px;
}

#diagram svg {
    width: 200px;
    height: auto;
    box-shadow: #333;
    filter: drop-shadow(0px 0px 10px #000000);

}

