Directory Structure:
audio/
chord-factory/
  chordfactory.js (Path: chord-factory\chordfactory.js)
  chordvoicing.js (Path: chord-factory\chordvoicing.js)
  constants.js (Path: chord-factory\constants.js)
  main.js (Path: chord-factory\main.js)
  utils.js (Path: chord-factory\utils.js)
chord-library/
  script.js (Path: chord-library\script.js)
chordviewer/
  index.html (Path: chordviewer\index.html)
  index.js (Path: chordviewer\index.js)
createChatGPTContext.js (Path: createChatGPTContext.js)
css/
drag-drop/
  script.js (Path: drag-drop\script.js)
index.html (Path: index.html)
index.js (Path: index.js)
midi-integration/
  index.html (Path: midi-integration\index.html)
  script.js (Path: midi-integration\script.js)
piano/
  script.js (Path: piano\script.js)
progression-generator/
  main.js (Path: progression-generator\main.js)
  svg/
  tabhtml.js (Path: progression-generator\tabhtml.js)
settings.js (Path: settings.js)
svg/
tab-generator/
  index.html (Path: tab-generator\index.html)
  script.js (Path: tab-generator\script.js)

File Contents:
File: chordfactory.js
Path: chord-factory\chordfactory.js

import { settings, MAX_FRETS } from './constants.js';
import { ChordVoicing } from './chordvoicing.js';


export class ChordFactory {
  constructor(chord, startWithRoot = true, tuning = settings.tuning) {
    console.log("ChordFactory Recieved Notes: ", chord.notes)
    this.identifier = chord.name
    this.notes = chord.notes;
    this.startWithRoot = startWithRoot
    this.root = chord.rootNote
    this.tuning = tuning;
    this.fingerPositions = this.calculateValidFingerPositions();
    this.allChords = this.generateAllChordCombinations2()
    this.playableChords = this.filterPlayableChords2(structuredClone(this.allChords))
    
    this.sortPlayableChordsByCombinedRating(1)
  }

  getFretSpanStatistics() {
    let spanCounts = {};  

    
    this.allChords.forEach(chord => {
      
      const frets = chord.filter(fret => fret > 0);
      if (frets.length > 1) { 
        const minFret = Math.min(...frets);
        const maxFret = Math.max(...frets);
        const span = maxFret - minFret;

        
        if (span in spanCounts) {
          spanCounts[span] = spanCounts[span] + 1;
        } else {
          spanCounts[span] = 1;
        }
      }
    });

    
    console.log("Fret Span Statistics:", spanCounts);
    return spanCounts;
  }


  calculateValidFingerPositions() {
    const fingerPositions = [];

    for (let stringIndex of this.tuning) {
      const positions = [];
      for (let chordIndex of this.notes) {
        const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12);
        positions.push(...validPositions);
      }
      if (!positions.includes(0)) { 
        positions.push(-1); 
      }
      positions.sort((a, b) => a - b); 
      fingerPositions.push(positions);
    }

    return fingerPositions;
  }

  getValidFretPositionsForNote(noteIndex, stringIndex) {
    const baseFret = (noteIndex - stringIndex + 120) % 12;
    return [baseFret, baseFret + 12];
  }

  cartesianProduct(arrays) {
    return arrays.reduce((acc, curr) => {
      return acc.flatMap(a => curr.map(b => [...a, b]));
    }, [[]]);
  }


  
  generateAllChordCombinations2() {

    const startTime = performance.now();

    let chords = [];
    

    let maskScope = [];
    for (let i = 0; i < 6; i++) {
      
      if (this.fingerPositions[i])
        maskScope[i] = [this.fingerPositions[i][0]]; 
    }
    

    const fingerIndexStorage = Array(6).fill(1);
    

    let fingerIndexLength = []
    this.fingerPositions.forEach((element, inndex) => {
      fingerIndexLength[inndex] = element.length - 1
    })

    

    
    for (let fret = 0; fret < 13; fret++) {
      

      for (let string = 0; string < 6; string++) {

        for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) {
          
          
          if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) {
            maskScope[string].splice(validPosition, 1);
          }
        }
      }
      
      

      

      
      for (let string = 0; string < 6; string++) {
        

        
        
        if (fingerIndexStorage[string] < fingerIndexLength[string]) {
          
          if (this.fingerPositions[string][fingerIndexStorage[string]] <= fret + settings.fingerFretRange - 1) {
            

            maskScope[string].push(this.fingerPositions[string][fingerIndexStorage[string]])

            for (let pos1 of maskScope[(string + 1) % 6]) {
              for (let pos2 of maskScope[(string + 2) % 6]) {
                for (let pos3 of maskScope[(string + 3) % 6]) {
                  for (let pos4 of maskScope[(string + 4) % 6]) {
                    for (let pos5 of maskScope[(string + 5) % 6]) {
                      let newVoicing = []
                      newVoicing[string] = this.fingerPositions[string][fingerIndexStorage[string]]
                      newVoicing[(string + 1) % 6] = pos1
                      newVoicing[(string + 2) % 6] = pos2
                      newVoicing[(string + 3) % 6] = pos3
                      newVoicing[(string + 4) % 6] = pos4
                      newVoicing[(string + 5) % 6] = pos5


                      
                      chords.push(newVoicing);
                    }
                  }
                }
              }
            }
            

            fingerIndexStorage[string]++

          } else {
            
          }
        } else {
          
        }

        

        
      }
    }
    
    const endTime = performance.now();

    
    const timeTaken = endTime - startTime;
    console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds");
    return chords;
  }


  filterPlayableChords(allChordsCopy) {
    const startTime = performance.now();

    const playableChordsSet = new Set();

    allChordsCopy.forEach(voicing => {
      
      if (this.startWithRoot) {
        for (let string = 0; string < 6; string++) {
          if (voicing[string] == -1) {
            continue;
          } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) {
            voicing[string] = -1;
          } else {
            break;
          }
        }
      }

      
      let minAboveZero = Infinity;
      for (let i = 0; i < voicing.length; i++) {
        if (voicing[i] > 0 && voicing[i] < minAboveZero) {
          minAboveZero = voicing[i];
        }
      }
      if (minAboveZero === Infinity) {
        minAboveZero = 0;
      }

      let fingersUsed = 0;
      let barreStop = false;
      let barreUseFingers = 0;
      let barreAddFingers = 0;
      for (let i = 5; i >= 0; i--) {
        if (voicing[i] <= 0) {
          barreStop = true;
        }
        if (voicing[i] >= minAboveZero && barreStop == false) {
          barreUseFingers++;
          if (voicing[i] > minAboveZero) {
            barreAddFingers++;
          }
        } else if (voicing[i] > 0 && voicing[i] !== "x") {
          barreAddFingers++;
        }
      }
      if (barreUseFingers) {
        if (barreUseFingers >= 2 && barreAddFingers > 3) {
          return;
        } else if (barreUseFingers < 2) {
          fingersUsed = voicing.filter(fret => fret >= minAboveZero).length;
          barreUseFingers = 0;
        }
      }
      if (fingersUsed <= 4) {
        let newVoicing = new ChordVoicing(
          voicing,
          barreUseFingers > 0 ? minAboveZero : null,
          barreUseFingers > 0 ? barreAddFingers : fingersUsed,
          barreUseFingers,
          minAboveZero,
          this.notes,
          this.startWithRoot ? this.root : -1
        );

        playableChordsSet.add(JSON.stringify(newVoicing));
      }
    });

    
    const playableChords = Array.from(playableChordsSet).map(voicingString => JSON.parse(voicingString));

    
    const endTime = performance.now();

    
    const timeTaken = endTime - startTime;
    console.log("filterPlayableChords - Time taken:", timeTaken, "milliseconds");

    return playableChords;
  }


  filterPlayableChords2(allChordsCopy) {
    const startTime = performance.now();
    let playableChordsVoicingSet = new Set();
    let playableChordsArray = []
    let totalChordVoicingTime = 0; 

    
    let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => []));
    let barreClassesUsed = new Set();
    let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0);
    let minAboveZero = 99;
    let mutingTillRoot = true;
    let touchedSet = new Set();
    let barres = []
    let touchedIndices = [];
    let fingerPositionsCounter = 0
    let fingerPositions = [-1, -1, -1, -1, -1, -1]
    let fingerPositionsAmmount = 0


    allChordsCopy.forEach(voicing => {
      minAboveZero = 99;
      mutingTillRoot = true;

      
      barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0));
      barreClassesUsed.clear();
      touchedSet.clear()
      barreSeparatorIndex.fill(0);
      barres = []
      touchedIndices = [];
      fingerPositionsCounter = 0
      fingerPositions = [-1, -1, -1, -1, -1, -1]
      fingerPositionsAmmount = 0


      for (let string = 0; string < 6; string++) {
        
        if (this.startWithRoot && mutingTillRoot) {
          if (voicing[string] == -1) {
            
          } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) {
            
            voicing[string] = -1;
          } else {
            mutingTillRoot = false;
          }
        }

        
        if (voicing[string] > 0) {
          fingerPositionsAmmount++
          if (voicing[string] < minAboveZero) {
            minAboveZero = voicing[string];
          }
        }


      }
      
      let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5];
      if (playableChordsVoicingSet.has(voicingString)) {
        
        return; 
      }

      
      if (fingerPositionsAmmount < 2) {
        return
      }

      
      if (fingerPositionsAmmount > 4) {

        for (let string = 0; string < 6; string++) {
          




          
          if (voicing[string] >= 0) {

            barreClassesUsed.forEach((index) => {
              if (voicing[string] < index) {
                barreSeparatorIndex[index] += 1;
              }
            });

            barreClassesUsed.add(voicing[string]);
            barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string);
            const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`;
            if (!touchedSet.has(newIndex)) {
              touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]);
              touchedSet.add(newIndex);
            }
          }
        }


        
        touchedIndices.sort(([fretA], [fretB]) => fretA - fretB);
        
        touchedIndices.forEach(([fret, index]) => {
          if (barreClass[fret][index].length > 0) {
            if (barreClass[fret][index].length > 1 && fret != 0) {
              barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])])
              fingerPositionsCounter++
              barreClass[fret][index].forEach(element => {
                fingerPositions[element] = fingerPositionsCounter
              })

            } else if (fret != 0) {
              fingerPositionsCounter++
              fingerPositions[barreClass[fret][index]] = fingerPositionsCounter
            }

          }

        });


        
        if (fingerPositionsCounter > 4) {
          return
        }
      } else {
        
        
        for (let fret = 0; fret < settings.fingerFretRange; fret++) {
          for (let string = 0; string < 6; string++) {
            if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) {
              fingerPositionsCounter++
              fingerPositions[string] = fingerPositionsCounter

            }
          }
        }
      }

      
      if (minAboveZero == 99) {
        minAboveZero = 0
      }

      const chordVoicingStartTime = performance.now();

      let newVoicing = new ChordVoicing(
        voicing,
        fingerPositions,
        barres,
        minAboveZero,
        fingerPositionsAmmount,
        this.notes,
        this.startWithRoot ? this.root : -1
      );

      const chordVoicingEndTime = performance.now();
      const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime;
      totalChordVoicingTime += chordVoicingTimeTaken;

      playableChordsVoicingSet.add(voicingString);
      playableChordsArray.push(newVoicing);
      
      

    });
    const endTime = performance.now();

    
    const totalTimeTaken = endTime - startTime;

    console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds");
    console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds");
    return playableChordsArray
  }



  
  sortPlayableChordsByCombinedRating(soundWeight = 0) {
    if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) {
      throw new Error("soundWeight must be a number between 0 and 1.");
    }
    console.log("Sorting...")
    this.playableChords.sort((a, b) => {
      let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight));
      let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight));
      return bCombinedRating - aCombinedRating;
    });
  }
}


File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { settings } from './constants.js';



export class ChordVoicing {
  
  constructor(voicing, fingerPositions, barres, minAboveZero, fingersUsed, chordFactoryNotes, chordFactoryRoot) {


    this.voicing = voicing;
    this.barres = barres;

    this.minAboveZero = minAboveZero
    this.fingerPositions = fingerPositions
    this.fingersUsed = fingersUsed
    this.chordSpacing = 0
    this.chordFactoryNotes = chordFactoryNotes
    this.chordFactoryRoot = chordFactoryRoot
    this.actuallyPlayedNotes = [0, 0, 0, 0, 0, 0]

    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] >= 0) {
        this.actuallyPlayedNotes[i] = (this.voicing[i] + settings.tuning[i])
      } else {
        this.actuallyPlayedNotes[i] = this.voicing[i]
      }
    }

    this.playabilityRating = 0;
    this.soundQualityRating = 0; 

    this.ratingDetails = {
      playability: {
        fingersUsed: 0,
        fingerSpread: 0,
        mutedAmount: 0,
        fretHeight: 0,
        total: 0,
      },
      soundQuality: {
        harmonicCompleteness: 0,
        openStrings: 0,
        playedStrings: 0,
        fretBoardHeight: 0,
        voicingRange: 0,
        doubleNotes: 0,
        total: 0,
      }
    };

    
    

    this.rateSoundQuality()
    this.ratePlayability()

    

  }

  calculateChordSpacing() {
    if (this.fingerPositions.length !== 6 || this.voicing.length !== 6) {
      throw new Error('Input arrays must each have 6 elements.');
    }

    let notes = this.fingerPositions.map((finger, index) => ({
      string: index + 1,
      fret: this.voicing[index],
      finger
    })).filter(note => note.finger !== 0 && note.fret !== -1);

    
    if (this.barre) {
      notes = notes.filter(note => note.finger !== 1);
    }

    notes.sort((a, b) => a.fret - b.fret || a.string - b.string);

    let totalSpacing = 0;
    for (let i = 0; i < notes.length - 1; i++) {
      const stringDistance = Math.abs(notes[i].string - notes[i + 1].string);
      const fretDistance = Math.abs(notes[i].fret - notes[i + 1].fret);
      totalSpacing += stringDistance + fretDistance;
    }

    this.chordSpacing = totalSpacing;
  }

  static PLAYABILITY_WEIGHTS = {
    fingersUsed: 1,
    fingerSpread: 1,
    mutedAmount: 1,
    fretHeight: 1,
    mutedDifficulty: 1,
    mutedReachability: 1,
    barreAmount: 1
  };

  
  ratePlayability() {
    const details = this.ratingDetails.playability;
    details.fingersUsed = this.assessPlayabilityFingersUsed();
    details.fingerSpread = this.assessPlayabilityFingerSpread();
    details.mutedAmount = this.assessPlayabilityMutedAmount();
    details.fretHeight = this.assessPlayabilityFretHeight();
    details.mutedDifficulty = this.assessPlayabilityMutedDifficulty();
    details.mutedReachability = this.assessPlayabilityMutedReachability();
    details.barreAmount = this.assessPlayabilityBarreAmount();

    details.total = (
      details.fingersUsed * ChordVoicing.PLAYABILITY_WEIGHTS.fingersUsed +
      details.fingerSpread * ChordVoicing.PLAYABILITY_WEIGHTS.fingerSpread +
      details.mutedAmount * ChordVoicing.PLAYABILITY_WEIGHTS.mutedAmount +
      details.fretHeight * ChordVoicing.PLAYABILITY_WEIGHTS.fretHeight +
      details.mutedDifficulty * ChordVoicing.PLAYABILITY_WEIGHTS.mutedDifficulty +
      details.mutedReachability * ChordVoicing.PLAYABILITY_WEIGHTS.mutedReachability +
      details.barreAmount * ChordVoicing.PLAYABILITY_WEIGHTS.barreAmount
    ) / Object.keys(ChordVoicing.PLAYABILITY_WEIGHTS).length;

    this.playabilityRating = details.total;
  }

  assessPlayabilityFingersUsed() {
    
    let maxUsableFingers = 4
    
    let rating = 1 - (this.fingersUsed / maxUsableFingers)
    return rating
  }

  assessPlayabilityFingerSpread() {
    let maxFret = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] > maxFret) {
        maxFret = this.voicing[i]
      }
    }
    return 1 - ((maxFret - this.minAboveZero) / settings.fingerFretRange)
  }

  assessPlayabilityMutedAmount() {
    let mutedCount = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] == -1) {
        mutedCount++
      }
    }
    return 1 - (mutedCount / 6)
  }

  assessPlayabilityFretHeight() {
    return 1 - Math.max((this.minAboveZero / 12), 0)
  }

  assessPlayabilityMutedDifficulty() {
    let mutedDifficulty = 0
    
    for (let i = 0; i < 4; i++) {
      if (this.voicing[i] == -1) {
        mutedDifficulty += (i + 1)
      }
    }
    
    for (let i = 0; i < 4; i++) {
      if (this.voicing[5 - i] == -1) {
        mutedDifficulty += (i + 1)
      }
    }

    return 1 - (mutedDifficulty / 12)

  }

  assessPlayabilityBarreAmount() {
    return 1 - ((this.barres.length * this.barres.length) / (3 * 3))
  }

  assessPlayabilityMutedReachability() {
    let mutedDifficulty = 0;
    let totalUnreachableMutes = 0;

    
    for (let i = 1; i < this.voicing.length - 1; i++) { 
      if (this.voicing[i] === -1) { 
        
        if (this.voicing[i - 1] === 0 && this.voicing[i + 1] === 0) {
          totalUnreachableMutes++;
        }
      }
    }

    
    if (this.voicing[0] === -1 && this.voicing[1] === 0) { 
      totalUnreachableMutes++;
    }
    if (this.voicing[this.voicing.length - 1] === -1 && this.voicing[this.voicing.length - 2] === 0) { 
      totalUnreachableMutes++;
    }

    
    mutedDifficulty = totalUnreachableMutes / (this.voicing.filter(v => v === -1).length || 1); // Avoid division by zero

    return 1 - mutedDifficulty; 
  }









  static SOUND_QUALITY_WEIGHTS = {
    harmonicCompleteness: 1,
    openStrings: 1,
    playedStrings: 1,
    fretBoardHeight: 1,
    voicingRange: 0,
    doubleNotes: 1
  };

  
  rateSoundQuality() {
    const details = this.ratingDetails.soundQuality;
    details.harmonicCompleteness = this.assessSoundHarmonicCompleteness();
    details.openStrings = this.assessSoundOpenStrings();
    details.playedStrings = this.assessSoundPlayedStrings();
    details.fretBoardHeight = this.assessSoundFretBoardHeight();
    details.voicingRange = this.assessSoundVoicingRange();
    details.doubleNotes = this.assessSoundDoubleNotes();

    details.total = (
      details.harmonicCompleteness * ChordVoicing.SOUND_QUALITY_WEIGHTS.harmonicCompleteness +
      details.openStrings * ChordVoicing.SOUND_QUALITY_WEIGHTS.openStrings +
      details.playedStrings * ChordVoicing.SOUND_QUALITY_WEIGHTS.playedStrings +
      details.fretBoardHeight * ChordVoicing.SOUND_QUALITY_WEIGHTS.fretBoardHeight +
      details.voicingRange * ChordVoicing.SOUND_QUALITY_WEIGHTS.voicingRange +
      details.doubleNotes * ChordVoicing.SOUND_QUALITY_WEIGHTS.doubleNotes
    ) / Object.keys(ChordVoicing.SOUND_QUALITY_WEIGHTS).length;

    this.soundQualityRating = details.total;
  }

  assessSoundHarmonicCompleteness() {
    
    const uniqueDesiredNotes = new Set(this.chordFactoryNotes.map(note => note % 12));

    
    const playedNotesModuloSet = new Set(this.actuallyPlayedNotes.map(note => note % 12));

    
    let overlapCount = 0;
    uniqueDesiredNotes.forEach(note => {
      if (playedNotesModuloSet.has(note)) {
        overlapCount++;
      }
    });

    
    const completenessScore = overlapCount / uniqueDesiredNotes.size;
    return completenessScore;
  }

  assessSoundOpenStrings() {
    let openStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] === 0) {
        openStrings++;
      }
    }

    return openStrings / this.voicing.length;
  }

  assessSoundPlayedStrings() {
    let playedStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] >= 0) {
        playedStrings++;
      }
    }

    return playedStrings / this.voicing.length;
  }

  assessSoundFretBoardHeight() {
    return Math.max(0, (1 - (this.minAboveZero / 12)))
  }



  assessSoundVoicingRange() {
    let minIndex = -1
    let maxIndex = -1
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] != -1) {
        minIndex = i
        break;
      }
    }
    
    if (minIndex < 0) {
      return 0;
    }

    for (let i = 5; i >= 0; i--) {
      if (this.voicing[i] != -1) {
        maxIndex = i
        break;
      }
    }
    let spacing = this.actuallyPlayedNotes[maxIndex] - this.actuallyPlayedNotes[minIndex]
    let maxSpacing = settings.tuning[5] + this.minAboveZero + settings.fingerFretRange - settings.tuning[0] + this.minAboveZero

    
    let spacingRatio = spacing / maxSpacing
    return spacingRatio
  }

  assessSoundDoubleNotes() {
    let doubleNotes = 0
    for (let i = 0; i < 5; i++) {
      if (this.actuallyPlayedNotes[i] == this.actuallyPlayedNotes[i + 1]) {
        doubleNotes++;
      }
    }
    return 1 - (doubleNotes / 5)
  }
}




File: constants.js
Path: chord-factory\constants.js



export const BARRE_RATING = 1
export const MAX_FRETS = 24


class Settings {
  
  constructor() {
    this._tuning = [40, 45, 50, 55, 59, 64];
    this._fingerFretRange = 4;
  }

  
  get tuning() {
    return this._tuning;
  }

  
  set tuning(value) {
    if (Array.isArray(value) && value.every(num => Number.isInteger(num))) {
      this._tuning = value;
    } else {
      throw new Error("Invalid tuning value. It must be an array of integers.");
    }
  }

  
  get fingerFretRange() {
    return this._fingerFretRange;
  }

  
  set fingerFretRange(value) {
    if (Number.isInteger(value) && value > 0) {
      this._fingerFretRange = value;
    } else {
      throw new Error("Invalid fingerFretRange value. It must be a positive integer.");
    }
  }
}

export const settings = new Settings();


File: main.js
Path: chord-factory\main.js

import { settings } from './constants.js';
import { parseNotes, removeDuplicateArrays } from './utils.js';
import { ChordFactory } from './chordfactory.js';

let totalDuration = 0;
const repetitions = 50;
let lastPlayChords;

for (let i = 0; i < repetitions; i++) {
    const startTime = performance.now();
    
    const chord = new ChordFactory("E, G, B", 4, true, settings.tuning);
    const playableChords = chord.playableChords
    
    if (i === repetitions - 1) { 
        lastPlayChords = playableChords;
    }

    const endTime = performance.now();
    totalDuration += endTime - startTime; 
}


if (lastPlayChords && lastPlayChords.length > 0) {
    lastPlayChords.sort((a, b) => a.rating - b.rating);
}

lastPlayChords.forEach((chord) => console.log(chord));


const averageTime = totalDuration / repetitions;
console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);


File: utils.js
Path: chord-factory\utils.js


export const NOTE_INDEX_MAP = {
  'C': 0, 'C#': 1, 'DB': 1, 'D': 2, 'D#': 3, 'EB': 3, 'E': 4, 'FB': 4,
  'F': 5, 'F#': 6, 'GB': 6, 'G': 7, 'G#': 8, 'AB': 8, 'A': 9, 'A#': 10,
  'BB': 10, 'B': 11, 'CB': 11
};


const NOTE_ARRAY = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];


export function noteToNumber(note) {
  
  const normalizedNote = note.toUpperCase().replace(/[\s#]+/g, __PRESERVED__31__).replace(/[\sB]+/g, 'B');
  
  return NOTE_INDEX_MAP.hasOwnProperty(normalizedNote) 
    ? NOTE_INDEX_MAP[normalizedNote] 
    : "Invalid note";
}


export function numberToNote(number) {
  return NOTE_ARRAY[number % 12];
}

export function parseNotes(input) {
  return input.toUpperCase()
    .replace(/B#/g, 'C').replace(/E#/g, 'F')
    .split(/[\s,]+/)
    .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note));
}

export function removeDuplicateArrays(arrays) {
  const uniqueArrays = new Set();
  return arrays.filter(array => {
    const serialized = JSON.stringify(array);
    if (!uniqueArrays.has(serialized)) {
      uniqueArrays.add(serialized);
      return true;
    }
    return
  });
}


File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js";

export class Chord {
    constructor(rootNote, notes, name, customRoot) {
        this.rootNote = rootNote; 
        this.notes = notes; 
        this.name = name; 
        this.customRoot = customRoot
        console.log("Constructed Chord: " + this.name + " Root: " + this.rootNote + " Notes: " + this.notes)
    }
}

export class ChordLibrary {
    constructor() {
        this.chords = [];
        this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        this.chordStructures = {
            '': { notes: [0, 4, 7], priority: 1 }, 
            'm': { notes: [0, 3, 7], priority: 2 }, 
            '7': { notes: [0, 4, 7, 10], priority: 3 }, 
            'M7': { notes: [0, 4, 7, 11], priority: 4 }, 
            'm7': { notes: [0, 3, 7, 10], priority: 5 }, 
            'mM7': { notes: [0, 3, 7, 11], priority: 18 }, 
            'sus2': { notes: [0, 2, 7], priority: 7 }, 
            'sus4': { notes: [0, 5, 7], priority: 6 }, 
            'dim': { notes: [0, 3, 6], priority: 9 }, 
            'aug': { notes: [0, 4, 8], priority: 8 }, 
            '9': { notes: [0, 4, 7, 10, 14], priority: 11 }, 
            'M9': { notes: [0, 4, 7, 11, 14], priority: 12 }, 
            'm9': { notes: [0, 3, 7, 10, 14], priority: 13 }, 
            '11': { notes: [0, 4, 7, 10, 14, 17], priority: 16 }, 
            '13': { notes: [0, 4, 7, 10, 14, 17, 21], priority: 24 }, 
            'add9': { notes: [0, 2, 4, 7], priority: 17 }, 
            'm6': { notes: [0, 3, 7, 9], priority: 14 }, 
            '6': { notes: [0, 4, 7, 9], priority: 15 }, 
            '5': { notes: [0, 7], priority: 10 }, 
            '6/9': { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6/9
            'm11': { notes: [0, 3, 7, 10, 14, 17], priority: 39 }, 
            'M7#11': { notes: [0, 4, 7, 11, 18], priority: 29 }, 
            'm7b5': { notes: [0, 3, 6, 10], priority: 19 }, 
            '+7': { notes: [0, 4, 8, 10], priority: 21 }, 
            'dim7': { notes: [0, 3, 6, 9], priority: 20 }, 
            'M7+5': { notes: [0, 4, 8, 11], priority: 28 }, 
            'mM9': { notes: [0, 3, 7, 11, 14], priority: 18 }, 
            'dimM7': { notes: [0, 3, 6, 11], priority: 22 }, 
            '7alt': { notes: [0, 4, 6, 10, 13], priority: 23 }, 
            'M13': { notes: [0, 4, 7, 11, 14, 17, 21], priority: 24 }, 
            'M11': { notes: [0, 4, 7, 11, 14, 17], priority: 25 }, 
            'M7sus4': { notes: [0, 5, 7, 11], priority: 26 }, 
            'm7#5': { notes: [0, 3, 8, 10], priority: 27 }, 
            'M#5': { notes: [0, 4, 8], priority: 28 }, 
            '9#11': { notes: [0, 4, 7, 10, 14, 18], priority: 29 }, 
            '13#11': { notes: [0, 4, 7, 10, 14, 18, 21], priority: 30 }, 
            '7b5': { notes: [0, 4, 6, 10], priority: 31 }, 
            'M7b5': { notes: [0, 4, 6, 11], priority: 32 }, 
            'M7#5': { notes: [0, 4, 8, 11], priority: 33 }, 
            'm7b9': { notes: [0, 3, 7, 10, 13], priority: 34 }, 
            '9b5': { notes: [0, 4, 6, 10, 14], priority: 34 }, 
            '9#5': { notes: [0, 4, 8, 10, 14], priority: 35 }, 
            '7b9': { notes: [0, 4, 7, 10, 13], priority: 36 }, 
            '7#9': { notes: [0, 4, 7, 10, 15], priority: 37 }, 
            '7#11': { notes: [0, 4, 7, 10, 18], priority: 38 }, 
            'm7add11': { notes: [0, 3, 7, 10, 17], priority: 39 }, 
            'add2': { notes: [0, 2, 4, 7], priority: 40 }, 
            'add4': { notes: [0, 4, 5, 7], priority: 41 }, 
            '6add9': { notes: [0, 4, 7, 9, 14], priority: 42 }, 

            '/C': { notes: [0, 4, 7], root: 0, priority: 43 }, 
            'm/C': { notes: [0, 3, 7], root: 0, priority: 44 }, 
            '/C#': { notes: [0, 4, 7], root: 1, priority: 43 }, 
            'm/C#': { notes: [0, 3, 7], root: 1, priority: 44 }, 
            '/D': { notes: [0, 4, 7], root: 2, priority: 43 }, 
            'm/D': { notes: [0, 3, 7], root: 2, priority: 44 }, 
            '/D#': { notes: [0, 4, 7], root: 3, priority: 43 }, 
            'm/D#': { notes: [0, 3, 7], root: 3, priority: 44 }, 
            '/E': { notes: [0, 4, 7], root: 4, priority: 43 }, 
            'm/E': { notes: [0, 3, 7], root: 4, priority: 44 }, 
            '/F': { notes: [0, 4, 7], root: 5, priority: 43 }, 
            'm/F': { notes: [0, 3, 7], root: 5, priority: 44 }, 
            '/F#': { notes: [0, 4, 7], root: 6, priority: 43 }, 
            'm/F#': { notes: [0, 3, 7], root: 6, priority: 44 }, 
            '/G': { notes: [0, 4, 7], root: 7, priority: 43 }, 
            'm/G': { notes: [0, 3, 7], root: 7, priority: 44 }, 
            '/G#': { notes: [0, 4, 7], root: 8, priority: 43 }, 
            'm/G#': { notes: [0, 3, 7], root: 8, priority: 44 }, 
            '/A': { notes: [0, 4, 7], root: 9, priority: 43 }, 
            'm/A': { notes: [0, 3, 7], root: 9, priority: 44 }, 
            '/A#': { notes: [0, 4, 7], root: 10, priority: 43 }, 
            'm/A#': { notes: [0, 3, 7], root: 10, priority: 44 }, 
            '/B': { notes: [0, 4, 7], root: 11, priority: 43 }, 
            'm/B': { notes: [0, 3, 7], root: 11, priority: 44 } 
        };

        this.generateChords();
    }

    generateChords() {
        Object.entries(this.chordStructures).forEach(([suffix, structure]) => {
            for (let i = 0; i < 12; i++) {
                let rootNote = i
                let customRoot = false
                let notes = structure.notes.map(interval => (i + interval) % 12);
                const chordName = `${this.noteNames[i]}${suffix}`;
                if (structure.root !== undefined) {
                    // Filter Dumb Chord Like C/C D/D
                    if (structure.root == rootNote) {
                        continue;
                    }
                    rootNote = structure.root;
                    customRoot = true;
                    notes.push(rootNote);
                }

                const chord = new Chord(rootNote, notes, chordName, customRoot);
                chord.priority = structure.priority;
                this.chords.push(chord);
            }
        });

        
        this.chords.sort((a, b) => a.priority - b.priority);
    }

    async searchChords(noteArray, rootNote, threshold = 50) {
        console.log("Searching Chords...")
        const results = [];
        noteArray = noteArray.map(note => note % 12); 
        if (rootNote) {
            rootNote = rootNote % 12

        }
        const inputNotesSet = new Set(noteArray);

        this.chords.forEach(chord => {
            let chordNotes = [...chord.notes];

            
            //Add the Root note to the Chords For Cases like A/D

            

            const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note)));
            

            const totalUniqueNotes = new Set([...chordNotes, ...noteArray]);
            


            let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100;
            

            
            if (rootNote !== null) {
                if (chord.rootNote == rootNote) {
                    
                    
                } else {
                    
                    matchPercentage *= 0.85; 
                    
                }
            } else {
                
                if (chord.customRoot == true) {
                    matchPercentage *= 0.85; 
                    

                }
            }



            if (matchPercentage >= threshold) {
                results.push(
                    new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2)))
                );
            }
        });

        
        return results.sort((a, b) => b.probability - a.probability);
    }

    getAllChords() {
        
        return this.chords;
    }

    getChordByName(name) {
        const chord = this.chords.find(chord => chord.name === name);
        if (chord) {
            
            return chord;
        } else {
            
            return null;
        }
    }


    
    transposeChord(chord, semitones) {
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        let mainChordName = chord.name;
        let bassNote = null;
    
        
        if (chord.name.includes('/')) {
            [mainChordName, bassNote] = chord.name.split('/');
        }
    
        
        const transposedRootNote = (chord.rootNote + semitones) % 12;
        const transposedNotes = chord.notes.map(note => (note + semitones) % 12);
    
        
        const originalRootNoteName = noteNames[chord.rootNote];
        const transposedRootNoteName = noteNames[transposedRootNote];
    
        
        let transposedMainChordName = mainChordName.replace(originalRootNoteName, transposedRootNoteName);
    
        
        if (originalRootNoteName.length === 1 && transposedRootNoteName.length === 2) {
            transposedMainChordName = transposedRootNoteName + mainChordName.slice(1);
        } else if (originalRootNoteName.length === 2 && transposedRootNoteName.length === 1) {
            transposedMainChordName = transposedRootNoteName + mainChordName.slice(2);
        }
    
        let transposedBassNoteName = '';
    
        if (bassNote) {
            
            const bassNoteIndex = noteNames.indexOf(bassNote);
            
            const transposedBassNote = (bassNoteIndex + semitones) % 12;
            transposedBassNoteName = noteNames[transposedBassNote];
        }
    
        
        const transposedName = transposedBassNoteName
            ? `${transposedMainChordName}/${transposedBassNoteName}`
            : transposedMainChordName;
    
        return new Chord(transposedRootNote, transposedNotes, transposedName, chord.customRoot);
    }
    
    

}



File: index.html
Path: chordviewer\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="../piano/style.css" />
    <link rel="stylesheet" href="../progression-generator/style.css" />
    <link rel="stylesheet" href="../css/output-styles.css" />
    <link rel="stylesheet" href="../css/input-styles.css" />
    <link rel="stylesheet" href="../css/slider-styles.css" />
    <link rel="stylesheet" href="../css/settings-styles.css" />
    <link rel="stylesheet" href="styles.css" />




    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div class="header">
            PianoToGuitar.com - ChordViewer
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="searchContainerWrapper">
                <div class="searchContainer">

                    <div class="searchWordContainer">
                        <div class="blackFadeBottom"></div>
                        <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                        <div class="searchChordList" id="itemsContainer">
                            <!-- Items will be populated here by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="selectedItemWrapper">

                <div class="selectedItemsHeading">
                    <div>Your Selected Chord</div>
                </div>
                <div class="selectedItemsWrapper">
                    <div class="selectedItems" id="selectedItems">
                        <!-- Dragged items will appear here -->
                    </div>

                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()"
                        height="24" viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the
                        most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>

            </div>
        </div>
</body>

</html>

File: index.js
Path: chordviewer\index.js

import DragAndDropList from '../drag-drop/script.js';
import { ChordLibrary } from "../chord-library/script.js"
import { ProgressionGenerator } from '../progression-generator/main.js';
import { settings } from '../chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {


    
    const chordLibrary = new ChordLibrary

    

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };



    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems[0]);
        
        await progressionGenerator.setProgression([event.detail.selectedItems[0]])
        await updateProgressionDynamic(soundQualityValue)
        dragAndDropList.clearSelectedList();
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);
        await updateProgressionDynamic(soundQualityValue)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue, 20);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };


    
    updateProgressionDynamic(soundQualityValue)
})


File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs');
const path = require('path');

function isHtmlOrJsFile(file) {
  return file.endsWith('.html') || file.endsWith('.js');
}

function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') {
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      fileStructure[item] = {};
      getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      fileStructure[item] = {
        path: fullPath,
        relativePath: path.join(parentPath, item),
        size: stats.size,
        lastModified: stats.mtime
      };
    }
  });
  return fileStructure;
}

function removeWhitespace(text) {
  return text.replace(/\s+/g, ' ').trim();
}

function removeComments(text) {
  const singleLineCommentPattern = /\/\/.*(?=[\n\r]|$)/g;
  const multiLineCommentPattern = /\/\*[\s\S]*?\*\
  const stringPattern = /(['"`])(?:(?!\1|\\).|\\.)*\1/g;
  const regexPattern = /\/(?!\*)[^/\\\n]+\/[gimsuy]*/g; 

  
  const preservedItems = [];
  let preservedText = text.replace(stringPattern, match => {
    preservedItems.push(match);
    return `__PRESERVED__${preservedItems.length - 1}__`;
  }).replace(regexPattern, match => {
    preservedItems.push(match);
    return `__PRESERVED__${preservedItems.length - 1}__`;
  });

  
  preservedText = preservedText.replace(singleLineCommentPattern, '');
  preservedText = preservedText.replace(multiLineCommentPattern, '');

  
  preservedText = preservedText.replace(/__PRESERVED__(\d+)__/g, (_, index) => preservedItems[Number(index)]);

  return preservedText;
}

function readAllFiles(dir, parentPath = '', removeWhitespaceSetting = false, removeCommentsSetting = false) {
  let allText = '';
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      allText += readAllFiles(fullPath, path.join(parentPath, item), removeWhitespaceSetting, removeCommentsSetting);
    } else if (isHtmlOrJsFile(item)) {
      let fileContent = fs.readFileSync(fullPath, 'utf8');
      if (removeWhitespaceSetting) {
        fileContent = removeWhitespace(fileContent);
      }
      if (removeCommentsSetting && item.endsWith('.js')) {
        fileContent = removeComments(fileContent);
      }
      allText += `File: ${item}\n`;
      allText += `Path: ${path.join(parentPath, item)}\n\n`;
      allText += fileContent + '\n\n';
    }
  });
  return allText;
}

function formatStructure(fileStructure, indent = 0) {
  let structureText = '';
  const indentString = ' '.repeat(indent);
  for (const key in fileStructure) {
    if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) {
      const { relativePath, size, lastModified } = fileStructure[key];
      structureText += `${indentString}${key} (Path: ${relativePath})\n`;
    } else {
      structureText += `${indentString}${key}/\n`;
      structureText += formatStructure(fileStructure[key], indent + 2);
    }
  }
  return structureText;
}

try {
  const targetDir = path.join(__dirname, ''); 
  const outputFilePath = path.join(__dirname, 'output.txt');
  const removeWhitespaceSetting = false; 
  const removeCommentsSetting = true; 

  
  const fileStructure = getDirectoryStructure(targetDir);

  
  const structureText = formatStructure(fileStructure);

  
  const filesText = readAllFiles(targetDir, '', removeWhitespaceSetting, removeCommentsSetting);

  
  const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`;

  
  fs.writeFileSync(outputFilePath, finalOutput);

  console.log('Folder structure and file contents have been saved to output.txt');
} catch (error) {
  console.error('Error reading directory:', error.message);
}


File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js";

export class DragAndDropItem extends Chord {
    constructor(chord, probability = -1) {
        super(chord)
        this.rootNote = chord.rootNote; 
        this.notes = chord.notes; 
        this.name = chord.name; 
        this.customRoot = chord.customRoot
        this.probability = probability
    }
}

export default class DragAndDropList {
    constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) {
        this.items = []
        this.idCounter = 0;
        items.forEach(item => {
            this.items.push(new DragAndDropItem(item))
        })

        this.dropzoneId = dropzoneId;

        this.selectedItemsEvent = new CustomEvent('selectedItemsUpdated', { bubbles: true, detail: { selectedItems: [] } });

        this.emptyMessageContainer = document.getElementById(emptyMessage);
        this.itemsContainer = document.getElementById(itemsContainer);
        this.selectedItemsContainer = document.getElementById(selectedItems);
        this.itemFilterInput = document.getElementById(itemSearch);
        this.selectedItemsArray = [];

        this.addEventListeners();
        this.populateItemsList();

        this.emptyMessage = "Click on chords to add";
        this.emptyMessageElement = document.createElement('div');
        this.emptyMessageElement.id = "DragAndDrop-EmptyMessage";

        const words = this.emptyMessage.split(' ');

        const baseElement = this.createItemElement({ name: "Sample Word" });
        baseElement.draggable = false;
        baseElement.isSelectable = false;

        words.forEach(word => {
            const clone = baseElement.cloneNode(true);
            clone.innerHTML = word;
            this.emptyMessageElement.appendChild(clone);
        });

        this.selectedItemsContainer.appendChild(this.emptyMessageElement);
    }

    addEventListeners() {
        window.addEventListener('dragover', this.handleWindowDragOver.bind(this));
        window.addEventListener('drop', this.handleWindowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('dragover', this.allowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('drop', this.handleDropOnContainer.bind(this));
        this.itemFilterInput.addEventListener('input', this.filterItems.bind(this));
    }

    handleWindowDragOver(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    handleWindowDrop(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    last100PercentItemIndex() {
        let lastIndex = -1;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].probability === 100) {
                lastIndex = i;
            }
        }
        return lastIndex;
    }

    populateItemsList() {
        const lastIndex100Percent = this.last100PercentItemIndex();
        let first100Percent = false;
        this.items.forEach((item, index) => {
            if (item.probability === 100 && !first100Percent) {
                first100Percent = true;
                const firstElement = document.createElement('div');
                firstElement.style.width = "100%";
                firstElement.innerHTML = "BEST MATCHES FOUND:";
                firstElement.style.backgroundColor = "#ffffff00";
                firstElement.style.color = "var(--light3)";
                firstElement.style.fontSize = "small";

                this.itemsContainer.appendChild(firstElement);
            }
            const itemElement = this.createItemElement(item, true);
            this.itemsContainer.appendChild(itemElement);

            if (index === lastIndex100Percent) {
                const breakElement = document.createElement('div');
                breakElement.style.width = "100%";
                breakElement.style.height = "2px";
                breakElement.style.backgroundColor = "var(--dark1)";
                breakElement.style.boxShadow = "var(--padding) 0px 0px 0px var(--dark1), calc(var(--padding)*-1) 0px 0px 0px var(--dark1)";

                this.itemsContainer.appendChild(breakElement);
            }
        });
    }

    createItemElement(item, isSelectable = false) {
        const itemElement = document.createElement('div');
        itemElement.textContent = item.name;

        itemElement.className = 'dragDropItem';
        itemElement.id = `dragDropItem-${this.idCounter++}`;

        if (item.probability > 0) {
            const probabilitySpan = document.createElement('span');
            probabilitySpan.textContent = `(${item.probability}%)`;
            probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability);
            if (item.probability === 100) {
                itemElement.style.boxShadow = '0px 0px 13px 0px rgba(0,255,0)';
                itemElement.style.fontWeight = "800";
            }

            itemElement.appendChild(probabilitySpan);
        }

        if (isSelectable) {
            itemElement.addEventListener('click', () => this.addSelectedItem(item));
        }
        return itemElement;
    }

    getBackgroundColor(probability) {
        const startColor = [255, 130, 130];
        const endColor = [230, 230, 30];
        const winnerColor = [150, 200, 0];

        probability = Math.max(50, Math.min(100, probability));

        const scaledProbability = (probability - 50) / 50;

        const adjustedProbability = Math.log10(1 + 9 * scaledProbability);

        let blendedColor = startColor.map((component, index) => {
            return Math.round(component + (endColor[index] - component) * adjustedProbability);
        });
        if (probability === 100) {
            blendedColor = winnerColor;
        }
        return `rgb(${blendedColor.join(',')})`;
    }

    createSelectedItemElement(item) {
        const selectedItemElement = document.createElement('div');
        selectedItemElement.className = 'selected-dragDropItem dragDropItem';
        selectedItemElement.draggable = true;
        selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`;
        selectedItemElement.textContent = item.name;
        selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this));
        selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this));
        selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this));
        selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this));
        selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this));
        return selectedItemElement;
    }

    removeSelectedItem(event) {
        event.target.remove();
        this.updateArrayFromList();
    }

    addSelectedItem(item) {

        this.selectedItemsArray.push(item);
        this.updateDisplayArray();
    }

    updateItems(newItems) {
        console.log("Updating Library...");
        this.clearList();
        this.items = newItems;
        this.populateItemsList();
    }

    clearList() {
        this.items = [];
        while (this.itemsContainer.firstChild) {
            this.itemsContainer.removeChild(this.itemsContainer.firstChild);
        }
    }

    clearSelectedList() {
        this.selectedItemsArray = [];
        while (this.selectedItemsContainer.firstChild) {
            this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild);
        }
        this.updateDisplayArray();
    }

    handleDropOnItemList(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) {
            droppedItemElement.remove();
            this.updateDisplayArray();
        }
    }

    handleDragStart(event) {
        event.dataTransfer.setData('text/plain', event.target.id);

        if (event.target.classList.contains('selected-dragDropItem')) {
            event.target.classList.add('dragging');
        }
    }

    handleDragOver(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.add('over');
        }
    }

    handleDragLeave(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.remove('over');
        }
    }

    handleDropReorder(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);
        if (!droppedItemElement) return;

        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            if (droppedItemElement.classList.contains('selected-dragDropItem')) {
                this.insertAtCorrectPosition(droppedItemElement, targetElement);
            }
        } else {
            if (!droppedItemElement.classList.contains('selected-dragDropItem')) {
                const chordName = droppedItemElement.textContent.split(' (')[0];
                const chord = this.items.find(item => item.name === chordName);

                if (chord) {
                    const newClone = this.createSelectedItemElement(chord);
                    this.selectedItemsContainer.appendChild(newClone);
                    this.selectedItemsArray.push(chord);
                }
            } else {
                this.selectedItemsContainer.appendChild(droppedItemElement);
                this.updateDisplayArray();
            }
        }
        this.updateDisplayArray();
    }


    handleDragEnd(event) {
        event.target.classList.remove('dragging');
        const overItems = document.querySelectorAll('.selected-dragDropItem');
        overItems.forEach(item => item.classList.remove('over'));
    }

    allowDrop(event) {
        event.preventDefault();
    }

    handleDropOnContainer(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) {
            const chordName = droppedItemElement.textContent.split(' (')[0];
            const chord = this.items.find(item => item.name === chordName);

            if (chord) {
                const newClone = this.createSelectedItemElement(chord);
                this.selectedItemsContainer.appendChild(newClone);
                this.selectedItemsArray.push(chord);
                this.updateDisplayArray();
            }
        }
    }
    insertAtCorrectPosition(droppedItemElement, targetElement) {
        const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement);
        const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement);

        if (droppedIndex < targetIndex) {
            targetElement.after(droppedItemElement);
        } else {
            targetElement.before(droppedItemElement);
        }
        targetElement.classList.remove('over');
        this.updateArrayFromList();
    }

    updateArrayFromList(){
        this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => {
            const chordName = el.textContent.split(' (')[0];
            return this.items.find(item => item.name === chordName);
        });
        this.updateDisplayArray();

    }

    updateDisplayArray() {

        this.selectedItemsContainer.innerHTML = ""

        if (this.selectedItemsArray.length == 0) {
            if (!this.emptyMessageElement.parentNode) {
                this.selectedItemsContainer.appendChild(this.emptyMessageElement);
            }
        } else {
            this.emptyMessageElement.remove();
        }

        this.selectedItemsArray.forEach(item => {
            const selectedItemElement = this.createSelectedItemElement(item);
            this.selectedItemsContainer.appendChild(selectedItemElement);
        })


        this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray];
        document.dispatchEvent(this.selectedItemsEvent);
        console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`);


    }

    filterItems() {
        const filterValue = this.itemFilterInput.value.toUpperCase();
        const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem');
        itemElements.forEach(itemElement => {
            const itemText = itemElement.textContent.toUpperCase();
            itemElement.style.display = itemText.includes(filterValue) ? '' : 'none';
        });
    }

    getArray() {
        return [...this.selectedItemsArray];
    }
}

File: index.html
Path: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="piano/style.css" />
    <link rel="stylesheet" href="progression-generator/style.css" />
    <link rel="stylesheet" href="css/output-styles.css" />
    <link rel="stylesheet" href="css/input-styles.css" />
    <link rel="stylesheet" href="css/slider-styles.css" />
    <link rel="stylesheet" href="css/settings-styles.css" />



    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./settings.js"></script>
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div id="closeSettings" onClick="toggleSettings()"></div>
        <div id="settings">
            <div class="settingsHeader">Settings</div>
            <div class="settingsContent">
                <div class="settingsItem">
                    <div class="settingsInfo">

                        <div class="settingsSubHeader">
                            <div>Guitar Tuning</div>
                        </div>
                        <div class="settingSubDescription">
                            Choose a common tuning from the dropdown or adjust each string's pitch manually with the
                            sliders.
                        </div>
                    </div>
                    <select id="settingsCommonTunings">
                        <option value="E A D G B E">Standard (E A D G B E)</option>
                        <option value="D A D G B E">Drop D (D A D G B E)</option>
                        <option value="D A D G A D">DADGAD (D A D G A D)</option>
                        <option value="D G D G B D">Open G (D G D G B D)</option>
                        <option value="D A D F# A D">Open D (D A D F# A D)</option>
                        <option value="E B E G# B E">Open E (E B E G# B E)</option>
                        <option value="C G C G C E">Open C (C G C G C E)</option>
                        <option value="D A D G B D">Double Drop D (D A D G B D)</option>
                        <option value="">Custom</option>
                    </select>
                    <div class="settingsStringTuning">
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue6">A</div>
                            <input class="settingsStringSlider string6" id="settingsString6" type="range" min="0"
                                max="12" value="0">
                        </div>
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue5">A</div>
                            <input class="settingsStringSlider string5" id="settingsString5" type="range" min="0"
                                max="12" value="0">
                        </div>
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue4">A</div>
                            <input class="settingsStringSlider string4" id="settingsString4" type="range" min="0"
                                max="12" value="0">
                        </div>
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue3">A</div>
                            <input class="settingsStringSlider string3" id="settingsString3" type="range" min="0"
                                max="12" value="0">
                        </div>
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue2">A</div>
                            <input class="settingsStringSlider string2" id="settingsString2" type="range" min="0"
                                max="12" value="0">
                        </div>
                        <div class="settingsStringWrapper">
                            <div class="settingsStringValue" id="settingsStringValue1">A</div>
                            <input class="settingsStringSlider string1" id="settingsString1" type="range" min="0"
                                max="12" value="0">
                        </div>
                    </div>

                </div>
                <div class="settingsItem">
                    <div class="settingsInfo">
                        <div class="settingsSubHeader">
                            <div>Maximum Frets</div>
                        </div>
                        <div class="settingSubDescription">
                            Set the maximum number of frets a chord can span.
                        </div>
                    </div>
                    <div class="settingsFretWrapper">
                        <div class="settingsFretSliderWrapper">
                            <div class="settingsFretBarSeparator"></div>
                            <div class="settingsFretBar selected">1</div>
                            <div class="settingsFretBarSeparator"></div>
                            <div class="settingsFretBar ">2</div>
                            <div class="settingsFretBarSeparator"></div>
                            <div class="settingsFretBar ">3</div>
                            <div class="settingsFretBarSeparator"></div>
                            <div class="settingsFretBar ">4</div>
                            <div class="settingsFretBarSeparator"></div>
                            <div class="settingsFretBar ">5</div>
                            <div class="settingsFretBarSeparator"></div>
                        </div>
                        <div id="settingsFretValue">4 Frets</div>

                    </div>
                </div>
            </div>
        </div>
        <div class="header">
            PianoToGuitar.com
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="visualPianoContainer">
                <div class="pianoMIDIWrapper">

                    <div class="pianoContainer"></div>
                    <div id="MIDIStatusDiv">
                        Initializing MIDI... </div>
                </div>
                <div class="pianoIconContainer">
                    <svg class="visualPianoIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg"
                        onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24">
                        <path
                            d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path
                            d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                    </svg>
                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
            <div class="searchWordContainer">
                <div class="blackFadeBottom"></div>
                <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                <div class="searchChordList" id="itemsContainer">
                    <!-- Items will be populated here by JavaScript -->
                </div>
            </div>
        </div>
        <div class="selectedItemsHeading">
            <div>Your Selected Progression</div>
            <div id="scaleDisplay"></div>
        </div>
        <div class="selectedItemsWrapper">
            <div class="selectedItems" id="selectedItems">
                <!-- Dragged items will appear here -->
            </div>

            <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24"
                viewBox="0 -960 960 960" width="24">
                <path fill="currentColor"
                    d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
            </svg>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionInfo">


                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to
                        the
                        most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>
            </div>
            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>

        </div>
        <div class="progression">


            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>EASY</i></div>
                    <div class="progressionInfoTextSubtitle">Get the Easiest transposed Progression
                    </div>
                    <div id="easyProgressionCapo">No Capo</div>
                </div>

            </div>
            <div class="progressionWrapper" id="easyProgressionWrapper"></div>

        </div>
</body>

</html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js';
import Piano from './piano/script.js';
import { Chord, ChordLibrary } from "./chord-library/script.js"
import MIDIAccessManager from "./midi-integration/script.js"
import { ProgressionGenerator } from './progression-generator/main.js';
import { settings } from './chord-factory/constants.js';
import { noteToNumber, numberToNote } from "./chord-factory/utils.js";



document.addEventListener('DOMContentLoaded', () => {
    function debounce(func, wait) {
        let timeout;
        return function () {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }






    
    const midiManager = new MIDIAccessManager();

    var visualPianoOctaves = 3


    
    function calculateOctaves() {
        const screenWidth = window.innerWidth;
        const maxOctaves = 3; 
        const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25);
        visualPianoOctaves = Math.min(maxOctaves, extraOctaves)
        return visualPianoOctaves;
    }



    
    const myPiano = new Piano('.pianoContainer', { octaves: calculateOctaves() });


    
    const chordLibrary = new ChordLibrary

    

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);


    var isVolumeOn = localStorage.getItem('volumeState') === 'off' ? false : true;
    const volumeIcon = document.getElementById('volumeIcon');

    updateVolumeIcon(); 

    window.toggleVolume = function () {

        if (isVolumeOn) {
            myPiano.volumeOff(); 
            isVolumeOn = false;
            localStorage.setItem('volumeState', 'off');
        } else {
            myPiano.volumeOn(); 
            isVolumeOn = true;
            localStorage.setItem('volumeState', 'on');
        }
        updateVolumeIcon();
    };

    function updateVolumeIcon() {
        if (!isVolumeOn) {
            volumeIcon.innerHTML = `<path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"/>`;
        } else {
            volumeIcon.innerHTML = `<path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"/>`;
        }
    }

    window.playPiano = function () {
        myPiano.playChord();
        console.log("Piano played");
    };


    window.clearPiano = function () {
        document.getElementById("itemSearch").value = ""
        myPiano.clearPiano();
        console.log("Piano cleared");
    };

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };

    
    window.onresize = function () {
        const newOctaves = calculateOctaves();
        myPiano.setOctaves(newOctaves); 
    };




    document.querySelector('.pianoContainer').addEventListener('notesChanged', async (e) => {
        console.log('Piano notes changed:', e.detail.notes, e.detail.rootNote);
        let items
        if (e.detail.notes.length > 0) {
            console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote)
            items = await chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50)
        } else {
            items = allChordLibraryItems
        }
        
        dragAndDropList.updateItems(items)
        
    });


    
    let actualPressedKeys = new Map(); 
    let visualPressedKeys = new Set();

    function mapNoteToVisualKey(note) {
        return note % (visualPianoOctaves * 12);
    }

    window.addEventListener('noteOn', (e) => {
        const { note } = e.detail;
        const visualKey = mapNoteToVisualKey(note);
        let count = actualPressedKeys.get(note) || 0;
        actualPressedKeys.set(note, count + 1);
        visualPressedKeys.add(visualKey);
        myPiano.activateKey(visualKey);
        updateRootNote();
    });

    window.addEventListener('noteOff', (e) => {
        const { note } = e.detail;
        if (actualPressedKeys.has(note)) {
            let count = actualPressedKeys.get(note);
            if (count > 1) {
                actualPressedKeys.set(note, count - 1);
            } else {
                actualPressedKeys.delete(note);
                
                const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note));
                if (!anyOther) {
                    visualPressedKeys.delete(mapNoteToVisualKey(note));
                    myPiano.deactivateKey(mapNoteToVisualKey(note));
                }
            }
        }
        updateRootNote();
    });

    function updateRootNote() {
        if (actualPressedKeys.size > 0) {
            
            const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b);

            
            const lowestNote = sortedNotes[0];
            const lowestNoteMod12 = lowestNote % 12;
            let setRoot = false;

            
            if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) {
                setRoot = true;
            }

            
            if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6)) {
                setRoot = true;
            }

            
            if (setRoot) {
                const visualKey = mapNoteToVisualKey(lowestNote);
                myPiano.setRootNote(visualKey);
            } else {
                myPiano.clearRootNote();
            }
        } else {
            myPiano.clearRootNote();
        }
    }


    window.addEventListener("statusUpdated", async (e) => {
        document.getElementById("MIDIStatusDiv").innerHTML = e.detail
    })


    
    window.addEventListener('notesOutput', async (e) => {
        const notes = e.detail;
        if (notes.length > 0) {
            const rootNote = Math.min(...notes);
            const searchResults = await chordLibrary.searchChords(notes, rootNote, 100);
            if (searchResults.length > 0) {
                const chord = searchResults[0];
                dragAndDropList.addSelectedItem(chord);
                
            }
        }
    });



    
    const scaleDisplay = document.getElementById("scaleDisplay")
    window.addEventListener('scaleDetected', async function (event) {
        scaleDisplay.innerHTML = event.detail.scale
    });





    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, chordLibrary, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems);
        await progressionGenerator.setProgression(event.detail.selectedItems)
        await updateProgressionDynamic(soundQualityValue)
        await updateProgressionEasy()
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);

        await updateProgressionDynamic(soundQualityValue)
        console.log(progressionGenerator)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };

    async function updateProgressionEasy() {
        let [progressionHTML, capo] = await progressionGenerator.getProgressionEasyHTML();
        document.getElementById("easyProgressionWrapper").innerHTML = "";
        document.getElementById("easyProgressionWrapper").appendChild(progressionHTML);
        document.getElementById("easyProgressionCapo").innerHTML = "Capo: "+capo+"fr";

    };






    let reloadFlag = false;

    
    window.toggleSettings = async function () {
        let settingsScreen = document.getElementById("settings");
        let closeSettings = document.getElementById("closeSettings");
    
        console.log("Toggle Settings clicked");
    
        
        settingsScreen.classList.toggle('visible');
        closeSettings.classList.toggle('visible');
    
        console.log("Settings screen visibility toggled:", settingsScreen.classList.contains('visible'));
    
        if (reloadFlag) {
            console.log("Reload flag is true, updating tuning settings.");
            localStorage.setItem('guitarTuning', JSON.stringify(settings.tuning));
    
            console.log("New tuning saved to localStorage:", settings.tuning);
    
            progressionGenerator.reloadProgression();
            console.log("Progression reloaded.");
            
            updateProgressionDynamic(soundQualityValue);
            console.log("Progression dynamic updated.");
    
            updateProgressionEasy();
            console.log("Progression easy updated.");
    
            reloadFlag = false;
        }
    };

    
    function loadTuningSettings() {
        console.log("Loading tuning settings...");
        if (localStorage.getItem('guitarTuning')) {
            settings.tuning = JSON.parse(localStorage.getItem('guitarTuning'));
            console.log("Stored tuning from localStorage:", settings.tuning);

        }
        settings.tuning.forEach((element, index) => {
            const selectElement = document.getElementById(`settingsString${index + 1}`);
            const displayElement = document.getElementById(`settingsStringValue${index + 1}`);

            displayElement.innerHTML = numberToNote(element);
            selectElement.value = element % 12
        });
    }


    
    for (let i = 0; i < 6; i++) {
        let selectElement = document.getElementById("settingsString" + (i + 1));
        if (selectElement) {
            selectElement.addEventListener('input', () => {
                let displayElement = document.getElementById(`settingsStringValue${i + 1}`);
                displayElement.innerHTML = numberToNote(parseInt(selectElement.value));
                document.getElementById('settingsCommonTunings').value = ""
                settings.tuning[i] = parseInt(selectElement.value);  
                reloadFlag = true;
                console.log(`String ${i + 1} tuning changed to:`, settings.tuning[i]);
                checkCommonTunings();  

            });
            console.log(`Event listener added for string ${i + 1}`);
        } else {
            console.warn(`Element with ID settingsString${i + 1} not found.`);
        }
    }



    function setTuning(tuning) {
        const tuningArray = tuning.split(' ').map(noteToNumber);
        settings.tuning = tuningArray;

        tuningArray.forEach((value, index) => {
            const selectElement = document.getElementById(`settingsString${index + 1}`);
            const displayElement = document.getElementById(`settingsStringValue${index + 1}`);

            selectElement.value = value;
            displayElement.innerHTML = numberToNote(value);
        });

        reloadFlag = true;
        console.log("Tuning set to:", tuningArray);
        checkCommonTunings(); 
    }

    
    document.getElementById('settingsCommonTunings').addEventListener('change', function () {
        if (this.value) {
            setTuning(this.value);
        }
    });

    
    function checkCommonTunings() {
        const dropdown = document.getElementById('settingsCommonTunings');
        const currentTuning = settings.tuning.map(numberToNote).join(' ');

        let found = false;
        for (let i = 0; i < dropdown.options.length; i++) {
            if (dropdown.options[i].value === currentTuning) {
                dropdown.value = currentTuning;
                found = true;
                break;
            }
        }

        if (!found) {
            dropdown.value = "";
        }
    }




    

    
    function setFretRange(fret) {
        
        const fretValueDisplay = document.getElementById('settingsFretValue');
        fretValueDisplay.textContent = `${fret} Frets`;

        
        settings.fingerFretRange = fret;

        
        reloadFlag = true;

        
        localStorage.setItem('fretRange', fret);

        
        const fretBars = document.querySelectorAll('.settingsFretBar');
        fretBars.forEach((bar, index) => {
            if (index < fret) {
                bar.classList.add('selected');
                bar.setAttribute('data-fret', index + 1); 

            } else {
                bar.classList.remove('selected');
                bar.removeAttribute('data-fret'); 

            }
            bar.textContent = index + 1;
        });

        console.log(`Fret range set to: ${fret} frets`);
    }

    
    const fretBars = document.querySelectorAll('.settingsFretBar');
    fretBars.forEach((bar, index) => {
        bar.addEventListener('click', () => {
            setFretRange(index + 1);
        });
        console.log(`Event listener added for fret ${index + 1}`);
    });

    
    function loadFretRangeSetting() {
        console.log("Loading fret range setting...");
        if (localStorage.getItem('fretRange')) {
            const storedFretRange = parseInt(localStorage.getItem('fretRange'));
            setFretRange(storedFretRange);
            console.log("Stored fret range from localStorage:", storedFretRange);
        } else{
            setFretRange(settings.fingerFretRange)
        }
    }

    
    loadFretRangeSetting();
    loadTuningSettings();
    checkCommonTunings()
    
    updateProgressionDynamic(soundQualityValue)
    updateProgressionEasy()
})


File: index.html
Path: midi-integration\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Note Logger</title>
</head>
<body>
<h1>MIDI Note Logger</h1>
<div id="status">Waiting for MIDI...</div>
<div id="log"></div>
<script src="script.js"></script>
</body>
</html>


File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 50;
        this.notesPlayed = new Set();
        this.activeNotes = new Set();

        if (navigator.requestMIDIAccess) {
            this.attemptMIDIAccess();
        } else {
            console.log("Web MIDI API not supported!");
        }
    }

    attemptMIDIAccess() {
        navigator.requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))
            .catch(err => {
                console.error('Error accessing MIDI devices:', err);
                this.handleRetry(err);
            });
    }

    onMIDISuccess(midiAccess) {
        this.updateStatus("MIDI ready...");
        this.midiAccess = midiAccess; 
        midiAccess.onstatechange = this.updateDeviceState.bind(this);
        this.addMIDIInputs(midiAccess.inputs);
    }

    addMIDIInputs(inputs) {
        Array.from(inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this));
    }

    onMIDIFailure() {
        this.updateStatus("");
        this.handleRetry(new Error("Initial connection failed"));
    }

    handleRetry(err) {
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            console.log(`Retrying... Attempt ${this.retryCount}`);
            setTimeout(() => this.attemptMIDIAccess(), 3000); 
        } else {
            console.error(`Failed to connect after ${this.maxRetries} attempts: ${err.message}`);
            
            this.updateStatus("");
        }
    }

    onMIDIMessage({ data: [command, note, velocity] }) {
        const eventDetail = { command, note, velocity };
        if (command === 144 && velocity > 0) {
            if (this.activeNotes.size === 0) { 
                this.notesPlayed.clear();
            }
            this.notesPlayed.add(note);
            this.activeNotes.add(note);
            window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail }));
        } else if (command === 128 || velocity === 0) {
            this.activeNotes.delete(note);
            window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail }));
            if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) {
                this.outputNotes();
            }
        }
    }

    outputNotes() {
        const uniqueNotes = Array.from(this.notesPlayed);
        console.log(uniqueNotes);
        window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes }));
    }

    updateStatus(message) {
        window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message }));
    }

    updateDeviceState({ port }) {
        const status = `MIDI: ${port.name} ${port.state}`;
        this.updateStatus(status);
        window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } }));

        if (port.state === "disconnected" || port.state === "unavailable") {
            this.handleDisconnection();
        }
    }

    handleDisconnection() {
        console.log("MIDI device disconnected. Attempting to reconnect...");
        this.attemptMIDIAccess();
    }
}

export default MIDIAccessManager;


File: script.js
Path: piano\script.js


class Piano {
    constructor(containerSelector, options = {}) {
        this.container = document.querySelector(containerSelector);
        this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50);

        this.octaves = options.octaves || 2;
        this.playedNotes = [];
        this.rootNote = null; 

        this.lastClickTime = 0;
        this.clickDelay = 300; 

        this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        this.keysPerOctave = this.layout.length;
        this.whiteKeyCount = this.layout.filter(x => x === 0).length;
        this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
        this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
        this.blackKeyHeight = 0.63;
        this.totalKeys = this.octaves * this.keysPerOctave;

        this.audioElements = [];
        this.volume = true
        this.globalVolume = 0.7;  


        this.createPiano();
        this.addKeyListeners();
    }

    volumeOff() {
        this.volume = false
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

    }

    volumeOn() {
        this.volume = true
    }

    updateVolume() {
        const activeCount = this.playedNotes.length;
        const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
        this.audioElements.forEach(audio => {
            if (!audio.paused) {  
                audio.volume = volume;
            }
        });
    }
    
    

    createPiano() {
        this.container.innerHTML = ''; 
        let whiteCounter = 0;

        for (let index = 0; index < this.totalKeys; index++) {
            let key = document.createElement("div");
            key.setAttribute('data-note', index);
            if (this.layout[index % this.keysPerOctave] === 1) {
                key.classList.add("key", "black");
                key.style.left = `${(whiteCounter * this.whiteKeyWidth) - (this.blackKeyWidth / 2)}%`;
                key.style.width = `${this.blackKeyWidth}%`;
                key.style.height = `${this.blackKeyHeight * 100}%`;
                key.style.boxSizing = "border-box";
                key.style.position = `absolute`;
            } else {
                key.classList.add("key", "white");
                key.style.boxSizing = "border-box";
                key.style.width = `${this.whiteKeyWidth}%`;
                whiteCounter++;
            }
            this.container.appendChild(key);
            this.audioElements[index] = new Audio(`../audio/${index % 24}.mp3`);
            this.audioElements[index].preload = 'auto'; 


        }
    }

    addKeyListeners() {
        this.container.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                
                let currentTime = Date.now();



                const note = key.getAttribute('data-note');

                
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    if (currentTime - this.lastClickTime > 200) {
                        this.lastClickTime = currentTime;
                        
                    }

                    this.rootNote = null;

                } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) {
                    this.playedNotes = this.playedNotes.filter(n => n !== note);
                    key.classList.remove("selectedKey");
                } else {
                    if (!this.playedNotes.includes(note)) {
                        this.playedNotes.push(note);
                    }
                    key.classList.add("selectedKey");
                    this.playSoundLong(note, 0.75);
                }
                this.updatePlayedNotesDebounced();
            });

            key.addEventListener('dblclick', (event) => {
                
                const note = key.getAttribute('data-note');
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    this.rootNote = null;
                } else {
                    if (this.rootNote !== null) {
                        this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
                    }
                    let currentTime = Date.now();
                    if (currentTime - this.lastClickTime < 500) {
                    } else {
                        this.rootNote = note;
                        if (!this.playedNotes.includes(note)) {
                            this.playedNotes.push(note);
                        }
                        key.classList.add('rootNote', 'selectedKey');
                    }

                }
                this.updatePlayedNotesDebounced();
            });
        });
    }


    debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }


    playSoundLong(index, localVolume) {
        if (this.volume) {
            const audio = this.audioElements[index];
            audio.volume = localVolume * this.globalVolume; 
            if (!audio.paused) {
                audio.currentTime = 0; 
            }
            audio.play();
        }
    }


    
    playChord() {
        this.playedNotes.sort((a, b) => a - b);
        const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1);
        this.playedNotes.forEach((note, index) => {
            const randomDelay = Math.random() * 20;
            setTimeout(() => {
                this.playSoundLong(note, localVolume);
            }, 20 * index + randomDelay);
        });
    }

    activateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (!key.classList.contains("selectedKey")) {
            key.classList.add("selectedKey");
            this.playedNotes.push(index);
            this.updatePlayedNotesDebounced();
            this.updateVolume(); 
        }
        this.playSoundLong(index, 0.75); 
    }
    
    

    deactivateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (key.classList.contains("selectedKey")) {
            key.classList.remove("selectedKey");
            this.playedNotes = this.playedNotes.filter(n => n !== index);
            this.updatePlayedNotesDebounced();
            
        }
    }
    
    setRootNote(note) {
        const key = this.container.querySelector(`.key[data-note="${note}"]`);
        if (this.rootNote !== null) {
            
            this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
        }
        this.rootNote = note; 
        key.classList.add('rootNote', 'selectedKey'); 
        if (!this.playedNotes.includes(note)) {
            this.playedNotes.push(note); 
        }
        this.updatePlayedNotesDebounced();
    }

    clearRootNote() {
        if (this.rootNote !== null) {
            const key = this.container.querySelector(`.key[data-note="${this.rootNote}"]`);
            key.classList.remove('rootNote'); 
            this.rootNote = null; 
            this.updatePlayedNotesDebounced();
        }
    }

    updatePlayedNotes() {
        const event = new CustomEvent('notesChanged', { detail: { notes: this.playedNotes, rootNote: this.rootNote } });
        console.log("Dispatching Note Change Event: " + this.playedNotes + " Root: " + this.rootNote)
        this.container.dispatchEvent(event);
    }
    clearPiano() {

        this.playedNotes = []; 
        this.rootNote = null; 
        this.container.querySelectorAll('.key.selectedKey').forEach(key => {
            key.classList.remove("selectedKey");
        });
        this.container.querySelectorAll('.key.rootNote').forEach(key => {
            key.classList.remove("rootNote");
        });
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });
        this.updatePlayedNotes();
    }

    setOctaves(newOctaves) {
        if (newOctaves !== this.octaves) {
            this.octaves = newOctaves;
            this.totalKeys = this.octaves * this.keysPerOctave;
            this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
            this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
            this.clearPiano();
            this.createPiano();
            this.addKeyListeners();
        }
    }
}

export default Piano;


File: main.js
Path: progression-generator\main.js

import { settings, BARRE_RATING } from '../chord-factory/constants.js';
import { parseNotes, removeDuplicateArrays, NOTE_INDEX_MAP } from '../chord-factory/utils.js';
import { ChordFactory } from '../chord-factory/chordfactory.js';
import { Chord } from '../chord-library/script.js';
import { numberToNote } from '../chord-factory/utils.js';
import TabGenerator from "../tab-generator/script.js"
import { TabHTML } from './tabhtml.js';


class ChordFactoryManager {
    constructor(useRoot) {
        this.chordFactoryMap = {};
        this.useRoot = useRoot;
    }

    getChordFactory(chord, key) {
        if (!this.chordFactoryMap[key]) {
            this.chordFactoryMap[key] = {};
        }

        if (this.chordFactoryMap[key][chord.name]) {
            console.log(`ChordFactory retrieved for: ${chord.name} in key: ${key}`);
            return this.chordFactoryMap[key][chord.name];
        } else {
            const chordFactory = new ChordFactory(chord, this.useRoot, settings.tuning);
            this.chordFactoryMap[key][chord.name] = chordFactory;
            console.log(`New ChordFactory created for: ${chord.name} in key: ${key}`);
            return chordFactory;
        }
    }
}


export class ProgressionGenerator {
    constructor(initialProgression = [], useRoot = true, chordLibrary, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.progression = [];
        this.progressionChords = [];
        this.useRoot = useRoot; 
        this.keyAnalysis = []
        this.chordLibrary = chordLibrary

        
        this.chordFactoryManager = new ChordFactoryManager(this.useRoot);

        
        this.initialize(initialProgression);
    }

    async initialize(initialProgression) {
        this.setProgression(initialProgression);
        this.easiestChords = await this.getEasiestChords();

    }

    addKeyAnalysis(root, keyscale, prob) {
        
        this.keyAnalysis.push({
            rootNote: root,
            scale: keyscale,
            probability: prob
        });
    }
    analyzeKey() {

        this.keyAnalysis = []
        
        
        const scaleStructures = {
            'Major': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 },  
            'Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 },  
            'Minor Pentatonic': { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 },  
            'Major Pentatonic': { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 },  
            'Harmonic Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 },  
            'Blues': { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 },  
            'Mixolydian': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 },  
            'Dorian': { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, 
            'Phrygian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, 
            'Lydian': { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, 
            'Locrian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 }  
        };


        
        let notesSet = Array(12).fill(0);
        this.progression.forEach(element => {
            element.notes.forEach(note => {
                notesSet[note]++
            })
        })
        console.log("analyzeKey - notesSet:", notesSet)





        
        notesSet.forEach((scopeNote, index) => {


            
            if (scopeNote != 0) {
                

                Object.keys(scaleStructures).forEach(key => {
                    let ammountWeight = 0.01
                    let rootWeight = 0.01
                    
                    let distanceToRootWeight = 1
                    let keyProbability = 0
                    for (let relativeNote = 0; relativeNote < 11; relativeNote++) {
                        if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) {
                            keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight))
                            distanceToRootWeight += rootWeight
                        }
                    }
                    this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority)
                })

            }
        })
        this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability);
        return
    }


    
    async setProgression(initialProgression) {
        if (!initialProgression) {
            return;
        }

        this.progressionChords = initialProgression;

        
        this.progression = initialProgression.map(chord => {
            if (chord instanceof Chord) {
                return this.chordFactoryManager.getChordFactory(chord, "dynamic");
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
                return null;
            }
        }).filter(chordFactory => chordFactory !== null);

        
        if (this.progression.length > 1) {
            this.analyzeKey()
            console.log("analyzeKey: ", this.keyAnalysis)
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: <b>" + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale + "</b>" } });
            console.log("Key Change Event: " + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale)
            window.dispatchEvent(event);
        } else {
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: ..." } });
            console.log("Key Change Event: none")
            window.dispatchEvent(event);
        }

    }

    async reloadProgression() {
        this.tuning = settings.tuning;
        this.chordFactoryManager = new ChordFactoryManager(this.useRoot);
        this.progression = [];
        this.initialize(this.progressionChords);
        console.log("ProgressionGenerator: Reloaded Progression");
    }


    getPlaceholderHTML() {
        let diagramsContainer = document.createElement('div');
        diagramsContainer.classList.add("progressionGeneratorContainer");
        diagramsContainer.style.opacity = 0.2

        let placeholderhtml = new TabHTML().generatePlaceholder(3)

        placeholderhtml.forEach(element => {
            diagramsContainer.appendChild(element);

        })
        return diagramsContainer; 
    }



    async getProgressionDynamicHTML(soundQuality = 0.5, amount = 1) {
        if (this.progression.length < 1) {
            return this.getPlaceholderHTML();
        }

        let diagramsContainer = document.createElement('div');
        diagramsContainer.classList.add("progressionGeneratorContainer");

        this.progression.forEach(chordFactory => {
            const tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);
            const chordDiagrams = tabHTML.generateHTML(soundQuality, amount);
            chordDiagrams.forEach(element => {
                diagramsContainer.appendChild(element);
            });
        });

        return diagramsContainer;
    }


    async getProgressionEasyHTML() {
        if (this.progression.length < 1) {
            return [this.getPlaceholderHTML(), 0];
        }
        const originalProgression = structuredClone(this.progressionChords); 
        let bestTransposition = 0;
        let maxOverlap = 0;

        
        const transposeChord = (chord, semitones) => {
            return this.chordLibrary.transposeChord(chord, semitones);
        };

        for (let i = 0; i < 12; i++) {
            let overlapCount = 0;
            let transposedProgression = originalProgression.map(chord => transposeChord(chord, i));

            transposedProgression.forEach(chord => {
                this.easiestChords.forEach(easyChord => {
                    if (chord.name == easyChord.name) {
                        overlapCount++;
                    }
                });
            });

            if (overlapCount > maxOverlap) {
                maxOverlap = overlapCount;
                bestTransposition = i;
            }
        }

        
        let bestTransposedProgression = originalProgression.map(chord => transposeChord(chord, bestTransposition));

        bestTransposedProgression = bestTransposedProgression.map(chord => {
            if (chord instanceof Chord) {
                return this.chordFactoryManager.getChordFactory(chord, "easy");
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
                return null;
            }
        });


        
        let diagramsContainer = document.createElement('div'); 
        diagramsContainer.classList.add("progressionGeneratorContainer");

        
        bestTransposedProgression.forEach(chordFactory => {
            
            let tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);

            
            let chordDiagrams = tabHTML.generateHTML(0, 1);

            
            chordDiagrams.forEach(element => {
                diagramsContainer.appendChild(element);
            });
        });

        
        return [diagramsContainer, bestTransposition];
    }

    async getEasiestChords() {
        const easiestChordsArray = [
            [-1, 0, 2, 2, 2, 0],  
            [-1, 0, 2, 2, 1, 0],  
            [-1, 0, 2, 0, 1, 0],  
            [-1, 2, 2, 2, 0, 0],  
            [-1, 0, 2, 0, 1, 3],  
            [-1, 3, 2, 0, 1, 0],  
            [-1, 3, 2, 0, 1, 0],   
            [-1, 3, 2, 2, 1, 3],  
            [-1, -1, 0, 2, 3, 2], 
            [-1, -1, 0, 2, 1, 2], 
            [3, 2, 0, 0, 0, 3],   
            [3, 2, 0, 0, 3, 3],   
            [0, 2, 2, 1, 0, 0],   
            [0, 2, 0, 1, 0, 0],   
            [0, 0, 2, 2, 1, 2],   
            [0, 2, 2, 0, 0, 0],   
            [1, 3, 3, 2, 1, 1],   
            [1, 1, 3, 3, 2, 1],   
            [1, 1, 3, 3, 3, 1],  
        ];

        let easiestChords = [];
        let currentChord = new Set();

        for (const element of easiestChordsArray) {
            currentChord = new Set();
            for (let i = 0; i < 6; i++) {
                if (element[i] != -1) {
                    currentChord.add((settings.tuning[i] + element[i]) % 12);
                }
            }
            let root = -1
            for (let i = 0; i < 6; i++) {
                if (element[i] != -1) {
                    root = (settings.tuning[i] + element[i]) % 12
                    break;
                }
            }
            const foundChords = await this.chordLibrary.searchChords(Array.from(currentChord), root, 100);
            if (foundChords[0]) {
                easiestChords.push(foundChords[0]);
            }
        }

        console.log("getEasiestChords:", easiestChords)
        return easiestChords
    }

    invertColor(hex) {
        
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
}

File: tabhtml.js
Path: progression-generator\tabhtml.js

import TabGenerator from "../tab-generator/script.js";
import { settings } from "../chord-factory/constants.js";

export class TabHTML {
    constructor(chordFactory = [], color = "#fff", fingerNumbers = "belowString", showOpenStrings = true) {
        this.chordFactory = chordFactory; 
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.currentIndex = 0; 
        this.maxChords = chordFactory.playableChords?.length ?? 0;
        

    }

    invertColor(hex) {
        
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }

    vibrateElement(element) {
        element.classList.add('vibrate');
        setTimeout(() => {
            element.classList.remove('vibrate');
        }, 200); 
    }

    updateChordDiagram(svgContainer, svgNameContainer, voicingInfoDiv, direction) {
        const playableChords = this.chordFactory.playableChords;
        voicingInfoDiv.innerHTML = this.currentIndex + 1 + " / " + this.maxChords
        if (this.currentIndex < playableChords.length && this.currentIndex >= 0) {
            let slideOutClass, slideInClass;

            if (direction === 'next') {
                slideOutClass = 'slide-out-left';
                slideInClass = 'slide-in-right';
            } else if (direction === 'previous') {
                slideOutClass = 'slide-out-right';
                slideInClass = 'slide-in-left';
            }

            
            svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
            svgContainer.classList.add(slideOutClass);

            
            setTimeout(() => {
                const chord = playableChords[this.currentIndex];
                const chordDiagram = new TabGenerator(
                    chord.voicing,
                    chord.fingerPositions,
                    chord.minAboveZero,
                    chord.barres,
                    this.color,
                    this.invertColor(this.color),
                    this.fingerNumbers,
                    this.showOpenStrings
                );
                const newSvg = chordDiagram.generateChordSVG();

                
                svgContainer.innerHTML = '';
                svgContainer.appendChild(newSvg);
                svgNameContainer.innerHTML = this.chordFactory.identifier;

                
                svgContainer.classList.remove(slideOutClass);
                svgContainer.classList.add(slideInClass);
                setTimeout(() => {
                    svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
                }, 100)
            }, 100); 

        }
    }

    generateHTML(soundQuality = 0.5, ammount = 1) {
        
        this.chordFactory.sortPlayableChordsByCombinedRating(soundQuality);

        let diagrams = [];

        
        for (let i = 0; i < ammount; i++) {
            if (this.chordFactory.playableChords[i]) {
                
                try {
                    this.currentIndex = i;
                    const chord = this.chordFactory.playableChords[this.currentIndex];
                    const chordDiagram = new TabGenerator(
                        chord.voicing,
                        chord.fingerPositions,
                        chord.minAboveZero,
                        chord.barres,
                        this.color,
                        this.invertColor(this.color),
                        this.fingerNumbers,
                        this.showOpenStrings
                    );
                    const svg = chordDiagram.generateChordSVG();
                    let svgInfoContainer = document.createElement('div');
                    svgInfoContainer.classList.add("progressionGeneratorSvgInfoContainer");

                    let voicingInfoContainer = document.createElement('div');
                    voicingInfoContainer.classList.add("progressionGeneratorVoicingInfoContainer");

                    let voicingInfoDiv = document.createElement('div');
                    voicingInfoDiv.innerHTML = this.currentIndex + 1 + " / " + this.maxChords;

                    let svgContainer = document.createElement('div'); 
                    svgContainer.classList.add("progressionGeneratorSvgContainer");

                    let svgNameContainer = document.createElement('div'); 
                    svgNameContainer.innerHTML = this.chordFactory.identifier;
                    svgNameContainer.classList.add("progressionGeneratorSvgChordName");

                    
                    const nextButton = document.createElement('div');
                    nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="M579-480 285-774q-15-15-14.5-35.5T286-845q15-15 35.5-15t35.5 15l307 308q12 12 18 27t6 30q0 15-6 30t-18 27L356-115q-15 15-35 14.5T286-116q-15-15-15-35.5t15-35.5l293-293Z"/></svg>';

                    nextButton.classList.add("progressionGeneratorChordButton");

                    nextButton.onclick = () => {
                        if (this.currentIndex + 1 < this.chordFactory.playableChords.length) {
                            this.currentIndex++;
                            this.updateChordDiagram(svgContainer, svgNameContainer, voicingInfoDiv, 'next');
                        } else {
                            this.vibrateElement(svgContainer);
                        }
                    };

                    
                    const prevButton = document.createElement('div');
                    prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="m142-480 294 294q15 15 14.5 35T435-116q-15 15-35 15t-35-15L57-423q-12-12-18-27t-6-30q0-15 6-30t18-27l308-308q15-15 35.5-14.5T436-844q15 15 15 35t-15 35L142-480Z"/></svg>';
                    prevButton.classList.add("progressionGeneratorChordButton");

                    prevButton.onclick = () => {
                        if (this.currentIndex > 0) {
                            this.currentIndex--;
                            this.updateChordDiagram(svgContainer, svgNameContainer, voicingInfoDiv, 'previous');
                        } else {
                            this.vibrateElement(svgContainer);
                        }
                    };

                    svgContainer.appendChild(svg);
                    voicingInfoContainer.appendChild(prevButton);
                    voicingInfoContainer.appendChild(voicingInfoDiv);
                    svgInfoContainer.appendChild(svgNameContainer);
                    voicingInfoContainer.appendChild(nextButton);
                    let diagramsContainer = document.createElement('div');
                    diagramsContainer.classList.add("progressionGeneratorDiagramsContainer");


                    diagramsContainer.appendChild(svgContainer);
                    diagramsContainer.appendChild(voicingInfoContainer);
                    diagramsContainer.appendChild(svgInfoContainer);
                    diagrams.push(diagramsContainer);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            }
        }

        return diagrams; 
    }

    generatePlaceholder(placeholderCount = 4) {
        let diagrams = [];

        for (let i = 0; i < placeholderCount; i++) {
            let voicing = [0, 0, 0, 0, 0, 0];
            let indices = new Set();
            while (indices.size < 4) {
                let index = Math.floor(Math.random() * voicing.length);
                indices.add(index);
            }

            indices.forEach(index => {
                voicing[index] = Math.floor(Math.random() * (settings.fingerFretRange + 1));
            });

            const fingerPositions = [0, 0, 0, 0, 0, 0];
            const barreSize = 0;

            const chordDiagram = new TabGenerator(
                voicing,
                fingerPositions,
                0,
                [{ fromString: 6, toString: 1, fret: barreSize }],
                this.color,
                this.invertColor(this.color),
                this.fingerNumbers,
                this.showOpenStrings
            );
            const svg = chordDiagram.generateChordSVG();

            let svgContainer = document.createElement('div');
            svgContainer.classList.add("progressionGeneratorSvgContainer");
            svgContainer.appendChild(svg);

            let voicingInfoDiv = document.createElement('div');
            voicingInfoDiv.innerHTML = `${i + 1} / ${placeholderCount}`;

            let svgNameContainer = document.createElement('div');
            svgNameContainer.classList.add("progressionGeneratorSvgChordName");
            svgNameContainer.innerHTML = `.`;

            let prevButton = document.createElement('div');
            prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="m142-480 294 294q15 15 14.5 35T435-116q-15 15-35 15t-35-15L57-423q-12-12-18-27t-6-30q0-15 6-30t18-27l308-308q15-15 35.5-14.5T436-844q15 15 15 35t-15 35L142-480Z"/></svg>';
            prevButton.classList.add("progressionGeneratorChordButton");

            let nextButton = document.createElement('div');
            nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="M579-480 285-774q-15-15-14.5-35.5T286-845q15-15 35.5-15t35.5 15l307 308q12 12 18 27t6 30q0 15-6 30t-18 27L356-115q-15 15-35 14.5T286-116q-15-15-15-35.5t15-35.5l293-293Z"/></svg>';
            nextButton.classList.add("progressionGeneratorChordButton");

            let voicingInfoContainer = document.createElement('div');
            voicingInfoContainer.classList.add("progressionGeneratorVoicingInfoContainer");
            voicingInfoContainer.appendChild(prevButton);
            voicingInfoContainer.appendChild(voicingInfoDiv);
            voicingInfoContainer.appendChild(nextButton);

            let diagramContainer = document.createElement('div');
            diagramContainer.classList.add("progressionGeneratorDiagramsContainer");
            diagramContainer.appendChild(svgContainer);
            diagramContainer.appendChild(voicingInfoContainer);
            diagramContainer.appendChild(svgNameContainer);

            diagrams.push(diagramContainer);
        }

        return diagrams; 
    }
}

File: settings.js
Path: settings.js

import { settings } from "./chord-factory/constants.js";
import { noteToNumber, numberToNote } from "./chord-factory/utils.js";

document.addEventListener('DOMContentLoaded', () => {

})

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Diagram Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>Guitar Chord Diagram Generator</h1>
        <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input">
        <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)">
        <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button>
        <div id="diagram" class="diagram-container"></div>
    </div>
    <script type="module">
        import TabGenerator from "./script.js"

        const fingerPositions = ['-1', '5', '6', '5', '0', '0'];
        const fingerNumbers = ['1', '1', '2', '1', '', ''];
        const barre = 10;
        const minAboveZero = 15
        const barres = [[5,1,3], [3,0,5]]
        const color = "#fff";
        const textColor = "#000";
        const showOpenStrings = true;

        try {
            const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, minAboveZero, barres, color, textColor, 'belowString', showOpenStrings);
            const svg = chordDiagram.generateChordSVG();
            document.getElementById('diagram').appendChild(svg);
        } catch (error) {
            console.error('Error generating chord diagram:', error);
        }
    </script>
</body>

</html>

File: script.js
Path: tab-generator\script.js


class TabGenerator {
    
    constructor(fingerPositions, fingerNumbers, minAboveZero = 0, barres = [], elementColor = "#000", textColor = "#fff", numberPosition = 'onNote', showOpenStrings) {

        if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) {
            console.error("Error: fingerPositions must be an array of length 6.");
        }
        if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) {
            console.error("Error: fingerNumbers must be an array of length 6 or null.");
        }
        if (typeof elementColor !== 'string') {
            console.error("Error: elementColor must be a string.");
        }
        if (typeof textColor !== 'string') {
            console.error("Error: textColor must be a string.");
        }
        if (numberPosition !== 'onNote' && numberPosition !== 'belowString') {
            console.error("Error: numberPosition must be either 'onNote' or 'belowString'.");
        }
        if (typeof showOpenStrings !== 'boolean') {
            console.error("Error: showOpenStrings must be a boolean.");
        }
        
        this.fingerPositions = fingerPositions;
        this.fingerNumbers = fingerNumbers;
        this.barres = barres;               
        this.color = elementColor; 
        this.textColor = textColor;       
        this.numberPosition = numberPosition; 
        this.showOpenStrings = showOpenStrings; 
        this.maxFret = Math.max(...fingerPositions)



        
        this.topSpacing = 25;
        this.topBarHeight = 7;
        this.fretSpacing = 25;
        this.stringSpacing = 25;
        this.paddingLeft = 10;
        this.barreSidesOverflow = 10;
        this.stringOverflowBotom = 10;
        this.fretCount = 4;
        this.circleRadius = 10;
        this.infoPadding = 10;
        this.openStringRadius = 7;


        
        this.offset = 1
        if (this.maxFret > this.fretCount){
            this.offset = minAboveZero
        }

        
        this.width = 185;
        this.height = 145
    }

    generateChordSVG() {
        const svgAttributes = {
            width:  this.width,
            height: this.height,
            viewBox: "0 0 " +  this.width + " " +this.height  
        };
        const svg = this.createSVGElement('svg', svgAttributes);
        this.drawDiagramComponents(svg);
        return svg;
    }

    drawDiagramComponents(svg) {
        this.drawTopBar(svg);
        if (this.barres) {
            this.barres.forEach(element => {
                this.drawBarre(svg, element[0], element[1], element[2]);

            });
        }
        this.drawStrings(svg);
        this.drawFrets(svg);
        if (this.showOpenStrings) {
            this.drawOpenStrings(svg);
        }
        this.drawNotes(svg);
        this.drawMuteIndicators(svg);
        this.drawFretHeight(svg)
    }


    createSVGElement(tag, attributes) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const attr in attributes) {
            element.setAttribute(attr, attributes[attr]);
        }
        return element;
    }

    drawTopBar(svg) {
        const topBar = this.createSVGElement('rect', {
            x: this.paddingLeft,
            y: this.topSpacing,
            width: this.stringSpacing * 5,
            height: this.topBarHeight,
            fill: this.color,
            stroke: this.color,
            'stroke-width': '2'
        });
        svg.appendChild(topBar);
    }

    drawStrings(svg) {
        for (let i = 0; i < 6; i++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft + i * this.stringSpacing, y1: this.topSpacing,
                x2: this.paddingLeft + i * this.stringSpacing, y2: this.fretSpacing * this.fretCount + this.topSpacing + this.stringOverflowBotom + this.topBarHeight,
                stroke: this.color, 'stroke-width': ((6 - i) / 3) + 1
            });
            svg.appendChild(line);
        }
    }

    drawFrets(svg) {
        for (let j = 0; j < this.fretCount + 1; j++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft, y1: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                x2: this.paddingLeft + this.stringSpacing * 5, y2: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                stroke: this.color, 'stroke-width': '2'
            });
            svg.appendChild(line);
        }
    }

    drawNotes(svg) {
        for (let string = 0; string < 6; string++) {
            if (this.fingerPositions[string] > 0) {
                let fret = parseInt(this.fingerPositions[string]);
                if (fret > 0) {
                    let position = this.topSpacing + this.topBarHeight + ((fret) - this.offset) * this.fretSpacing - this.circleRadius / 2;
                    let circle = this.createSVGElement('circle', {
                        cx: this.paddingLeft + string * this.stringSpacing, cy: position + this.topSpacing - 8,
                        r: this.circleRadius, fill: this.color
                    });
                    svg.appendChild(circle);

                    if (this.fingerNumbers && this.fingerNumbers[string]) {
                        const textPositionY = this.numberPosition === 'onNote' ? position + this.topSpacing : this.topSpacing + this.topBarHeight + (this.fretCount + 1) * this.fretSpacing + this.stringOverflowBotom;
                        const text = this.createSVGElement('text', {
                            x: this.paddingLeft + string * this.stringSpacing,
                            y: textPositionY,
                            'font-family': 'Arial',
                            'font-size': '20',
                            'font-weight': '500',
                            fill: this.numberPosition === 'onNote' ? this.textColor : this.color,
                            'text-anchor': 'middle'
                        });
                        text.textContent = this.fingerNumbers[string];
                        svg.appendChild(text);
                    }
                }
            }
        }
    }

    drawMuteIndicators(svg) {
        const radius = 10
        const height = radius * Math.sqrt(2)

        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] == -1) {
                const line1 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - height - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                const line2 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - height - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(line1);
                svg.appendChild(line2);
            }
        }
    }

    drawOpenStrings(svg) {
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] === '0') {
                const circle = this.createSVGElement('circle', {
                    cx: this.paddingLeft + i * this.stringSpacing,
                    cy: this.topSpacing - this.infoPadding - this.openStringRadius,
                    r: this.openStringRadius,
                    fill: 'none',
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(circle);
            }
        }
    }

    drawBarre(svg, barreFret, barreStartString, barreEndString) {
        if (barreFret != 0) {
            barreFret = barreFret - this.offset 
            const barreWidth = barreEndString - barreStartString
            const barreHeight = 10;
            const barreX = this.paddingLeft - this.barreSidesOverflow + barreStartString * this.stringSpacing;
            const barreY = barreFret * this.fretSpacing + this.topSpacing + this.topBarHeight + (this.fretSpacing / 2) - barreHeight / 2;

            const rect = this.createSVGElement('rect', {
                x: barreX, y: barreY,
                width: barreWidth * this.stringSpacing + 2 * this.barreSidesOverflow, height: barreHeight,
                rx: '5', ry: '5',
                fill: this.color
            });
            svg.appendChild(rect);


        }
    }

    drawFretHeight(svg) {
        if (this.offset  > 1) {
            const text = this.createSVGElement('text', {
                x:this.paddingLeft + this.stringSpacing*5 + this.infoPadding, y: this.topSpacing + this.topBarHeight + this.fretSpacing * 0.5,
                'font-family': 'Arial', 'font-size': '20', fill: this.color,
                'text-anchor': 'left',
                "alignment-baseline": "central"
            });
            text.textContent = this.offset  + "fr";
            svg.appendChild(text);
        }
    }
}

export default TabGenerator;

