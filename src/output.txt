Directory Structure:
audio/
chord-factory/
  CC.js (Path: chord-factory\CC.js)
  CF.js (Path: chord-factory\CF.js)
  chordfactory.js (Path: chord-factory\chordfactory.js)
  chordvoicing.js (Path: chord-factory\chordvoicing.js)
  constants.js (Path: chord-factory\constants.js)
  main.js (Path: chord-factory\main.js)
  utils.js (Path: chord-factory\utils.js)
chord-library/
  script.js (Path: chord-library\script.js)
chordviewer/
  index.html (Path: chordviewer\index.html)
  index.js (Path: chordviewer\index.js)
createChatGPTContext.js (Path: createChatGPTContext.js)
css/
drag-drop/
  script.js (Path: drag-drop\script.js)
index.html (Path: index.html)
index.js (Path: index.js)
midi-integration/
  index.html (Path: midi-integration\index.html)
  script.js (Path: midi-integration\script.js)
piano/
  script.js (Path: piano\script.js)
progression-generator/
  main.js (Path: progression-generator\main.js)
  svg/
  tabhtml.js (Path: progression-generator\tabhtml.js)
svg/
tab-generator/
  index.html (Path: tab-generator\index.html)
  script.js (Path: tab-generator\script.js)

File Contents:
File: CC.js
Path: chord-factory\CC.js

let settings
// ChordCombinationsWorker.js
onmessage = function (e) {
    if (e.data.type === 'settingsUpdate') {
        settings = e.data.newSettings;
        //console.warn("settingsUpdate:", settings)

    } else {
        const { fingerPositions } = e.data;
        //console.warn("ChordCombinationsWorker called:", fingerPositions)
        const chords = generateAllChordCombinations(fingerPositions);
        postMessage(chords);
    }
};



function generateAllChordCombinations(fingerPositions) {
    //console.warn("Settings at generateAllChordCombinations", settings)

    // Start the timer to measure function execution time
    const startTime = performance.now();

    // Array to keep track of temporary indexes where -1 is inserted
    let temporaryMutedIndexes = [];
    // Array to store all generated chord combinations
    let generatedChords = [];

    // Initialize maskScope with 6 empty arrays, one for each string
    let maskScope = Array.from({ length: 6 }, () => []);
    let preScope = [];
    let trail = []
    let trailIndexes = []

    // Array to store the current index in fingerPositions for each string
    const fingerIndexStorage = Array(6).fill(0);

    // Array to store the length of valid positions for each string minus one
    let fingerIndexLength = [];
    fingerPositions.forEach((element, index) => {
        fingerIndexLength[index] = element.length - 1;
    });


    // Iterate over all possible frets from -1 (muted) to 12
    for (let fret = -1; fret < 13; fret++) {
        preScope = [];
        temporaryMutedIndexes = [];

        // Reduce the Trail for each Trail Index by 1
        if (settings.trailing) {
            trailIndexes.forEach((string, index, object) => {
                trail[string] -= 1;

                // Check if the current value is below the allowable range
                if (trail[string] <= (settings.fingerFretRange * -1)) {
                    trail[string] = 0;

                    // Remove the current string from trailIndexes if the value is out of the range
                    object.splice(index, 1);
                }
            });
        }

        // Iterate over each string of the guitar
        for (let string = 0; string < 6; string++) {
            //console.log("maskScope before", structuredClone(maskScope));

            //console.log("scope before removal", structuredClone(maskScope))
            // Remove positions in maskScope that are less than the current fret
            for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) {
                if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) {
                    maskScope[string].splice(validPosition, 1);
                    //Add the position to the Trailing Elements
                    if (settings.trailing) {
                        trail[string] = -1
                    }
                }
            }
            //console.log("scope after removal", structuredClone(maskScope))

            // If maskScope is empty for the current string, add it to preScope
            if (maskScope[string].length == 0) {
                // only Push the element to the PreScope If its not trailing
                if (!trail[string] || !settings.trailing) {
                    preScope.push(string);
                }
            }
        }

        // Populate maskScope for strings in preScope
        preScope.forEach((string) => {
            if (fingerIndexStorage[string] < fingerIndexLength[string]) {
                // If the next valid position is within the allowed fret range
                if (fingerPositions[string][fingerIndexStorage[string]] < fret + settings.fingerFretRange) {
                    // Do nothing as the position will be added in the next loop
                } else {
                    // Add -1 (muted) to maskScope if the position is out of range
                    maskScope[string].push(-1);
                    temporaryMutedIndexes.push(string);
                }
            }
        });

        // Insert new elements into maskScope
        for (let string = 0; string < 6; string++) {
            // If there are valid positions left for the current string
            if (fingerIndexStorage[string] < fingerIndexLength[string]) {
                // If the next valid position is within the allowed fret range
                if (fingerPositions[string][fingerIndexStorage[string]] < fret + settings.fingerFretRange) {
                    //console.log("generateAllChordCombinations2 Pushing into maskScope[string], string, fingerPositions[string][fingerIndexStorage[string]] ", maskScope[string], string, fingerPositions[string][fingerIndexStorage[string]]);
                    //console.log("fret, string", fret, string);
                    maskScope[string].push(fingerPositions[string][fingerIndexStorage[string]]);
                    //console.log("maskScope after insertion", structuredClone(maskScope));

                    // Generate all combinations of positions in maskScope
                    for (let pos1 of maskScope[(string + 1) % 6]) {
                        for (let pos2 of maskScope[(string + 2) % 6]) {
                            for (let pos3 of maskScope[(string + 3) % 6]) {
                                for (let pos4 of maskScope[(string + 4) % 6]) {
                                    for (let pos5 of maskScope[(string + 5) % 6]) {
                                        let newVoicing = [];
                                        newVoicing[string] = fingerPositions[string][fingerIndexStorage[string]];
                                        newVoicing[(string + 1) % 6] = pos1;
                                        newVoicing[(string + 2) % 6] = pos2;
                                        newVoicing[(string + 3) % 6] = pos3;
                                        newVoicing[(string + 4) % 6] = pos4;
                                        newVoicing[(string + 5) % 6] = pos5;

                                        //console.log("NEW: ", structuredClone(newVoicing));
                                        generatedChords.push(newVoicing);
                                    }
                                }
                            }
                        }
                    }

                    // Move to the next valid position for the current string
                    fingerIndexStorage[string]++;



                } else {
                    // Break because the element found is too big to be inserted into the maskScope
                }
            } else {
                // Break because there are no more elements left in the Array
            }
        }
        // Remove the temporary -1 values added to maskScope
        for (let i of temporaryMutedIndexes) {
            maskScope[i].pop();
        }
    }

    // Track end time and calculate the time taken
    const endTime = performance.now();
    const timeTaken = endTime - startTime;
    console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds");

    return generatedChords;
}

File: CF.js
Path: chord-factory\CF.js

import { MAX_FRETS } from './constants.js';

let settings;
self.onmessage = (e) => {
  if (e.data.type === 'settingsUpdate') {
    settings = e.data.newSettings;
    //console.warn("settingsUpdate:", settings)

  } else {
    const { allChords, notes, root } = e.data;
    filterPlayableChords(allChords, notes, root);
  }
};

function filterPlayableChords(allChords, notes, rootNote) {
  //console.warn("Settings at filterPlayableChords", settings)

  //console.error(allChords)
  const startTime = performance.now();
  let playableChordsVoicingSet = new Set();
  let totalChordVoicingTime = 0; // Initialize a variable to accumulate time for ChordVoicing creation

  // Pre-create and reuse these objects - Testing Showed This is faster than Creating them newly
  let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => []));
  let barreClassesUsed = new Set();
  let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0);
  let minAboveZero = 99;
  let mutingTillRoot = true;
  let touchedSet = new Set();
  let barres = []
  let touchedIndices = [];
  let fingerPositionsCounter = 0
  let fingerPositions = [-1, -1, -1, -1, -1, -1]
  let fingerPositionsAmmount = 0
  let actuallyPlayedNotes = [-1, -1, -1, -1, -1, -1]


  allChords.forEach(voicing => {
    minAboveZero = 99;
    mutingTillRoot = true;

    // Reset values for each iteration
    barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0));
    barreClassesUsed.clear();
    touchedSet.clear()
    barreSeparatorIndex.fill(0);
    barres = []
    touchedIndices = [];
    fingerPositionsCounter = 0
    fingerPositions = [-1, -1, -1, -1, -1, -1]
    fingerPositionsAmmount = 0



    //Calcualte the Real played Notes
    for (let i = 0; i < 6; i++) {
      if (voicing[i] >= 0) {
        actuallyPlayedNotes[i] = (voicing[i] + settings.tuning[i])
      } else {
        actuallyPlayedNotes[i] = voicing[i]
      }
    }


    for (let string = 0; string < 6; string++) {
      //Mute Strings That are not the Root Note
      if (settings.startWithRoot && mutingTillRoot) {
        if (actuallyPlayedNotes[string] == -1) {
          // Do Nothing
        } else if (((actuallyPlayedNotes[string]) % 12) != rootNote) {
          // Mute The String
          voicing[string] = -1;
        } else {
          mutingTillRoot = false;
        }
      }

      //Count Total Fingers Used in this voicing.
      if (voicing[string] > 0) {
        fingerPositionsAmmount++
        if (voicing[string] < minAboveZero) {
          minAboveZero = voicing[string];
        }
      }


    }
    // Check if the voicing is already in the set
    let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5];
    if (playableChordsVoicingSet.has(voicingString)) {
      //console.log("Allready Has Voicing, Skipping...")
      return; // Skip processing if voicing is already in the set
    }

    //Remove Chords Below two fingers used.
    if (fingerPositionsAmmount < 2) {
      return
    }

    //Take a Look at the Ammount of fingers Required. If is less than 5 no barre needs to be caluclated.
    if (fingerPositionsAmmount > 4) {

      for (let string = 0; string < 6; string++) {
        //Mute Strings That are not the Root Note




        //Now, Place the Strings in their Corresponding barreClass
        if (voicing[string] >= 0) {

          barreClassesUsed.forEach((index) => {
            if (voicing[string] < index) {
              barreSeparatorIndex[index] += 1;
            }
          });

          barreClassesUsed.add(voicing[string]);
          barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string);
          const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`;
          if (!touchedSet.has(newIndex)) {
            touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]);
            touchedSet.add(newIndex);
          }
        }
      }


      // Sort touchedIndices from lowest to highest fret
      touchedIndices.sort(([fretA], [fretB]) => fretA - fretB);
      //console.log(touchedIndices)
      touchedIndices.forEach(([fret, index]) => {
        if (barreClass[fret][index].length > 0) {
          if (barreClass[fret][index].length > 1 && fret != 0) {
            barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])])
            fingerPositionsCounter++
            barreClass[fret][index].forEach(element => {
              fingerPositions[element] = fingerPositionsCounter
            })

          } else if (fret != 0) {
            fingerPositionsCounter++
            fingerPositions[barreClass[fret][index]] = fingerPositionsCounter
          }

        }

      });


      //Check if 5 Finger are still used, If so, Remove the CHord.
      if (fingerPositionsCounter > 4) {
        return
      }
    } else {
      //console.log("SkippedBarre Because The Fingers are to less")
      //No Barre Requred, so we can just calulate Where each finger goes.
      for (let fret = 0; fret < settings.fingerFretRange; fret++) {
        for (let string = 0; string < 6; string++) {
          if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) {
            fingerPositionsCounter++
            fingerPositions[string] = fingerPositionsCounter

          }
        }
      }
    }

    let fingersused = Math.max(...fingerPositions)
    //filter one String Chords
    if (fingersused < 2) {
      return
    }
    //IF minabove Zero Was note set, Set it to zero
    if (minAboveZero == 99) {
      minAboveZero = 0
    }

    const chordVoicingStartTime = performance.now();

    self.postMessage({
      voicing,
      fingerPositions,
      barres,
      minAboveZero,
      fingersused,
      notes,
      root: settings.startWithRoot ? rootNote : -1,
      actuallyPlayedNotes
    });

    const chordVoicingEndTime = performance.now();
    const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime;
    totalChordVoicingTime += chordVoicingTimeTaken;

    playableChordsVoicingSet.add(voicingString);

  });
  self.postMessage({ status: 'finished' });

  const endTime = performance.now();

  // Calculate the time taken
  const totalTimeTaken = endTime - startTime;

  console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds");
  console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds");

}


File: chordfactory.js
Path: chord-factory\chordfactory.js

import { settings, MAX_FRETS } from './constants.js';
import { ChordVoicing } from './chordvoicing.js';


export class ChordFactory {
  constructor(chord, startWithRoot = true, tuning = settings.tuning) {


   //CREATE Workers and Updtae Their Settings, as the Workers do not share the same context as the main Thread
    this.ChordCombinationsWorker = new Worker(new URL('./CC.js', import.meta.url), { type: 'module' });
    this.ChordFilteringWorker = new Worker(new URL('./CF.js', import.meta.url), { type: 'module' });
    this.ChordFilteringWorker.postMessage({ type: 'settingsUpdate', newSettings: settings });
    this.ChordCombinationsWorker.postMessage({ type: 'settingsUpdate', newSettings: settings });



    console.log("ChordFactory Recieved Notes: ", chord.notes)
    this.identifier = chord.name
    this.notes = chord.notes;
    this.root = chord.rootNote
    this.tuning = tuning;
    this.fingerPositions = this.calculateValidFingerPositions();
    this.playableChordsLoaded = new Promise(resolve => {
      this.resolvePlayableChords = resolve;
    });






    this.ChordCombinationsWorker.postMessage({ fingerPositions: this.fingerPositions });
    this.ChordCombinationsWorker.onmessage = (e => {
      this.allChords = e.data;
      this.initializeChordFilteringWorker(); // Initialize the new worker here
    }).bind(this);

  }

  initializeChordFilteringWorker() {

    this.ChordFilteringWorker.postMessage({
      allChords: structuredClone(this.allChords),
      notes: this.notes,
      root: this.root
    });

    this.playableChords = [];
    this.ChordFilteringWorker.onmessage = (e => {
      if (e.data.status === 'finished') {
        this.resolvePlayableChords();  // Resolve the promise when chords are ready
        this.terminateWorkers();
      } else {
        const { voicing, fingerPositions, barres, minAboveZero, fingersused, notes, root, actuallyPlayedNotes } = e.data;
        let newVoicing = new ChordVoicing(
          voicing,
          fingerPositions,
          barres,
          minAboveZero,
          fingersused,
          notes,
          root,
          actuallyPlayedNotes
        );
        this.playableChords.push(newVoicing);
      }
    }).bind(this);
  }


  terminateWorkers() {
    if (this.ChordCombinationsWorker) {
      this.ChordCombinationsWorker.terminate();
      this.ChordCombinationsWorker = null;
    }
    if (this.ChordFilteringWorker) {
      this.ChordFilteringWorker.terminate();
      this.ChordFilteringWorker = null;
    }
  }


  getFretSpanStatistics() {
    let spanCounts = {};  // Object to store the count of each span

    // Iterate over all chord combinations
    this.allChords.forEach(chord => {
      // Filter out muted and open strings, keeping only fretted notes
      const frets = chord.filter(fret => fret > 0);
      if (frets.length > 1) { // Ensure there's more than one fretted note to calculate a span
        const minFret = Math.min(...frets);
        const maxFret = Math.max(...frets);
        const span = maxFret - minFret;

        // Update the count for the calculated span
        if (span in spanCounts) {
          spanCounts[span] = spanCounts[span] + 1;
        } else {
          spanCounts[span] = 1;
        }
      }
    });

    // Log the statistics for review
    console.log("Fret Span Statistics:", spanCounts);
    return spanCounts;
  }


  calculateValidFingerPositions() {
    const fingerPositions = [];

    for (let stringIndex of this.tuning) {
      const positions = [];
      for (let chordIndex of this.notes) {
        const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12);
        // Add each valid position only if it's not already in the array
        validPositions.forEach(position => {
          if (!positions.includes(position)) {
            positions.push(position);
          }
        });
      }
      // Add -1 for muting if necessary, ensuring it's not already present
      if (settings.mutePermutations && !positions.includes(-1)) {
        positions.push(-1);
      }
      // Sort the positions from lowest to highest
      positions.sort((a, b) => a - b);
      fingerPositions.push(positions);
    }

    return fingerPositions;
  }


  getValidFretPositionsForNote(noteIndex, stringIndex) {
    const baseFret = (noteIndex - stringIndex + 120) % 12;
    return [baseFret, baseFret + 12];
  }

  cartesianProduct(arrays) {
    return arrays.reduce((acc, curr) => {
      return acc.flatMap(a => curr.map(b => [...a, b]));
    }, [[]]);
  }





  filterPlayableChords(allChordsCopy) {
    const startTime = performance.now();
    let playableChordsVoicingSet = new Set();
    let playableChordsArray = []
    let totalChordVoicingTime = 0; // Initialize a variable to accumulate time for ChordVoicing creation

    // Pre-create and reuse these objects - Testing Showed This is faster than Creating them newly
    let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => []));
    let barreClassesUsed = new Set();
    let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0);
    let minAboveZero = 99;
    let mutingTillRoot = true;
    let touchedSet = new Set();
    let barres = []
    let touchedIndices = [];
    let fingerPositionsCounter = 0
    let fingerPositions = [-1, -1, -1, -1, -1, -1]
    let fingerPositionsAmmount = 0
    let actuallyPlayedNotes = [-1, -1, -1, -1, -1, -1]


    allChordsCopy.forEach(voicing => {
      minAboveZero = 99;
      mutingTillRoot = true;

      // Reset values for each iteration
      barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0));
      barreClassesUsed.clear();
      touchedSet.clear()
      barreSeparatorIndex.fill(0);
      barres = []
      touchedIndices = [];
      fingerPositionsCounter = 0
      fingerPositions = [-1, -1, -1, -1, -1, -1]
      fingerPositionsAmmount = 0



      //Calcualte the Real played Notes
      for (let i = 0; i < 6; i++) {
        if (voicing[i] >= 0) {
          actuallyPlayedNotes[i] = (voicing[i] + settings.tuning[i])
        } else {
          actuallyPlayedNotes[i] = voicing[i]
        }
      }


      for (let string = 0; string < 6; string++) {
        //Mute Strings That are not the Root Note
        if (settings.startWithRoot && mutingTillRoot) {
          if (actuallyPlayedNotes[string] == -1) {
            // Do Nothing
          } else if (((actuallyPlayedNotes[string]) % 12) != this.root) {
            // Mute The String
            voicing[string] = -1;
          } else {
            mutingTillRoot = false;
          }
        }

        //Count Total Fingers Used in this voicing.
        if (voicing[string] > 0) {
          fingerPositionsAmmount++
          if (voicing[string] < minAboveZero) {
            minAboveZero = voicing[string];
          }
        }


      }
      // Check if the voicing is already in the set
      let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5];
      if (playableChordsVoicingSet.has(voicingString)) {
        //console.log("Allready Has Voicing, Skipping...")
        return; // Skip processing if voicing is already in the set
      }

      //Remove Chords Below two fingers used.
      if (fingerPositionsAmmount < 2) {
        return
      }

      //Take a Look at the Ammount of fingers Required. If is less than 5 no barre needs to be caluclated.
      if (fingerPositionsAmmount > 4) {

        for (let string = 0; string < 6; string++) {
          //Mute Strings That are not the Root Note




          //Now, Place the Strings in their Corresponding barreClass
          if (voicing[string] >= 0) {

            barreClassesUsed.forEach((index) => {
              if (voicing[string] < index) {
                barreSeparatorIndex[index] += 1;
              }
            });

            barreClassesUsed.add(voicing[string]);
            barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string);
            const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`;
            if (!touchedSet.has(newIndex)) {
              touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]);
              touchedSet.add(newIndex);
            }
          }
        }


        // Sort touchedIndices from lowest to highest fret
        touchedIndices.sort(([fretA], [fretB]) => fretA - fretB);
        //console.log(touchedIndices)
        touchedIndices.forEach(([fret, index]) => {
          if (barreClass[fret][index].length > 0) {
            if (barreClass[fret][index].length > 1 && fret != 0) {
              barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])])
              fingerPositionsCounter++
              barreClass[fret][index].forEach(element => {
                fingerPositions[element] = fingerPositionsCounter
              })

            } else if (fret != 0) {
              fingerPositionsCounter++
              fingerPositions[barreClass[fret][index]] = fingerPositionsCounter
            }

          }

        });


        //Check if 5 Finger are still used, If so, Remove the CHord.
        if (fingerPositionsCounter > 4) {
          return
        }
      } else {
        //console.log("SkippedBarre Because The Fingers are to less")
        //No Barre Requred, so we can just calulate Where each finger goes.
        for (let fret = 0; fret < settings.fingerFretRange; fret++) {
          for (let string = 0; string < 6; string++) {
            if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) {
              fingerPositionsCounter++
              fingerPositions[string] = fingerPositionsCounter

            }
          }
        }
      }

      let fingersused = Math.max(...fingerPositions)
      //filter one String Chords
      if (fingersused < 2) {
        return
      }
      //IF minabove Zero Was note set, Set it to zero
      if (minAboveZero == 99) {
        minAboveZero = 0
      }

      const chordVoicingStartTime = performance.now();

      let newVoicing = new ChordVoicing(
        voicing,
        fingerPositions,
        barres,
        minAboveZero,
        fingersused,
        this.notes,
        settings.startWithRoot ? this.root : -1,
        actuallyPlayedNotes
      );

      const chordVoicingEndTime = performance.now();
      const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime;
      totalChordVoicingTime += chordVoicingTimeTaken;

      playableChordsVoicingSet.add(voicingString);
      playableChordsArray.push(newVoicing);
      //console.log("filterPlayableChords2 - voicing, barres", voicing, barres);
      //Now Check For each Barre Class Starting at MinAboveZero...

    });
    const endTime = performance.now();

    // Calculate the time taken
    const totalTimeTaken = endTime - startTime;

    console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds");
    console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds");
    return playableChordsArray
  }



  /**
   * Sorts the playable chords by a combined rating based on sound quality and 
   * playability. The combined rating is calculated using a weighted sum of 
   * the sound quality rating and the playability rating.
   * 
   * @param {number} soundWeight - A value between 0 and 1 that determines the weight 
   * given to the sound quality rating. The weight given to the playability rating 
   * will be (1 - soundWeight).
   * 
   * Usage example:
   * ```javascript
   * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning);
   * chordFactory.sortPlayableChordsByCombinedRating(0.7);
   * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating
   * ```
   * 
   * @throws {Error} If `soundWeight` is not a number between 0 and 1.
   */
  async sortPlayableChordsByCombinedRating(soundWeight = 0) {
    if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) {
      throw new Error("soundWeight must be a number between 0 and 1.");
    }

    await this.playableChordsLoaded;  // Wait for the playable chords to be loaded

    console.log("Sorting...")
    this.playableChords.sort((a, b) => {
      let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight));
      let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight));
      return bCombinedRating - aCombinedRating;
    });

    return this.playableChords;  // Explicitly return the sorted array
  }

}


File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { settings } from './constants.js';


/**
 * Class representing a Chord Voicing.
 * 
 * The `ChordVoicing` class is used to represent a specific way to play a chord on a guitar. It includes
 * properties and methods to calculate and rate the playability and sound quality of the chord voicing.
 * 
 * @class
 */
export class ChordVoicing {
  /**
   * Creates an instance of ChordVoicing.
   * 
   * @constructor
   * @param {Array<number>} voicing - Array representing the fret positions for each string (0-5). `-1` represents a muted string, `0` represents an open string.
   * @param {number|null} barre - The fret position where a barre chord is applied. `null` if no barre chord.
   * @param {number} fingersUsed - The number of fingers used to play the chord.
   * @param {number} minAboveZero - The minimum fret position above zero used in the voicing.
   * @param {Array<number>} chordFactoryNotes - Array of note indices used in the chord (0-11 representing C-B).
   * @param {number} chordFactoryRoot - The root note of the chord.
   */
  constructor(voicing, fingerPositions, barres, minAboveZero, fingersUsed, chordFactoryNotes, chordFactoryRoot, actuallyPlayedNotes) {


    this.voicing = voicing;
    this.barres = barres;

    this.minAboveZero = minAboveZero
    this.fingerPositions = fingerPositions
    this.fingersUsed = fingersUsed
    this.chordSpacing = 0
    this.chordFactoryNotes = chordFactoryNotes
    this.chordFactoryRoot = chordFactoryRoot
    this.actuallyPlayedNotes = actuallyPlayedNotes



    this.playabilityRating = 0;
    this.soundQualityRating = 0; // New property to store sound quality rating

    this.ratingDetails = {
      playability: {
        fingersUsed: 0,
        fingerSpread: 0,
        mutedAmount: 0,
        fretHeight: 0,
        total: 0,
      },
      soundQuality: {
        harmonicCompleteness: 0,
        openStrings: 0,
        playedStrings: 0,
        fretBoardHeight: 0,
        voicingRange: 0,
        doubleNotes: 0,
        total: 0,
      }
    };

    //this.calculateChordSpacing()
    //this.calculateFingerPosition()

    this.rateSoundQuality()
    this.ratePlayability()

    //Send From ChordFactory over

  }

  calculateChordSpacing() {
    if (this.fingerPositions.length !== 6 || this.voicing.length !== 6) {
      throw new Error('Input arrays must each have 6 elements.');
    }

    let notes = this.fingerPositions.map((finger, index) => ({
      string: index + 1,
      fret: this.voicing[index],
      finger
    })).filter(note => note.finger !== 0 && note.fret !== -1);

    // Additional condition for barre chords
    if (this.barre) {
      notes = notes.filter(note => note.finger !== 1);
    }

    notes.sort((a, b) => a.fret - b.fret || a.string - b.string);

    let totalSpacing = 0;
    for (let i = 0; i < notes.length - 1; i++) {
      const stringDistance = Math.abs(notes[i].string - notes[i + 1].string);
      const fretDistance = Math.abs(notes[i].fret - notes[i + 1].fret);
      totalSpacing += stringDistance + fretDistance;
    }

    this.chordSpacing = totalSpacing;
  }





  //1 is good playability, 0 is bad palyability
  ratePlayability() {
    // Define playability weights directly within this method
    const PLAYABILITY_WEIGHTS = {
      fingersUsed: 3,        // Increased due to significant impact on difficulty
      fingerSpread: 5,       // Increased to reflect moderate spreads being easier
      fretHeight: 30,         // Kept moderate as high frets can be challenging
      mutedAmount: 40,        // Kept moderate as muting few strings is common
      mutedDifficulty: 14,    // Increased due to high difficulty of unreachable mutes
      mutedReachability: 2,  // Increased due to difficulty of unreachable mutes
      barreAmount: 9,        // Increased due to high difficulty of barre chords
      barreDifficulty: 6,
      fingerDistances: 2,    // Increased to reflect larger distances being harder
    };



    const details = this.ratingDetails.playability;
    details.fingersUsed = this.assessPlayabilityFingersUsed() * PLAYABILITY_WEIGHTS.fingersUsed;
    details.fingerSpread = this.assessPlayabilityFingerSpread() * PLAYABILITY_WEIGHTS.fingerSpread;
    details.mutedAmount = this.assessPlayabilityMutedAmount() * PLAYABILITY_WEIGHTS.mutedAmount;
    details.fretHeight = this.assessPlayabilityFretHeight() * PLAYABILITY_WEIGHTS.fretHeight;
    details.mutedDifficulty = this.assessPlayabilityMutedDifficulty() * PLAYABILITY_WEIGHTS.mutedDifficulty;
    details.mutedReachability = this.assessPlayabilityMutedReachability() * PLAYABILITY_WEIGHTS.mutedReachability;
    details.barreAmount = this.assessPlayabilityBarreAmount() * PLAYABILITY_WEIGHTS.barreAmount;
    details.fingerDistances = this.assessPlayabilityFingerDistances() * PLAYABILITY_WEIGHTS.fingerDistances;
    details.barreDifficulty = this.assessPlayabilityBarreDifficulty() * PLAYABILITY_WEIGHTS.barreDifficulty;

    // Calculate total playability score
    details.total = (
      details.fingersUsed +
      details.fingerSpread +
      details.mutedAmount +
      details.fretHeight +
      details.mutedDifficulty +
      details.mutedReachability +
      details.barreAmount +
      details.barreDifficulty +
      details.fingerDistances
    ) / Object.values(PLAYABILITY_WEIGHTS).reduce((sum, weight) => sum + weight, 0);

    this.playabilityRating = details.total;
  }

  assessPlayabilityFingersUsed() {
    // USe FInger Positions because They are MOst realibale and ALgorithmically Safe Way (Becaus of possible future Changes) to asses Finger COunt
    let maxUsableFingers = 4
    // INvert Rating so Many fingers used gets a low score
    let rating = 1 - (this.fingersUsed / maxUsableFingers)
    return rating
  }

  assessPlayabilityFingerSpread() {
    let maxFret = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] > maxFret) {
        maxFret = this.voicing[i]
      }
    }
    return 1 - ((2 ** (maxFret - this.minAboveZero)) / (2 ** settings.fingerFretRange))
  }

  assessPlayabilityMutedAmount() {
    let mutedCount = 0
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] == -1) {
        mutedCount++
      }
    }
    return 1 - (mutedCount / 6)
  }

  assessPlayabilityFretHeight() {
    if (Math.max(...this.voicing) > settings.fingerFretRange) {
      return 1 - (this.minAboveZero / 12)
    }
    else {
      return 1
    }

  }

  assessPlayabilityMutedDifficulty() {
    let mutedDifficulty = 0
    //Check Muting from the top
    for (let i = 0; i < 4; i++) {
      if (this.voicing[i] == -1) {
        mutedDifficulty += (i * 1)
      }
    }
    //Check Muting from the bottom  
    for (let i = 0; i < 4; i++) {
      if (this.voicing[5 - i] == -1) {
        mutedDifficulty += (i * 1.5)
      }
    }

    return 1 - (mutedDifficulty / 15)

  }

  assessPlayabilityBarreAmount() {
    return 1 - ((this.barres.length * this.barres.length) / (3 * 3))
  }

  assessPlayabilityBarreDifficulty() {
    if(this.barres.length ==0){
      return 0.9
    }
    let count = 0
    this.barres.forEach(barre => {
      //If Full Barre
      count += barre[2] - barre[1]
    })
    let barrevalue = count / this.barres.length
    return (barrevalue / 5)
  }

  assessPlayabilityMutedReachability() {
    let mutedDifficulty = 0;
    let totalUnreachableMutes = 0;

    // Loop through the strings to check for muted strings surrounded by open strings
    for (let i = 1; i < this.voicing.length - 1; i++) { // Start from the second string and go to the second-last
      if (this.voicing[i] === -1) { // Check if the current string is muted
        // Check if both neighboring strings are open
        if (this.voicing[i - 1] === 0 && this.voicing[i + 1] === 0) {
          totalUnreachableMutes++;
        }
      }
    }

    // Edge cases: Check the first and last string separately if needed
    if (this.voicing[0] === -1 && this.voicing[1] === 0) { // First string muted and second string open
      totalUnreachableMutes++;
    }
    if (this.voicing[this.voicing.length - 1] === -1 && this.voicing[this.voicing.length - 2] === 0) { // Last string muted and the one before it open
      totalUnreachableMutes++;
    }

    // Normalize the difficulty score: the more muted strings surrounded by open strings, the higher the difficulty
    mutedDifficulty = totalUnreachableMutes / (this.voicing.filter(v => v === -1).length || 1); // Avoid division by zero

    return 1 - mutedDifficulty; // Invert to match scale where 1 is easy and 0 is difficult
  }

  assessPlayabilityFingerDistances() {
    const positions = [];

    // Collect positions of all fingers that are not muting a string.
    this.fingerPositions.forEach((pos, index) => {
      if (pos > 0 && this.voicing[index] !== -1) {
        positions.push({ finger: pos, fret: this.voicing[index], string: index });
      }
    });

    // Sort the positions array by finger order
    positions.sort((a, b) => a.finger - b.finger);
    //console.log(positions)

    // Calculate total distance between consecutive fingers
    let totalDistance = 0;
    for (let i = 0; i < positions.length - 1; i++) {
      const fretDistance = Math.abs(positions[i].fret - positions[i + 1].fret);
      const stringDistance = Math.abs(positions[i].string - positions[i + 1].string);
      totalDistance += fretDistance + stringDistance;
    }

    return settings.fingerFretRange / totalDistance;
  }













  rateSoundQuality() {
    // Define sound quality weights directly within this method
    const SOUND_QUALITY_WEIGHTS = {
      harmonicCompleteness: 1,
      openStrings: 1,
      playedStrings: 2,
      fretBoardHeight: 3,
      voicingRange: 4,
      doubleNotes: 1,
      voicingExp: 3,
      highStringHarmonicCompleteness: 2,
    };

    const details = this.ratingDetails.soundQuality;
    details.harmonicCompleteness = this.assessSoundHarmonicCompleteness() * SOUND_QUALITY_WEIGHTS.harmonicCompleteness;
    details.openStrings = this.assessSoundOpenStrings() * SOUND_QUALITY_WEIGHTS.openStrings;
    details.playedStrings = this.assessSoundPlayedStrings() * SOUND_QUALITY_WEIGHTS.playedStrings;
    details.fretBoardHeight = this.assessSoundFretBoardHeight() * SOUND_QUALITY_WEIGHTS.fretBoardHeight;
    details.voicingRange = this.assessSoundVoicingRange() * SOUND_QUALITY_WEIGHTS.voicingRange;
    details.doubleNotes = this.assessSoundDoubleNotes() * SOUND_QUALITY_WEIGHTS.doubleNotes;
    details.voicingExp = this.assessSoundVoicingExp() * SOUND_QUALITY_WEIGHTS.voicingExp;
    details.highStringHarmonicCompleteness = this.assessSoundHighStringHarmonicCompleteness() * SOUND_QUALITY_WEIGHTS.highStringHarmonicCompleteness;

    // Calculate total sound quality score
    details.total = (
      details.harmonicCompleteness +
      details.openStrings +
      details.playedStrings +
      details.fretBoardHeight +
      details.voicingRange +
      details.doubleNotes +
      details.voicingExp +
      details.highStringHarmonicCompleteness
    ) / Object.values(SOUND_QUALITY_WEIGHTS).reduce((sum, weight) => sum + weight, 0);

    this.soundQualityRating = details.total;
  }

  assessSoundHarmonicCompleteness() {
    // Transform chordFactoryNotes to modulo 12 and store as a Set
    const uniqueDesiredNotes = new Set(this.chordFactoryNotes.map(note => note % 12));

    // Transform actuallyPlayedNotes to modulo 12 and store as a Set
    const playedNotesModuloSet = new Set(this.actuallyPlayedNotes.map(note => note % 12));

    // Calculate the number of overlapping notes using set intersection
    let overlapCount = 0;
    uniqueDesiredNotes.forEach(note => {
      if (playedNotesModuloSet.has(note)) {
        overlapCount++;
      }
    });

    // Calculate harmonic completeness score
    const completenessScore = overlapCount / uniqueDesiredNotes.size;
    return completenessScore;
  }

  assessSoundOpenStrings() {
    let openStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] === 0) {
        openStrings++;
      }
    }

    return openStrings / this.voicing.length;
  }

  assessSoundPlayedStrings() {
    let playedStrings = 0;

    for (let i = 0; i < this.voicing.length; i++) {
      if (this.voicing[i] >= 0) {
        playedStrings++;
      }
    }

    return playedStrings / this.voicing.length;
  }

  assessSoundFretBoardHeight() {
    return Math.max(0, (1 - (this.minAboveZero / 12)))
  }



  assessSoundVoicingRange() {
    let minIndex = -1
    let maxIndex = -1
    for (let i = 0; i < 6; i++) {
      if (this.voicing[i] != -1) {
        minIndex = i
        break;
      }
    }
    //Check if one thing is presen
    if (minIndex < 0) {
      return 0;
    }

    for (let i = 5; i >= 0; i--) {
      if (this.voicing[i] != -1) {
        maxIndex = i
        break;
      }
    }
    let spacing = this.actuallyPlayedNotes[maxIndex] - this.actuallyPlayedNotes[minIndex]
    let maxSpacing = settings.tuning[5] + this.minAboveZero + settings.fingerFretRange - settings.tuning[0] + this.minAboveZero

    // The Higher the number, the better So The higher the Spacing archived, the better
    let spacingRatio = spacing / maxSpacing
    return spacingRatio
  }

  assessSoundDoubleNotes() {
    let doubleNotes = 0
    for (let i = 0; i < 5; i++) {
      if (this.actuallyPlayedNotes[i] == this.actuallyPlayedNotes[i + 1]) {
        doubleNotes++;
      }
    }
    return 1 - (doubleNotes / 5)
  }

  assessSoundVoicingExp() {
    // The Closer to 1 the Bigger are the Gaps Between the Low Notes
    // The CLoser to 0, the more it is equal spaces are between the Notes
    let decayParameter = 0.5
    this.ratingDetails.soundQuality.expDeltaArray = [0, 0, 0, 0, 0, 0]
    let min = 99
    let max = -1
    this.actuallyPlayedNotes.forEach(element => {
      if (element > max) {
        max = element
      }
      if (element < min && element != -1) {
        min = element
      }
    })
    let difference = max - min

    let desiredpoint
    let comultative_delta = 0
    let unmuted_strings = 0
    for (let i = 0; i < 6; i++) {
      //If Not Muted, get the Desired exponential Decay point
      if (this.actuallyPlayedNotes[i] != -1) {
        unmuted_strings++
        desiredpoint = ((difference) * (1 - Math.exp(-decayParameter * i))) + min;
        comultative_delta += Math.abs(desiredpoint - this.actuallyPlayedNotes[i])
        this.ratingDetails.soundQuality.expDeltaArray[i] = desiredpoint
      }
    }
    this.ratingDetails.soundQuality.expComultativeDelta = comultative_delta

    //lessdelta means Better sound
    return 1 - Math.min((comultative_delta / (difference * unmuted_strings)), 1)
  }
  assessSoundHighStringHarmonicCompleteness() {
    let playedNotesModulo = this.actuallyPlayedNotes.map(note => note % 12)
    let overlap = new Set();
    let minStrings = Math.min(6, this.chordFactoryNotes.length);
    for (let string = 0; string < minStrings; string++) {
      if (this.chordFactoryNotes.includes(playedNotesModulo[5 - string])) {
        overlap.add(playedNotesModulo[5 - string]);
      }
    }
    this.ratingDetails.soundQuality.highStringHarmonicOverlap = overlap.size + " / " + minStrings
    return overlap.size / minStrings;
  }
}
/*
assessVoicingRange(){
  //TODO: Asses, The Difference Between the Lowest and the highest Played note. Find a Way to normalize the output between 0 (small difference) and 1
}


assessTonalBalance() {
  const noteFrequencies = this.voicing.map((fret, string) =>
    fret !== -1 ? (STANDARD_settings.tuning[string] + fret) % 12 : null
  ).filter(note => note !== null);

  const lowNotes = noteFrequencies.filter(note => note < 5).length;
  const midNotes = noteFrequencies.filter(note => note >= 5 && note < 9).length;
  const highNotes = noteFrequencies.filter(note => note >= 9).length;

  const balance = Math.min(lowNotes, midNotes, highNotes);
  return balance / 3 * 10;
}



assessVoicingRange() {
  const frets = this.voicing.filter(fret => fret !== -1);
  const range = Math.max(...frets) - Math.min(...frets);
  return range > 5 ? 0 : (5 - range) / 5 * 10;
}

assessDissonance() {
  const intervals = [];
  const frets = this.voicing.filter(fret => fret !== -1);

  for (let i = 0; i < frets.length; i++) {
    for (let j = i + 1; j < frets.length; j++) {
      const interval = Math.abs(frets[i] - frets[j]);
      intervals.push(interval);
    }
  }

  const dissonantIntervals = intervals.filter(interval => [1, 2, 6, 10].includes(interval));
  return 10 - dissonantIntervals.length * 2;
}

assessResonanceAndSustain() {
  const openStrings = this.voicing.filter(fret => fret === 0).length;
  return openStrings * 2;
}

assessChordClarity() {
  const clearNotes = this.voicing.filter(fret => fret !== -1 && fret !== 0);
  return clearNotes.length / 6 * 10;
}

assessContextualFit(contextChords) {
  const similarityScores = contextChords.map(contextChord => {
    let score = 0;
    for (let i = 0; i < 6; i++) {
      if (contextChord.voicing[i] === this.voicing[i]) {
        score++;
      }
    }
    return score;
  });

  const maxSimilarity = Math.max(...similarityScores);
  return maxSimilarity / 6 * 10;
}
}*/

/*
Start at Index Finger, represented by fingerPositions 1.
Count the String changes on the Same Fret with the middle finger so if the middle finger is 2 stings below, add 2 to the evalutaion 
if the middle finger is on the next fret over the minAboveZero, add 0, and only add 1 for each string it moved down or upward relative to the index finger
if the index finger is on the same fret as the middle finger, but the index finger is not also on the fret where the ring finger is, add the string count distance between the middle and ring finger 
if the index finger is on one fret more thatn the middle finger, but the middle and the index finger are on the fret below, add only the distance between the ring and the middle finger
if the index finger is on one fret, the middle finger is on +1 fret and the ring finger is on #1 fret, add 3 to the difficulty
if the small finger is on the same fret as the ring finger, but no other finger is on that fret, only add the string distance between the ring and the small finger.


*/

File: constants.js
Path: chord-factory\constants.js

// constants.js

export const BARRE_RATING = 1
export const MAX_FRETS = 24


/**
 * Class representing application settings.
 */
class Settings {
  /**
   * Create a settings object with default values.
   */
  constructor() {
    this.tuning = [40, 45, 50, 55, 59, 64];
    this.fingerFretRange = 4;
    this.mutePermutations = false
    this.startWithRoot = true;
    this.trailing = true;

  }

}

export var settings = new Settings();


File: main.js
Path: chord-factory\main.js

import { settings } from './constants.js';
import { ChordFactory } from './chordfactory.js';

let totalDuration = 0;
const repetitions = 50;
let lastPlayChords;

for (let i = 0; i < repetitions; i++) {
    const startTime = performance.now();
    
    const chord = new ChordFactory("E, G, B", 4, true, settings.tuning);
    const playableChords = chord.playableChords
    
    if (i === repetitions - 1) { // Only save the last result
        lastPlayChords = playableChords;
    }

    const endTime = performance.now();
    totalDuration += endTime - startTime; // Calculate the duration for this iteration
}

// Sort lastPlayChords by difficulty
if (lastPlayChords && lastPlayChords.length > 0) {
    lastPlayChords.sort((a, b) => a.rating - b.rating);
}

lastPlayChords.forEach((chord) => console.log(chord));

// Calculate the average time
const averageTime = totalDuration / repetitions;
console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);


File: utils.js
Path: chord-factory\utils.js

// Mapping of musical notes to their respective index numbers
export const NOTE_INDEX_MAP = {
  'C': 0, 'C#': 1, 'DB': 1, 'D': 2, 'D#': 3, 'EB': 3, 'E': 4, 'FB': 4,
  'F': 5, 'F#': 6, 'GB': 6, 'G': 7, 'G#': 8, 'AB': 8, 'A': 9, 'A#': 10,
  'BB': 10, 'B': 11, 'CB': 11
};

// Reverse mapping for number to note conversion
export const NOTE_ARRAY = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

// Convert a note to its respective index number
export function noteToNumber(note) {
  
  const normalizedNote = note.toUpperCase().replace(/[\s#]+/g, '#').replace(/[\sB]+/g, 'B');
  
  return NOTE_INDEX_MAP.hasOwnProperty(normalizedNote) 
    ? NOTE_INDEX_MAP[normalizedNote] 
    : "Invalid note";
}

// Convert a number to its respective musical note
export function numberToNote(number) {
  return NOTE_ARRAY[number % 12];
}

export function parseNotes(input) {
  return input.toUpperCase()
    .replace(/B#/g, 'C').replace(/E#/g, 'F')
    .split(/[\s,]+/)
    .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note));
}

export function removeDuplicateArrays(arrays) {
  const uniqueArrays = new Set();
  return arrays.filter(array => {
    const serialized = JSON.stringify(array);
    if (!uniqueArrays.has(serialized)) {
      uniqueArrays.add(serialized);
      return true;
    }
    return
  });
}


File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js";
/**
 * Represents a musical chord.
 * 
 * @class Chord
 * @constructor
 * @param {number} rootNote - The root note of the chord, represented as an integer from 0 to 11. 
 *                            0 corresponds to C, 1 to C#, 2 to D, and so on.
 * @param {number[]} notes - An array of integers representing the notes of the chord. 
 *                           Each note is represented as an integer from 0 to 11.
 * @param {string} name - The full name of the chord, e.g., "Gm", "Asus4".
 * @param {boolean} customRoot - A flag indicating if the root note is custom.
 * 
 * @example
 * // Create a G minor chord
 * const gMinor = new Chord(7, [7, 10, 2], "Gm", false);
 * 
 * @example
 * // Create an A suspended 4th chord with a custom root
 * const aSus4 = new Chord(9, [9, 0, 5], "Asus4", true);
 * 
 * @property {number} rootNote - The root note of the chord.
 * @property {number[]} notes - The notes that make up the chord.
 * @property {string} name - The name of the chord.
 * @property {boolean} customRoot - Indicates if the root note is custom.
 */
export class Chord {
    constructor(rootNote, notes, name, customRoot) {
        this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = notes; // Array of integers representing notes of the chord
        this.name = name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = customRoot
        console.log("Constructed Chord: " + this.name + " Root: " + this.rootNote + " Notes: " + this.notes)
    }
}

export class ChordLibrary {
    constructor() {
        this.chords = [];
        this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        this.chordStructures = {
            ' ': { notes: [0, 4, 7], priority: 1 }, // Major
            'm': { notes: [0, 3, 7], priority: 2 }, // Minor
            '7': { notes: [0, 4, 7, 10], priority: 3 }, // Dominant 7th
            'M7': { notes: [0, 4, 7, 11], priority: 4 }, // Major 7th
            'm7': { notes: [0, 3, 7, 10], priority: 5 }, // Minor 7th
            'mM7': { notes: [0, 3, 7, 11], priority: 18 }, // Minor Major 7th
            'sus2': { notes: [0, 2, 7], priority: 7 }, // Suspended 2nd
            'sus4': { notes: [0, 5, 7], priority: 6 }, // Suspended 4th
            'dim': { notes: [0, 3, 6], priority: 9 }, // Diminished
            'aug': { notes: [0, 4, 8], priority: 8 }, // Augmented
            '9': { notes: [0, 4, 7, 10, 14], priority: 11 }, // Dominant 9th
            'M9': { notes: [0, 4, 7, 11, 14], priority: 12 }, // Major 9th
            'm9': { notes: [0, 3, 7, 10, 14], priority: 13 }, // Minor 9th
            '11': { notes: [0, 4, 7, 10, 14, 17], priority: 16 }, // Dominant 11th
            '13': { notes: [0, 4, 7, 10, 14, 17, 21], priority: 24 }, // Dominant 13th
            'add9': { notes: [0, 2, 4, 7], priority: 17 }, // Added 9th
            'm6': { notes: [0, 3, 7, 9], priority: 14 }, // Minor 6th
            '6': { notes: [0, 4, 7, 9], priority: 15 }, // Major 6th
            '5': { notes: [0, 7], priority: 10 }, // Power chord
            '6/9': { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6/9
            'm11': { notes: [0, 3, 7, 10, 14, 17], priority: 39 }, // Minor 11
            'M7#11': { notes: [0, 4, 7, 11, 18], priority: 29 }, // Major 7#11
            'm7b5': { notes: [0, 3, 6, 10], priority: 19 }, // Half-Diminished
            '+7': { notes: [0, 4, 8, 10], priority: 21 }, // Augmented 7th
            'dim7': { notes: [0, 3, 6, 9], priority: 20 }, // Diminished 7th
            'M7+5': { notes: [0, 4, 8, 11], priority: 28 }, // Augmented Major 7th
            'mM9': { notes: [0, 3, 7, 11, 14], priority: 18 }, // Minor Major 9th
            'dimM7': { notes: [0, 3, 6, 11], priority: 22 }, // Diminished Major 7th
            '7alt': { notes: [0, 4, 6, 10, 13], priority: 23 }, // Altered Dominant
            'M13': { notes: [0, 4, 7, 11, 14, 17, 21], priority: 24 }, // Major 13th
            'M11': { notes: [0, 4, 7, 11, 14, 17], priority: 25 }, // Major 11th
            'M7sus4': { notes: [0, 5, 7, 11], priority: 26 }, // Major 7th Suspended 4th
            'm7#5': { notes: [0, 3, 8, 10], priority: 27 }, // Minor 7th #5
            'M#5': { notes: [0, 4, 8], priority: 28 }, // Major #5
            '9#11': { notes: [0, 4, 7, 10, 14, 18], priority: 29 }, // Dominant 9th #11
            '13#11': { notes: [0, 4, 7, 10, 14, 18, 21], priority: 30 }, // Dominant 13th #11
            '7b5': { notes: [0, 4, 6, 10], priority: 31 }, // Dominant 7th Flat Five
            'M7b5': { notes: [0, 4, 6, 11], priority: 32 }, // Major 7th Flat Five
            'M7#5': { notes: [0, 4, 8, 11], priority: 33 }, // Major 7th Sharp Five
            'm7b9': { notes: [0, 3, 7, 10, 13], priority: 34 }, // Minor 7th Flat Nine
            '9b5': { notes: [0, 4, 6, 10, 14], priority: 34 }, // 9th Flat Five
            '9#5': { notes: [0, 4, 8, 10, 14], priority: 35 }, // 9th Sharp Five
            '7b9': { notes: [0, 4, 7, 10, 13], priority: 36 }, // Dominant 7th Flat Nine
            '7#9': { notes: [0, 4, 7, 10, 15], priority: 37 }, // Dominant 7th Sharp Nine
            '7#11': { notes: [0, 4, 7, 10, 18], priority: 38 }, // Dominant 7th Sharp Eleven
            'm7add11': { notes: [0, 3, 7, 10, 17], priority: 39 }, // Minor 7th Add 11
            'add2': { notes: [0, 2, 4, 7], priority: 40 }, // Major Add 2
            'add4': { notes: [0, 4, 5, 7], priority: 41 }, // Major Add 4
            '6add9': { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6 Add 9

            '/C': { notes: [0, 4, 7], root: 0, priority: 43 }, // C Major
            'm/C': { notes: [0, 3, 7], root: 0, priority: 44 }, // C Minor
            '/C#': { notes: [0, 4, 7], root: 1, priority: 43 }, // C# Major
            'm/C#': { notes: [0, 3, 7], root: 1, priority: 44 }, // C# Minor
            '/D': { notes: [0, 4, 7], root: 2, priority: 43 }, // D Major
            'm/D': { notes: [0, 3, 7], root: 2, priority: 44 }, // D Minor
            '/D#': { notes: [0, 4, 7], root: 3, priority: 43 }, // D# Major
            'm/D#': { notes: [0, 3, 7], root: 3, priority: 44 }, // D# Minor
            '/E': { notes: [0, 4, 7], root: 4, priority: 43 }, // E Major
            'm/E': { notes: [0, 3, 7], root: 4, priority: 44 }, // E Minor
            '/F': { notes: [0, 4, 7], root: 5, priority: 43 }, // F Major
            'm/F': { notes: [0, 3, 7], root: 5, priority: 44 }, // F Minor
            '/F#': { notes: [0, 4, 7], root: 6, priority: 43 }, // F# Major
            'm/F#': { notes: [0, 3, 7], root: 6, priority: 44 }, // F# Minor
            '/G': { notes: [0, 4, 7], root: 7, priority: 43 }, // G Major
            'm/G': { notes: [0, 3, 7], root: 7, priority: 44 }, // G Minor
            '/G#': { notes: [0, 4, 7], root: 8, priority: 43 }, // G# Major
            'm/G#': { notes: [0, 3, 7], root: 8, priority: 44 }, // G# Minor
            '/A': { notes: [0, 4, 7], root: 9, priority: 43 }, // A Major
            'm/A': { notes: [0, 3, 7], root: 9, priority: 44 }, // A Minor
            '/A#': { notes: [0, 4, 7], root: 10, priority: 43 }, // A# Major
            'm/A#': { notes: [0, 3, 7], root: 10, priority: 44 }, // A# Minor
            '/B': { notes: [0, 4, 7], root: 11, priority: 43 }, // B Major
            'm/B': { notes: [0, 3, 7], root: 11, priority: 44 } // B Minor
        };

        this.generateChords();
    }

    generateChords() {
        Object.entries(this.chordStructures).forEach(([suffix, structure]) => {
            for (let i = 0; i < 12; i++) {
                let rootNote = i
                let customRoot = false
                let notes = structure.notes.map(interval => (i + interval) % 12);
                const chordName = `${this.noteNames[i]}${suffix}`;
                if (structure.root !== undefined) {
                    // Filter Dumb Chord Like C/C D/D
                    if (structure.root == rootNote) {
                        continue;
                    }
                    rootNote = structure.root;
                    customRoot = true;
                    notes.push(rootNote);
                }

                const chord = new Chord(rootNote, notes, chordName, customRoot);
                chord.priority = structure.priority;
                this.chords.push(chord);
            }
        });

        // Sort chords by priority
        this.chords.sort((a, b) => a.priority - b.priority);
    }

    async searchChords(noteArray, rootNote, threshold = 50) {
        console.log("Searching Chords...")
        const results = [];
        noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave
        if (rootNote) {
            rootNote = rootNote % 12

        }
        const inputNotesSet = new Set(noteArray);

        this.chords.forEach(chord => {
            let chordNotes = [...chord.notes];

            //console.log("Comparing to: " + chord.name)
            //Add the Root note to the Chords For Cases like A/D

            //console.log("Input Notes Set: ", inputNotesSet);

            const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note)));
            //console.log("Common Notes with Chord: ", commonNotes);

            const totalUniqueNotes = new Set([...chordNotes, ...noteArray]);
            //console.log("Total Unique Notes: ", totalUniqueNotes);


            let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100;
            //console.log("Searched Root: " + rootNote + " Presen Root: " + chord.rootNote);

            // Adjusting match percentage based on root note comparison
            if (rootNote !== null) {
                if (chord.rootNote == rootNote) {
                    //console.log("Matching Root for: " + chord.name + " Root: " + chord.rootNote + " Notes: " + chordNotes)
                    // If root notes match, this is fine as calculated
                } else {
                    // Penalize the match percentage slightly if root notes don't match
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized for not matching Root")
                }
            } else {
                //If a Custom Root in the CHord Details is specified but the user hasnt put a custom root
                if (chord.customRoot == true) {
                    matchPercentage *= 0.85; // Penalize by 10%
                    //console.log("Panelized For Havinng Specific when it shouldnt")

                }
            }



            if (matchPercentage >= threshold) {
                results.push(
                    new DragAndDropItem(chord, parseFloat(matchPercentage.toFixed(2)))
                );
            }
        });

        // Sort results by probability in descending order
        return results.sort((a, b) => b.probability - a.probability);
    }

    getAllChords() {
        // Return all chord names in a simplified object format
        return this.chords;
    }

    getChordByName(name) {
        const chord = this.chords.find(chord => chord.name === name);
        if (chord) {
            //console.log('Chord found:', chord);
            return chord;
        } else {
            //console.log('No chord found with the name:', name);
            return null;
        }
    }


    //USing this ugly transpose Chord function as its computationaly faster
    transposeChord(chord, semitones) {
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        console.warn("Trying: ", chord, semitones)

        // Helper function to transpose a note name
        function transposeNoteName(noteName) {
            let noteIndex = noteNames.indexOf(noteName);
            let transposedIndex = (noteIndex + semitones) % 12;
            if (transposedIndex < 0) transposedIndex += 12; // Correct negative indices
            return noteNames[transposedIndex];
        }

        // Split the chord name at the slash to separate the main part and the bass note (if any)
        let [mainPart, bassPart] = chord.name.split('/');

        // Determine the root note and suffix from the main part
        let noteLength = mainPart[1] === '#' ? 2 : 1;
        let rootNoteName = mainPart.substring(0, noteLength);
        let suffix = mainPart.substring(noteLength);

        // Transpose the root note
        let transposedRootNoteName = transposeNoteName(rootNoteName);

        // If there is a bass part, transpose it directly
        let transposedBassPart = '';
        if (bassPart) {
            let bassRootNoteLength = bassPart[1] === '#' ? 2 : 1;
            let bassRootNoteName = bassPart.substring(0, bassRootNoteLength);
            transposedBassPart = transposeNoteName(bassRootNoteName) + bassPart.substring(bassRootNoteLength);
        }

        // Construct the transposed chord name
        let transposedChordName = transposedRootNoteName + suffix;
        if (bassPart) {
            transposedChordName += '/' + transposedBassPart;
        }

        // Transpose the numeric notes in the chord
        let transposedNotes = chord.notes.map(note => (note + semitones) % 12);

        return new Chord(noteNames.indexOf(transposedRootNoteName), transposedNotes, transposedChordName, chord.customRoot);
    }


    async simplifySlashChord(chord) {
        // Check if the chord is a slash chord (contains a '/')
        if (!chord.name.includes('/')) {
            return chord; // Return original chord if it's not a slash chord
        }

        console.warn("simplifySlashChord", chord.notes)



        // Search for a chord in the library that matches the modified notes
        let matchedChords = await this.searchChords(chord.notes, undefined, 50)

        if (matchedChords.length > 0) {
            console.warn(this.convertDragDropItemsToChords(matchedChords[0]))
            return this.convertDragDropItemsToChords(matchedChords[0]); // Return the first matching chord
        } else {
            return chord; // Return original if no match found
        }
    }
    convertDragDropItemsToChords(dragDropItem) {
        return new Chord(
            dragDropItem.rootNote,
            dragDropItem.notes,
            dragDropItem.name,
            dragDropItem.customRoot,
        )
    }

}



File: index.html
Path: chordviewer\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano2Guitar</title>
    <!-- STYLESHEETS -->
    <link rel="stylesheet" href="../piano/style.css" />
    <link rel="stylesheet" href="../progression-generator/style.css" />
    <link rel="stylesheet" href="../css/output-styles.css" />
    <link rel="stylesheet" href="../css/input-styles.css" />
    <link rel="stylesheet" href="../css/slider-styles.css" />
    <link rel="stylesheet" href="../css/settings-styles.css" />
    <link rel="stylesheet" href="styles.css" />




    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">


    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>
</head>

<body>

    <div class="inputWrapper">
        <div class="header">
            PianoToGuitar.com - ChordViewer
            <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()"
                height="24" viewBox="0 -960 960 960" width="24">
                <path
                    d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
            </svg>
        </div>
        <div class="searchContainer">
            <div class="searchContainerWrapper">
                <div class="searchContainer">

                    <div class="searchWordContainer">
                        <div class="blackFadeBottom"></div>
                        <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name...">
                        <div class="searchChordList" id="itemsContainer">
                            <!-- Items will be populated here by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="selectedItemWrapper">

                <div class="selectedItemsHeading">
                    <div>Your Selected Chord</div>
                </div>
                <div class="selectedItemsWrapper">
                    <div class="selectedItems" id="selectedItems">
                        <!-- Dragged items will appear here -->
                    </div>

                    <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()"
                        height="24" viewBox="0 -960 960 960" width="24">
                        <path fill="currentColor"
                            d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                    </svg>
                </div>
            </div>
        </div>

    </div>
    <div class="outputWrapper" id="outputWrapper">
        <div class="progression">


            <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            <div class="progressionInfo">
                <div class="progressionInfoText">
                    <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                    <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the
                        most beautifully sounding ones!
                    </div>
                </div>
                <div class="soundQualityWrapper">
                    <input id="soundQualitySlider" type="range" min="0" max="100" value="50">
                    <div class="soundQualityLables">
                        <div>EASY</div>
                        <div>BEST SOUND</div>
                    </div>
                </div>

            </div>
        </div>
</body>

</html>

File: index.js
Path: chordviewer\index.js

import DragAndDropList from '../drag-drop/script.js';
import { ChordLibrary } from "../chord-library/script.js"
import { ProgressionGenerator } from '../progression-generator/main.js';
import { settings } from '../chord-factory/constants.js';


document.addEventListener('DOMContentLoaded', () => {


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };



    let soundQualityValue = 1;
    let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems[0]);
        
        await progressionGenerator.setProgression([event.detail.selectedItems[0]])
        await updateProgressionDynamic(soundQualityValue)
        dragAndDropList.clearSelectedList();
    });


    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue);
        await updateProgressionDynamic(soundQualityValue)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue, 20);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };


    //Update the Progressions to get the PLaceholders:
    updateProgressionDynamic(soundQualityValue)
})


File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs');
const path = require('path');

function isHtmlOrJsFile(file) {
  return file.endsWith('.html') || file.endsWith('.js');
}

function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') {
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      fileStructure[item] = {};
      getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item));
    } else if (isHtmlOrJsFile(item)) {
      fileStructure[item] = {
        path: fullPath,
        relativePath: path.join(parentPath, item),
        size: stats.size,
        lastModified: stats.mtime
      };
    }
  });
  return fileStructure;
}

function removeWhitespace(text) {
  return text.replace(/\s+/g, ' ').trim();
}

function removeComments(text) {
  const singleLineCommentPattern = /\/\/.*(?=[\n\r]|$)/g;
  const multiLineCommentPattern = /\/\*[\s\S]*?\*\//g;
  const stringPattern = /(['"`])(?:(?!\1|\\).|\\.)*\1/g;
  const regexPattern = /\/(?!\*)[^/\\\n]+\/[gimsuy]*/g; // Improved regex for JS regex patterns

  // Preserve strings and regex to avoid removing comment-like patterns within them
  const preservedItems = [];
  let preservedText = text.replace(stringPattern, match => {
    preservedItems.push(match);
    return `__PRESERVED__${preservedItems.length - 1}__`;
  }).replace(regexPattern, match => {
    preservedItems.push(match);
    return `__PRESERVED__${preservedItems.length - 1}__`;
  });

  // Remove comments
  preservedText = preservedText.replace(singleLineCommentPattern, '');
  preservedText = preservedText.replace(multiLineCommentPattern, '');

  // Restore strings and regex patterns
  preservedText = preservedText.replace(/__PRESERVED__(\d+)__/g, (_, index) => preservedItems[Number(index)]);

  return preservedText;
}

function readAllFiles(dir, parentPath = '', removeWhitespaceSetting = false, removeCommentsSetting = false) {
  let allText = '';
  const items = fs.readdirSync(dir);
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    if (stats.isDirectory()) {
      allText += readAllFiles(fullPath, path.join(parentPath, item), removeWhitespaceSetting, removeCommentsSetting);
    } else if (isHtmlOrJsFile(item)) {
      let fileContent = fs.readFileSync(fullPath, 'utf8');
      if (removeWhitespaceSetting) {
        fileContent = removeWhitespace(fileContent);
      }
      if (removeCommentsSetting && item.endsWith('.js')) {
        fileContent = removeComments(fileContent);
      }
      allText += `File: ${item}\n`;
      allText += `Path: ${path.join(parentPath, item)}\n\n`;
      allText += fileContent + '\n\n';
    }
  });
  return allText;
}

function formatStructure(fileStructure, indent = 0) {
  let structureText = '';
  const indentString = ' '.repeat(indent);
  for (const key in fileStructure) {
    if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) {
      const { relativePath, size, lastModified } = fileStructure[key];
      structureText += `${indentString}${key} (Path: ${relativePath})\n`;
    } else {
      structureText += `${indentString}${key}/\n`;
      structureText += formatStructure(fileStructure[key], indent + 2);
    }
  }
  return structureText;
}

try {
  const targetDir = path.join(__dirname, ''); // Change '' to your target folder
  const outputFilePath = path.join(__dirname, 'output.txt');
  const removeWhitespaceSetting = false ; // Set to true to remove whitespace
  const removeCommentsSetting = false; // Set to true to remove comments

  // Get the folder and file structure
  const fileStructure = getDirectoryStructure(targetDir);

  // Format the structure to a string
  const structureText = formatStructure(fileStructure);

  // Read all the text from HTML and JS files
  const filesText = readAllFiles(targetDir, '', removeWhitespaceSetting, removeCommentsSetting);

  // Combine structure and file texts
  const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`;

  // Write the final output to a file
  fs.writeFileSync(outputFilePath, finalOutput);

  console.log('Folder structure and file contents have been saved to output.txt');
} catch (error) {
  console.error('Error reading directory:', error.message);
}


File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js";
import { NOTE_ARRAY } from "../chord-factory/utils.js"

export class DragAndDropItem extends Chord {
    constructor(chord, probability = -1) {
        super(chord)
        this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc.
        this.notes = chord.notes; // Array of integers representing notes of the chord
        this.name = chord.name; // String representing the full name of the chord, e.g., "Gm", "Asus4"
        this.customRoot = chord.customRoot
        this.probability = probability
    }
}

export default class DragAndDropList {
    constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) {
        this.items = []
        this.idCounter = 0;
        items.forEach(item => {
            this.items.push(new DragAndDropItem(item))
        })

        this.dropzoneId = dropzoneId;
        this.selectedItemsEvent = new CustomEvent('selectedItemsUpdated', { bubbles: true, detail: { selectedItems: [] } });

        this.emptyMessageContainer = document.getElementById(emptyMessage);
        this.itemsContainer = document.getElementById(itemsContainer);
        this.selectedItemsContainer = document.getElementById(selectedItems);
        this.itemFilterInput = document.getElementById(itemSearch);
        this.selectedItemsArray = [];

        this.addEventListeners();
        this.populateItemsList();

        this.emptyMessage = "Click on chords to add";
        this.emptyMessageElement = document.createElement('div');
        this.emptyMessageElement.id = "DragAndDrop-EmptyMessage";

        const words = this.emptyMessage.split(' ');

        const baseElement = this.createItemElement({ name: "Sample Word" });
        baseElement.draggable = false;
        baseElement.isSelectable = false;

        words.forEach(word => {
            const clone = baseElement.cloneNode(true);
            clone.innerHTML = word;
            this.emptyMessageElement.appendChild(clone);
        });

        this.selectedItemsContainer.appendChild(this.emptyMessageElement);
    }

    addEventListeners() {
        window.addEventListener('dragover', this.handleWindowDragOver.bind(this));
        window.addEventListener('drop', this.handleWindowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('dragover', this.allowDrop.bind(this));
        this.selectedItemsContainer.addEventListener('drop', this.handleDropOnContainer.bind(this));
        this.itemFilterInput.addEventListener('input', this.filterItems.bind(this));
    }

    handleWindowDragOver(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    handleWindowDrop(e) {
        e = e || event;
        if (e.target.id !== this.dropzoneId) {
            e.preventDefault();
        }
    }

    last100PercentItemIndex() {
        let lastIndex = -1;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].probability === 100) {
                lastIndex = i;
            }
        }
        return lastIndex;
    }

    populateItemsList() {
        const lastIndex100Percent = this.last100PercentItemIndex();
        let first100Percent = false;
        this.items.forEach((item, index) => {
            if (item.probability === 100 && !first100Percent) {
                first100Percent = true;
                const firstElement = document.createElement('div');
                firstElement.style.width = "100%";
                firstElement.innerHTML = "BEST MATCHES FOUND:";
                firstElement.style.backgroundColor = "#ffffff00";
                firstElement.style.color = "var(--light3)";
                firstElement.style.fontSize = "small";

                this.itemsContainer.appendChild(firstElement);
            }
            const itemElement = this.createItemElement(item, true);
            this.itemsContainer.appendChild(itemElement);

            if (index === lastIndex100Percent) {
                const breakElement = document.createElement('div');
                breakElement.style.width = "100%";
                breakElement.style.height = "2px";
                breakElement.style.backgroundColor = "var(--dark1)";
                breakElement.style.boxShadow = "var(--padding) 0px 0px 0px var(--dark1), calc(var(--padding)*-1) 0px 0px 0px var(--dark1)";

                this.itemsContainer.appendChild(breakElement);
            }
        });
    }

    createItemElement(item, isSelectable = false) {
        const itemElement = document.createElement('div');
        itemElement.textContent = item.name;
        itemElement.title = item.name + ": " + item.notes?.map(index => NOTE_ARRAY[index]).join(', ');

        itemElement.className = 'dragDropItem';
        itemElement.id = `dragDropItem-${this.idCounter++}`;

        if (item.probability > 0) {
            const probabilitySpan = document.createElement('span');
            probabilitySpan.textContent = `(${item.probability}%)`;
            probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability);
            if (item.probability === 100) {
                itemElement.style.boxShadow = '0px 0px 13px 0px rgba(0,255,0)';
                itemElement.style.fontWeight = "800";
            }

            itemElement.appendChild(probabilitySpan);
        }

        if (isSelectable) {
            itemElement.addEventListener('click', () => this.addSelectedItem(item));
        }
        return itemElement;
    }

    getBackgroundColor(probability) {
        const startColor = [255, 130, 130];
        const endColor = [230, 230, 30];
        const winnerColor = [150, 200, 0];

        probability = Math.max(50, Math.min(100, probability));

        const scaledProbability = (probability - 50) / 50;

        const adjustedProbability = Math.log10(1 + 9 * scaledProbability);

        let blendedColor = startColor.map((component, index) => {
            return Math.round(component + (endColor[index] - component) * adjustedProbability);
        });
        if (probability === 100) {
            blendedColor = winnerColor;
        }
        return `rgb(${blendedColor.join(',')})`;
    }

    createSelectedItemElement(item) {
        const selectedItemElement = document.createElement('div');
        selectedItemElement.className = 'selected-dragDropItem dragDropItem';
        selectedItemElement.draggable = true;
        selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`;
        selectedItemElement.textContent = item.name;
        selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this));
        selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this));
        selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this));
        selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this));
        selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this));
        return selectedItemElement;
    }

    removeSelectedItem(event) {
        event.target.remove();
        this.updateArrayFromList();
    }

    addSelectedItem(item) {

        this.selectedItemsArray.push(item);
        //TODO: Deselect all Pinao Keys
        this.updateDisplayArray();
    }

    updateItems(newItems) {
        console.log("Updating Library...");
        this.clearList();
        this.items = newItems;
        this.populateItemsList();
    }

    clearList() {
        this.items = [];
        while (this.itemsContainer.firstChild) {
            this.itemsContainer.removeChild(this.itemsContainer.firstChild);
        }
    }

    clearSelectedList() {
        this.selectedItemsArray = [];
        while (this.selectedItemsContainer.firstChild) {
            this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild);
        }
        this.updateDisplayArray();
    }

    handleDropOnItemList(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) {
            droppedItemElement.remove();
            this.updateDisplayArray();
        }
    }

    handleDragStart(event) {
        event.dataTransfer.setData('text/plain', event.target.id);

        if (event.target.classList.contains('selected-dragDropItem')) {
            event.target.classList.add('dragging');
        }
    }

    handleDragOver(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.add('over');
        }
    }

    handleDragLeave(event) {
        event.preventDefault();
        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            targetElement.classList.remove('over');
        }
    }

    handleDropReorder(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);
        if (!droppedItemElement) return;

        const targetElement = event.target.closest('.selected-dragDropItem');
        if (targetElement) {
            if (droppedItemElement.classList.contains('selected-dragDropItem')) {
                this.insertAtCorrectPosition(droppedItemElement, targetElement);
            }
        } else {
            if (!droppedItemElement.classList.contains('selected-dragDropItem')) {
                const chordName = droppedItemElement.textContent.split(' (')[0];
                const chord = this.items.find(item => item.name === chordName);

                if (chord) {
                    const newClone = this.createSelectedItemElement(chord);
                    this.selectedItemsContainer.appendChild(newClone);
                    this.selectedItemsArray.push(chord);
                }
            } else {
                this.selectedItemsContainer.appendChild(droppedItemElement);
                this.updateDisplayArray();
            }
        }
        this.updateDisplayArray();
    }


    handleDragEnd(event) {
        event.target.classList.remove('dragging');
        const overItems = document.querySelectorAll('.selected-dragDropItem');
        overItems.forEach(item => item.classList.remove('over'));
    }

    allowDrop(event) {
        event.preventDefault();
    }

    handleDropOnContainer(event) {
        event.preventDefault();
        const droppedItemId = event.dataTransfer.getData('text/plain');
        const droppedItemElement = document.getElementById(droppedItemId);

        if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) {
            const chordName = droppedItemElement.textContent.split(' (')[0];
            const chord = this.items.find(item => item.name === chordName);

            if (chord) {
                const newClone = this.createSelectedItemElement(chord);
                this.selectedItemsContainer.appendChild(newClone);
                this.selectedItemsArray.push(chord);
                this.updateDisplayArray();
            }
        }
    }
    insertAtCorrectPosition(droppedItemElement, targetElement) {
        const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement);
        const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement);

        if (droppedIndex < targetIndex) {
            targetElement.after(droppedItemElement);
        } else {
            targetElement.before(droppedItemElement);
        }
        targetElement.classList.remove('over');
        this.updateArrayFromList();
    }

    updateArrayFromList() {
        this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => {
            const chordName = el.textContent.split(' (')[0];
            return this.items.find(item => item.name === chordName);
        });
        this.updateDisplayArray();

    }

    updateDisplayArray() {

        this.selectedItemsContainer.innerHTML = ""

        if (this.selectedItemsArray.length == 0) {
            if (!this.emptyMessageElement.parentNode) {
                this.selectedItemsContainer.appendChild(this.emptyMessageElement);
            }
        } else {
            this.emptyMessageElement.remove();
        }

        this.selectedItemsArray.forEach(item => {
            const selectedItemElement = this.createSelectedItemElement(item);
            this.selectedItemsContainer.appendChild(selectedItemElement);
        })


        this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray];
        document.dispatchEvent(this.selectedItemsEvent);
        console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`);


    }

    filterItems() {
        const filterValue = this.itemFilterInput.value.toUpperCase();
        const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem');
        itemElements.forEach(itemElement => {
            const itemText = itemElement.textContent.toUpperCase();
            itemElement.style.display = itemText.includes(filterValue) ? '' : 'none';
        });
    }

    getArray() {
        return [...this.selectedItemsArray];
    }



    loadChords(chords) {
        this.selectedItemsArray = [];
        chords.forEach(chordName => {
            if (chordName) {
                const newDragDropItem = new DragAndDropItem(chordName, 0);  // Assuming full match for direct loads
                this.addSelectedItem(newDragDropItem);
            } else {
                console.error('Chord not found:', chordName);
            }
        });
        this.updateDisplayArray();
    }



}

File: index.html
Path: index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PianoToGuitar - Chord Progression to Tabs</title>
    <meta name="description"
        content="Translate Progressions to Guitar Tabs. Find the best fingerings and capo position for any chord sequence with any guitar tuning algorithmically.">

    <!-- FAVICONS -->

    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
    <link rel="mask-icon" href="./safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#222222">

    <!-- STYLESHEETS -->

    <link rel="stylesheet" href="piano/style.css" />
    <link rel="stylesheet" href="progression-generator/style.css" />
    <link rel="stylesheet" href="css/output-styles.css" />
    <link rel="stylesheet" href="css/input-styles.css" />
    <link rel="stylesheet" href="css/slider-styles.css" />
    <link rel="stylesheet" href="css/settings-styles.css" />
    <link rel="stylesheet" href="css/adv-settings.css" />
    <link rel="stylesheet" href="css/footer.css" />
    <link rel="stylesheet" href="css/header.css" />
    <link rel="stylesheet" href="css/midi-selector.css" />
    <link rel="stylesheet" href="css/general.css" />

    <!-- FONT -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">

    <!-- SCRIPTS -->
    <script type="module" src="./index.js"></script>

</head>

<body>

    <div class="content">
        <div class="mainHeader">
            <div class="mainLogo">
                <svg xmlns="http://www.w3.org/2000/svg" alt="PianoToGuitar Logo" viewBox="0 0 243.68 212.74">
                    <title>PianoToGuitar Logo</title>
                    <g>
                        <path class="cls-1"
                            d="M46.18,212.74h-19.25C12.05,212.74,0,200.69,0,185.81v-64.85c17.21,3.47,34.67,6.22,52.36,8.21.1,0,.21.02.31.03.2,2.47.74,4.84,1.57,7.08,1.36,3.67,3.49,6.97,6.21,9.68,3.44,3.43,7.79,5.94,12.66,7.12v32.73c0,14.88-12.06,26.93-26.93,26.93Z" />
                        <path class="cls-1"
                            d="M137.91,52.01c-5.32.14-10.66.21-16.01.21-5.14,0-10.26-.06-15.37-.19h-.11s0-.31,0-.31c5.16.13,10.33.19,15.53.19,5.34,0,10.66-.07,15.96-.21v.31Z" />
                        <path class="cls-1"
                            d="M131.47,212.74h-19.25c-14.88,0-26.93-12.05-26.93-26.93v-32.6c12.08-2.64,21.13-13.4,21.13-26.29v-48.18s.11,0,.11,0c5.18.14,10.38.21,15.59.21s10.54-.08,15.79-.21v48.18c0,7.44,3.02,14.18,7.88,19.04,3.43,3.42,7.76,5.92,12.6,7.11v32.74c0,14.88-12.05,26.93-26.92,26.93Z" />
                        <path class="cls-1"
                            d="M243.68,39.78v146.04c0,14.87-12.05,26.93-26.93,26.93h-19.25c-14.87,0-26.93-12.05-26.93-26.93v-32.58c12.11-2.63,21.18-13.4,21.18-26.31V47.97c17.54-2,34.87-4.74,51.92-8.19Z" />
                        <path class="cls-1"
                            d="M243.68,19.74v7.03c-17.06,3.45-34.38,6.19-51.92,8.18-7.02.8-14.08,1.48-21.18,2.04-4.05.31-8.11.59-12.18.83-6.79.4-13.63.69-20.48.86-5.29.13-10.59.2-15.91.2-5.21,0-10.41-.06-15.59-.2-7.08-.17-14.12-.47-21.13-.88-4.07-.24-8.13-.52-12.18-.84-6.88-.55-13.73-1.2-20.54-1.97C34.8,32.98,17.27,30.21,0,26.7v-6.86c17.27,3.49,34.8,6.25,52.56,8.26,6.81.76,13.66,1.41,20.54,1.95,4.05.32,8.11.6,12.18.83,7.01.42,14.05.71,21.13.87,5.04.13,10.09.19,15.16.19,5.46,0,10.91-.07,16.34-.22,6.85-.17,13.69-.47,20.48-.87,4.07-.23,8.13-.52,12.18-.84,7.1-.56,14.16-1.25,21.18-2.04,17.54-2.01,34.87-4.76,51.92-8.22Z" />
                        <path class="cls-1"
                            d="M243.68,0v7.03c-17.06,3.45-34.38,6.18-51.92,8.17-7.03.79-14.08,1.47-21.18,2.02-4.05.32-8.11.6-12.18.83-6.79.4-13.63.69-20.48.85-5.21.13-10.45.2-15.7.2-5.28,0-10.55-.07-15.8-.2-7.08-.17-14.11-.48-21.13-.89-4.07-.24-8.13-.53-12.18-.85-6.88-.54-13.73-1.21-20.54-1.97C34.8,13.17,17.27,10.39,0,6.88V.02c17.27,3.5,34.81,6.27,52.56,8.26,6.81.77,13.66,1.42,20.54,1.97,4.05.31,8.11.6,12.18.83,7.02.42,14.05.71,21.13.88,5.11.13,10.23.19,15.37.19,5.39,0,10.77-.07,16.12-.21,6.85-.17,13.69-.47,20.48-.86,4.07-.24,8.13-.52,12.18-.84,7.1-.56,14.15-1.24,21.18-2.04,17.54-2,34.87-4.74,51.92-8.2Z" />
                        <path class="cls-1"
                            d="M52.57,116.29c-.07,0-.14-.01-.21-.02C34.67,114.26,17.21,111.49,0,108v-6.86c17.21,3.48,34.68,6.23,52.36,8.22.07,0,.14.02.21.02v6.91Z" />
                        <path class="cls-1"
                            d="M52.57,95.23c-.07-.01-.14-.02-.21-.03C34.67,93.03,17.2,90.09,0,86.44v-6.86c17.2,3.65,34.67,6.57,52.36,8.73.07.01.14.02.21.02v6.9Z" />
                        <path class="cls-1"
                            d="M52.57,75.61c-.07-.01-.14-.02-.21-.03C34.67,73.42,17.2,70.49,0,66.83v-6.85c17.2,3.64,34.67,6.56,52.36,8.71.07,0,.14.02.21.02v6.9Z" />
                        <path class="cls-1"
                            d="M52.57,56.16c-.14-.02-.28-.03-.42-.05C34.52,53.94,17.13,51.03,0,47.39v-6.86c17.13,3.64,34.52,6.54,52.15,8.68.14.02.28.03.42.05v6.9Z" />
                        <path class="cls-1"
                            d="M122.12,78.95c-5.21,0-10.41-.07-15.59-.21h-.11s0-6.93,0-6.93h.11c5.04.13,10.09.19,15.16.19,5.42,0,10.83-.07,16.22-.22v6.96c-5.25.13-10.51.21-15.79.21Z" />
                        <path class="cls-1"
                            d="M122.33,59.17c-5.28,0-10.55-.07-15.8-.21h-.11s0-6.93,0-6.93h.11c5.11.13,10.23.19,15.37.19,5.35,0,10.69-.07,16.01-.21v6.95c-5.17.14-10.37.21-15.58.21Z" />
                    </g>
                </svg>
                <h1><a href="https://pianotoguitar.com/" title="PianoToGuitar.com">
                        PianoToGuitar.com</a></h1>
                <div class="versionDescription"><strong>ALPHA</strong><br>Last Update: {{BUILD_DATE}}</div>
            </div>
            <div id="introductionHeader">
                <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <title>Show / Hide User Guide</title>
                    <desc>Icon to show or hide the introduction information
                        to get new users started</desc>
                    <path
                        d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z" />
                </svg>
            </div>
        </div>

        <div class="introduction">

            <div id="introductionContent">
                <div class="introductionWrapper">
                    <div class="introductionContentText">
                        <h3>PianoToGuitar is a tool that helps you find
                            guitar chords for all types of guitar tunings.
                            It rates each chord based on how good it sounds
                            and how difficult it is to play.<br>You
                            can search for chords in several ways: by
                            searching chords by name, by selecting the piano
                            keys,
                            or by connecting a MIDI device and playing the
                            chord directly.</h3>
                    </div>
                    <div class="introductionContentItemWrapper">
                        <div class="introductionContentItem">
                            <svg xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                                <path
                                    d="M278.5 215.6L23 471c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l74.8-74.8c7.4 4.6 15.3 8.2 23.8 10.5C200.3 452.8 270 454.5 338 409.4c12.2-8.1 5.8-25.4-8.8-25.4l-16.1 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l97.7-29.3c3.4-1 6.4-3.1 8.4-6.1c4.4-6.4 8.6-12.9 12.6-19.6c6.2-10.3-1.5-23-13.5-23l-38.6 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l80.9-24.3c4.6-1.4 8.4-4.8 10.2-9.3C494.5 163 507.8 86.1 511.9 36.8c.8-9.9-3-19.6-10-26.6s-16.7-10.8-26.6-10C391.5 7 228.5 40.5 137.4 131.6C57.3 211.7 56.7 302.3 71.3 356.4c2.1 7.9 12 9.6 17.8 3.8L253.6 195.8c6.2-6.2 16.4-6.2 22.6 0c5.4 5.4 6.1 13.6 2.2 19.8z" />
                            </svg>
                            <div class="introductionContentItemHeader">Best Capo placement</div>
                            <div class="introductionContentItemText">Automatically find the best Capo placement for any
                                progression while retaining the original key!</div>
                        </div>
                        <div class="introductionContentItem">
                            <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px"
                                fill="currentColor">
                                <title>MIDI Support</title>
                                <path
                                    d="M180-120q-24 0-42-18t-18-42v-600q0-23 18-41.5t42-18.5h600q23 0 41.5 18.5T840-780v600q0 24-18.5 42T780-120H180Zm0-60h157v-210h-20q-12.75 0-21.37-8.63Q287-407.25 287-420v-360H180v600Zm443 0h157v-600H673v360q0 12.75-8.62 21.37Q655.75-390 643-390h-20v210Zm-246 0h206v-210h-20q-12.75 0-21.37-8.63Q533-407.25 533-420v-360H427v360q0 12.75-8.62 21.37Q409.75-390 397-390h-20v210Z" />
                            </svg>
                            <div class="introductionContentItemHeader">MIDI
                                Support</div>
                            <div class="introductionContentItemText">Use
                                your MIDI Device to quickly search Chords!
                            </div>
                        </div>
                        <div class="introductionContentItem">
                            <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px"
                                fill="currentColor">
                                <title>Custom Guitar Tunings</title>
                                <path
                                    d="M231.82-160q-12.82 0-21.32-8.63-8.5-8.62-8.5-21.37v-264h-52q-12.75 0-21.37-8.68-8.63-8.67-8.63-21.5 0-12.82 8.63-21.32 8.62-8.5 21.37-8.5h164q12.75 0 21.38 8.68 8.62 8.67 8.62 21.5 0 12.82-8.62 21.32-8.63 8.5-21.38 8.5h-52v264q0 12.75-8.68 21.37-8.67 8.63-21.5 8.63Zm0-414q-12.82 0-21.32-8.63-8.5-8.62-8.5-21.37v-166q0-12.75 8.68-21.38 8.67-8.62 21.5-8.62 12.82 0 21.32 8.62 8.5 8.63 8.5 21.38v166q0 12.75-8.68 21.37-8.67 8.63-21.5 8.63ZM398-615q-12.75 0-21.37-8.68-8.63-8.67-8.63-21.5 0-12.82 8.63-21.32 8.62-8.5 21.37-8.5h52v-95q0-12.75 8.68-21.38 8.67-8.62 21.5-8.62 12.82 0 21.32 8.62 8.5 8.63 8.5 21.38v95h52q12.75 0 21.38 8.68 8.62 8.67 8.62 21.5 0 12.82-8.62 21.32-8.63 8.5-21.38 8.5H398Zm81.82 455q-12.82 0-21.32-8.63-8.5-8.62-8.5-21.37v-335q0-12.75 8.68-21.38 8.67-8.62 21.5-8.62 12.82 0 21.32 8.62 8.5 8.63 8.5 21.38v335q0 12.75-8.68 21.37-8.67 8.63-21.5 8.63Zm248 0q-12.82 0-21.32-8.63-8.5-8.62-8.5-21.37v-97h-52q-12.75 0-21.37-8.68-8.63-8.67-8.63-21.5 0-12.82 8.63-21.32 8.62-8.5 21.37-8.5h164q12.75 0 21.38 8.68 8.62 8.67 8.62 21.5 0 12.82-8.62 21.32-8.63 8.5-21.38 8.5h-52v97q0 12.75-8.68 21.37-8.67 8.63-21.5 8.63Zm0-247q-12.82 0-21.32-8.63-8.5-8.62-8.5-21.37v-333q0-12.75 8.68-21.38 8.67-8.62 21.5-8.62 12.82 0 21.32 8.62 8.5 8.63 8.5 21.38v333q0 12.75-8.68 21.37-8.67 8.63-21.5 8.63Z" />
                            </svg>
                            <div class="introductionContentItemHeader">Custom
                                Guitar Tuning</div>
                            <div class="introductionContentItemText">Supports
                                <strong> all </strong> Guitar
                                Tunings!<br>Use
                                the Settings to change the Guitar
                                Tuning.
                            </div>
                        </div>
                        <div class="introductionContentItem">
                            <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px"
                                fill="currentColor">
                                <title>Adjust Difficulty</title>
                                <path
                                    d="m643-273 44-41q7-7 7-15.5t-7-15.5L535-497q5-14 8-27t3-27q0-58-41-99t-99-41q-11 0-21 1.5t-20 5.5q-9 5-13 13t2 14l73 72-54 51-71-70q-5-5-13-4t-11 9q-5 11-7 23.5t-2 24.5q0 57 40 96.5t97 39.5q14 0 27.5-2.5T461-425l151 152q6 6 15.5 6t15.5-6ZM480-80q-82 0-155-31.5t-127.5-86Q143-252 111.5-325T80-480q0-83 31.5-156t86-127Q252-817 325-848.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 82-31.5 155T763-197.5q-54 54.5-127 86T480-80Zm0-60q142 0 241-99.5T820-480q0-142-99-241t-241-99q-141 0-240.5 99T140-480q0 141 99.5 240.5T480-140Zm0-340Z" />
                            </svg>
                            <div class="introductionContentItemHeader">Adjust
                                Difficulty</div>
                            <div class="introductionContentItemText">Adjust
                                everything to your skill Level.<br>Use the
                                settings to change how many frets a Chord
                                can span</div>
                        </div>
                        <div class="introductionContentItem">
                            <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px"
                                fill="#e8eaed">
                                <title>Algorithmic Chords</title>
                                <path
                                    d="M480-80q-27 0-47.5-13T406-129h-14q-24 0-42-18t-18-42v-143q-66-43-104-110t-38-148q0-121 84.5-205.5T480-880q121 0 205.5 84.5T770-590q0 81-38 148T628-332v143q0 24-18 42t-42 18h-14q-6 23-26.5 36T480-80Zm-88-109h176v-44H392v44Zm0-84h176v-40H392v40Zm-9-100h74v-137l-92-92 31-31 84 84 84-84 31 31-92 92v137h74q60-28 96.5-87T710-590q0-97-66.5-163.5T480-820q-97 0-163.5 66.5T250-590q0 71 36.5 130t96.5 87Zm97-176Zm0-48Z" />
                            </svg>
                            <div class="introductionContentItemHeader">Algorithmic
                                Chords</div>
                            <div class="introductionContentItemText">Find
                                new and undiscovered Chords<br>We use
                                algorithms to generate <strong> all
                                </strong> possible Chords.</div>
                        </div>
                    </div>
                    <div class="introductionContentText">
                    </div>
                </div>

                <script>
                    var coll = document.getElementById("introductionHeader");
                    var content = document.getElementById("introductionContent");

                    // Function to toggle the introduction state
                    function toggleIntroduction() {
                        coll.classList.toggle("active");
                        if (content.style.maxHeight) {
                            content.style.maxHeight = null;
                            localStorage.setItem("isIntroductionOpen", "false");
                        } else {
                            // Dynamically measure the required height
                            content.style.maxHeight = content.scrollHeight * 2 + "px";;
                            localStorage.setItem("isIntroductionOpen", "true");
                        }
                    }

                    // Event listener for the introduction header
                    coll.addEventListener("click", toggleIntroduction);

                    // Check local storage and set the initial state
                    window.onload = function () {
                        if (localStorage.getItem("isIntroductionOpen") === "true") {
                            coll.classList.add("active");
                            content.style.maxHeight = content.scrollHeight * 2 + "px";;
                        } else if (localStorage.getItem("isIntroductionOpen") === null) {
                            // If visiting for the first time, open the introduction by default
                            toggleIntroduction();
                        }
                    };
                </script>
            </div>
        </div>
        <div class="inputWrapper">
            <div id="closeSettings" onClick="toggleSettings()"></div>
            <div id="settings">
                <div class="settingsHeader">Settings</div>
                <div class="settingsContent">
                    <div class="settingsItem">
                        <div class="settingsInfo">

                            <div class="settingsSubHeader">
                                <div>Guitar Tuning</div>
                            </div>
                            <div class="settingSubDescription">
                                Choose a common tuning from the dropdown or
                                adjust each string's pitch manually with the
                                sliders.
                            </div>
                        </div>
                        <select id="settingsCommonTunings">
                            <option value="40 45 50 55 59 64">Standard (E A
                                D G B E)</option>
                            <option value="38 45 50 55 59 64">Drop D (D A D
                                G B E)</option>
                            <option value="38 45 50 55 57 62">DADGAD (D A D
                                G A D)</option>
                            <option value="38 43 50 55 59 62">Open G (D G D
                                G B D)</option>
                            <option value="38 45 50 54 57 62">Open D (D A D
                                F# A D)</option>
                            <option value="40 47 52 56 59 64">Open E (E B E
                                G# B E)</option>
                            <option value="36 43 48 55 60 64">Open C (C G C
                                G C E)</option>
                            <option value="38 45 50 55 59 62">Double Drop D
                                (D A D G B D)</option>
                            <option value>Custom</option>
                        </select>
                        <div class="settingsStringTuning">
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue6">A</div>
                                <input class="settingsStringSlider string6" id="settingsString6" type="range" min="59"
                                    max="70" value="64">
                            </div>
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue5">A</div>
                                <input class="settingsStringSlider string5" id="settingsString5" type="range" min="54"
                                    max="65" value="59">
                            </div>
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue4">A</div>
                                <input class="settingsStringSlider string4" id="settingsString4" type="range" min="50"
                                    max="61" value="55">
                            </div>
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue3">A</div>
                                <input class="settingsStringSlider string3" id="settingsString3" type="range" min="45"
                                    max="56" value="50">
                            </div>
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue2">A</div>
                                <input class="settingsStringSlider string2" id="settingsString2" type="range" min="40"
                                    max="51" value="45">
                            </div>
                            <div class="settingsStringWrapper">
                                <div class="settingsStringValue" id="settingsStringValue1">A</div>
                                <input class="settingsStringSlider string1" id="settingsString1" type="range" min="35"
                                    max="46" value="40">
                            </div>
                        </div>

                    </div>
                    <div class="settingsItem">
                        <div class="settingsInfo">
                            <div class="settingsSubHeader">
                                <div>Maximum Frets</div>
                            </div>
                            <div class="settingSubDescription">
                                Set the maximum number of frets a chord can
                                span.
                            </div>
                        </div>
                        <div class="settingsFretWrapper">
                            <div class="settingsFretSliderWrapper">
                                <div class="settingsFretBarSeparator"></div>
                                <div class="settingsFretBar selected">1</div>
                                <div class="settingsFretBarSeparator"></div>
                                <div class="settingsFretBar ">2</div>
                                <div class="settingsFretBarSeparator"></div>
                                <div class="settingsFretBar ">3</div>
                                <div class="settingsFretBarSeparator"></div>
                                <div class="settingsFretBar ">4</div>
                                <div class="settingsFretBarSeparator"></div>
                                <div class="settingsFretBar ">5</div>
                                <div class="settingsFretBarSeparator"></div>
                            </div>
                            <div id="settingsFretValue">4 Frets</div>

                        </div>
                    </div>
                </div>
                <div class="settingsFooter">
                    <div class="advancedSettingsButton" onclick="toggleAdvSettings()">
                        <div>ADVANCED</div><svg xmlns="http://www.w3.org/2000/svg" height="24px"
                            viewBox="0 -960 960 960" width="24px" class=" visualIcon" class="visualIcon">
                            <title>Toggle Advanced Settings</title>
                            <path
                                d="m620-284 56-56q6-6 6-14t-6-14L540-505q4-11 6-22t2-25q0-57-40.5-97.5T410-690q-11 0-21 1t-20 5q-9 4-11 14t5 17l74 74-56 56-74-74q-7-7-17-5t-14 11q-3 10-4.5 20t-1.5 21q0 57 40.5 97.5T408-412q13 0 24.5-2t22.5-6l137 136q6 6 14 6t14-6ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                        </svg>
                    </div>
                    <div onClick="toggleSettings()"><svg xmlns="http://www.w3.org/2000/svg" class=" visualIcon"
                            height="48px" viewBox="0 -960 960 960" width="48px" fill="currentColor">
                            <title>Confirm and Leave Settings</title>
                            <path
                                d="m378-332 363-363q9.27-9 21.64-9 12.36 0 21.36 9.05 9 9.06 9 21.5 0 12.45-9 21.45L399-267q-9 9-21 9t-21-9L175-449q-9-9.07-8.5-21.53.5-12.47 9.55-21.47 9.06-9 21.5-9 12.45 0 21.45 9l159 160Z" />
                        </svg></div>

                </div>
                <div id="settingsAdvanced" class>
                    <div class="settingsHeader">Advanced Settings</div>
                    <div class="settingsAdvancedContent">
                        <div class="settingsItem">
                            <div class="settingsInfo">
                                <div class="settingsSubHeader">
                                    Muted Strings Permutation
                                </div>
                                <div class="settingSubDescription">
                                    When this setting is enabled, the chord
                                    generator will consider every possible
                                    configuration of muted strings, even if
                                    some strings could be played.<br>If
                                    disabled,
                                    the chord generator avoids unnecessarily
                                    muting strings.<br><br>⚠️ May lead to
                                    excessive chords and slow loading.
                                </div>
                            </div>
                            <div class="checkbocWrapper">
                                <input id="settingsmutePermutations" type="checkbox" /><label
                                    for="settingsmutePermutations"></label>
                            </div>
                        </div>
                        <div class="settingsItem">
                            <div class="settingsInfo">
                                <div class="settingsSubHeader">
                                    Start with Root
                                </div>
                                <div class="settingSubDescription">
                                    If enabled, the lowest note of a chord
                                    will always be the root note.<br>If
                                    disabled,
                                    chords can start with any note that is
                                    part of the chord.
                                </div>
                            </div>
                            <div class="checkbocWrapper">
                                <input id="settingsStartWithRoot" type="checkbox" /><label
                                    for="settingsStartWithRoot"></label>
                            </div>
                        </div>
                        <div class="settingsItem">
                            <div class="settingsInfo">
                                <div class="settingsSubHeader">
                                    Trailaing
                                </div>
                                <div class="settingSubDescription">
                                    Trailing manages the reuse of previously
                                    used notes in chord generation. When
                                    enabled, notes used in a chord are
                                    temporarily unavailable, making them
                                    less likely
                                    to appear in subsequent chords. This
                                    helps create fewer chords with muted
                                    strings in
                                    them. <br><br>⚠️ Some good chords may be
                                    missed.
                                </div>
                            </div>
                            <div class="checkbocWrapper">
                                <input id="settingsTrailing" type="checkbox" /><label for="settingsTrailing"></label>
                            </div>
                        </div>
                    </div>
                    <div class="settingsFooter">
                        <div class="advancedSettingsButton" onclick="toggleAdvSettings()">
                            <div>ADVANCED</div><svg xmlns="http://www.w3.org/2000/svg" height="24px"
                                viewBox="0 -960 960 960" width="24px" class=" visualIcon" class="visualIcon">
                                <title>Toggle Advanced Settings</title>

                                <path
                                    d="m620-284 56-56q6-6 6-14t-6-14L540-505q4-11 6-22t2-25q0-57-40.5-97.5T410-690q-11 0-21 1t-20 5q-9 4-11 14t5 17l74 74-56 56-74-74q-7-7-17-5t-14 11q-3 10-4.5 20t-1.5 21q0 57 40.5 97.5T408-412q13 0 24.5-2t22.5-6l137 136q6 6 14 6t14-6ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                            </svg>
                        </div>
                        <div onClick="toggleSettings()"><svg xmlns="http://www.w3.org/2000/svg" class=" visualIcon"
                                height="48px" viewBox="0 -960 960 960" width="48px" fill="currentColor">
                                <title>Confirm and Leave Settings</title>

                                <path
                                    d="m378-332 363-363q9.27-9 21.64-9 12.36 0 21.36 9.05 9 9.06 9 21.5 0 12.45-9 21.45L399-267q-9 9-21 9t-21-9L175-449q-9-9.07-8.5-21.53.5-12.47 9.55-21.47 9.06-9 21.5-9 12.45 0 21.45 9l159 160Z" />
                            </svg></div>

                    </div>
                </div>
            </div>
            <div class="searchHeaderWrapper">
                <div>
                    <div class="searchHeader">
                        Search Chords</div>
                    <div class="searchSubHeader">Click a chord to add it to your progression.<br>Double-click a piano
                        key to set it as the root note</div>
                </div>
                <div class="settingsWrapper" onclick="toggleSettings()">
                    <div class="settingsWrapperText">SETTINGS</div>
                    <svg class="visualIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" height="24"
                        viewBox="0 -960 960 960" width="24">
                        <title>Settings</title>
                        <desc>Change guitar tuning and guitar fret range.
                            Modify how chords are generated in the
                            advanced settings.</desc>

                        <path
                            d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" />
                    </svg>
                </div>
            </div>
            <div class="searchContainer">
                <div class="visualPianoContainer">
                    <div class="pianoMIDIWrapper">

                        <div class="pianoContainer"></div>
                        <select id="MIDIStatusDiv" title="Choose a MIDI device from the list">
                            <!-- options will go here -->
                        </select>
                    </div>
                    <div class="pianoIconContainer">
                        <svg class="visualIcon" id="midiToggleIcon" xmlns="http://www.w3.org/2000/svg"
                            onclick="toggleMIDI()" height="24" style="display: none;" viewBox="0 -960 960 960" width="24">
                            <title>Toggle MIDI</title>
                            <desc>Toogle MIDI on / off</desc>
                            <path d="M180-120q-24 0-42-18t-18-42v-600q0-23 18-41.5t42-18.5h600q23 0 41.5 18.5T840-780v600q0 24-18.5 42T780-120H180Zm0-60h157v-210h-20q-12.75 0-21.37-8.63Q287-407.25 287-420v-360H180v600Zm443 0h157v-600H673v360q0 12.75-8.62 21.37Q655.75-390 643-390h-20v210Zm-246 0h206v-210h-20q-12.75 0-21.37-8.63Q533-407.25 533-420v-360H427v360q0 12.75-8.62 21.37Q409.75-390 397-390h-20v210Z"/>
                        </svg>
                        <svg class="visualIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg"
                            onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24">
                            <title>Toggle Piano Volume</title>
                            <desc>Mute / Unmute the Piano sound.</desc>

                            <path
                                d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" />
                        </svg>
                        <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24"
                            viewBox="0 -960 960 960" width="24">
                            <title>Play Chord</title>
                            <desc>Plays the selected Keys</desc>

                            <path
                                d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                        </svg>
                        <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24"
                            viewBox="0 -960 960 960" width="24">
                            <title>Clear Piano Keys</title>
                            <desc>Removes all selected Keys</desc>

                            <path fill="currentColor"
                                d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                        </svg>
                    </div>
                </div>
                <div class="searchWordContainer">
                    <div class="blackFadeBottom"></div>
                    <input class="searchBox" type="text" id="itemSearch"
                        placeholder="Search chord name - Click Chord to add">
                    <div class="searchChordList" id="itemsContainer">
                        <!-- Items will be populated here by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="selectedItemsHeading">
                <div class="selectedItemsHeaderText">Your Selected
                    Progression</div>
                <div id="scaleDisplay"></div>
            </div>
            <div class="selectedItemsWrapper">
                <div class="selectedItems" id="selectedItems">
                    <!-- Dragged items will appear here -->
                </div>

                <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24"
                    viewBox="0 -960 960 960" width="24">
                    <title>Clear Progression</title>
                    <desc>Remove all selected chords from the current
                        progression</desc>

                    <path fill="currentColor"
                        d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" />
                </svg>
            </div>

        </div>
        <div class="outputWrapper" id="outputWrapper">
            <div class="progression">
                <div class="progressionInfo">
                    <div class="progressionInfoText">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                            <title>Easy Progression</title>
                            <path
                                d="M278.5 215.6L23 471c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l74.8-74.8c7.4 4.6 15.3 8.2 23.8 10.5C200.3 452.8 270 454.5 338 409.4c12.2-8.1 5.8-25.4-8.8-25.4l-16.1 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l97.7-29.3c3.4-1 6.4-3.1 8.4-6.1c4.4-6.4 8.6-12.9 12.6-19.6c6.2-10.3-1.5-23-13.5-23l-38.6 0c-5.1 0-9.2-4.1-9.2-9.2c0-4.1 2.7-7.6 6.5-8.8l80.9-24.3c4.6-1.4 8.4-4.8 10.2-9.3C494.5 163 507.8 86.1 511.9 36.8c.8-9.9-3-19.6-10-26.6s-16.7-10.8-26.6-10C391.5 7 228.5 40.5 137.4 131.6C57.3 211.7 56.7 302.3 71.3 356.4c2.1 7.9 12 9.6 17.8 3.8L253.6 195.8c6.2-6.2 16.4-6.2 22.6 0c5.4 5.4 6.1 13.6 2.2 19.8z" />
                        </svg>
                        <div class="progressionInfoTextWrapper">
                            <div class="progressionInfoTextName"><i>EASY</i></div>
                            <div class="progressionInfoTextSubtitle">
                                Utilize a capo to ease playability while preserving the progression's key.<br>
                                Best capo spots suggested. Click to change. <span class="darker"> (min 2 Chords)</span>
                            </div>
                            <div id="easyProgressionCapoWrapper">
                                Capo:
                                <div id="easyProgressionCapo"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="progressionWrapper" id="easyProgressionWrapper"></div>
            </div>
            <div class="progression">
                <div class="progressionInfo">
                    <div class="progressionInfoText">
                        <div>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                <title>Dynamic Progression</title>
                                <path
                                    d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z" />
                            </svg>
                        </div>
                        <div class="progressionInfoTextWrapper">
                            <div class="progressionInfoTextName"><i>DYNAMIC</i></div>
                            <div class="progressionInfoTextSubtitle">Adjust
                                the slider to transition from simple chords
                                to
                                the
                                most beautifully sounding ones!
                            </div>
                        </div>
                    </div>
                    <div class="soundQualityWrapper">
                        <input class="slider" id="soundQualitySlider" type="range" min="0" max="100" value="70">
                        <div class="sliderLables">
                            <div>EASY</div>
                            <div>BEST SOUND</div>
                        </div>
                    </div>
                </div>
                <div class="progressionWrapper" id="dynamicProgressionWrapper"></div>
            </div>

            <div class="progression">
                <div class="progressionInfo">
                    <div class="progressionInfoText">
                        <div>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512">
                                <title>Transpose Progression</title>
                                <path
                                    d="M145.6 7.7C141 2.8 134.7 0 128 0s-13 2.8-17.6 7.7l-104 112c-6.5 7-8.2 17.2-4.4 25.9S14.5 160 24 160H80V352H24c-9.5 0-18.2 5.7-22 14.4s-2.1 18.9 4.4 25.9l104 112c4.5 4.9 10.9 7.7 17.6 7.7s13-2.8 17.6-7.7l104-112c6.5-7 8.2-17.2 4.4-25.9s-12.5-14.4-22-14.4H176V160h56c9.5 0 18.2-5.7 22-14.4s2.1-18.9-4.4-25.9l-104-112z" />
                            </svg>
                        </div>
                        <div class="progressionInfoTextWrapper">
                            <div class="progressionInfoTextName"><i>TRANSPOSE</i></div>
                            <div class="progressionInfoTextSubtitle">Shift your chord progression up or down by
                                semitones to adjust the pitch.</div>

                        </div>
                    </div>
                    <div class="soundQualityWrapper">
                        <input class="slider" id="transposeSlider" type="range" min="-6" max="6" value="0">
                        <div class="sliderLables soundTranspoLables">
                            <div data-value="-6">-6</div>
                            <div data-value="-5">-5</div>
                            <div data-value="-4">-4</div>
                            <div data-value="-3">-3</div>
                            <div data-value="-2">-2</div>
                            <div data-value="-1">-1</div>
                            <div data-value="0" class="active">0</div>
                            <div data-value="1">+1</div>
                            <div data-value="2">+2</div>
                            <div data-value="3">+3</div>
                            <div data-value="4">+4</div>
                            <div data-value="5">+5</div>
                            <div data-value="6">+6</div>


                        </div>
                    </div>
                </div>
                <div class="progressionWrapper" id="transposedProgressionWrapper"></div>
            </div>
        </div>
    </div>
    <footer>
        <div class="footerItem">
            <div>PianoToGuitar.com
                <br>© 2024 Lukas Marschhausen
            </div>
        </div>
        <div class="footerItem">
            <a href="https://discord.gg/cXVU96cqPm" target="_blank"
                title="Join our Discord Community for Suggestions and Improvements">
                <div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 127.14 96.36">
                        <title>Discord Icon</title>
                        <path fill="#fff"
                            d="M107.7,8.07A105.15,105.15,0,0,0,81.47,0a72.06,72.06,0,0,0-3.36,6.83A97.68,97.68,0,0,0,49,6.83,72.37,72.37,0,0,0,45.64,0,105.89,105.89,0,0,0,19.39,8.09C2.79,32.65-1.71,56.6.54,80.21h0A105.73,105.73,0,0,0,32.71,96.36,77.7,77.7,0,0,0,39.6,85.25a68.42,68.42,0,0,1-10.85-5.18c.91-.66,1.8-1.34,2.66-2a75.57,75.57,0,0,0,64.32,0c.87.71,1.76,1.39,2.66,2a68.68,68.68,0,0,1-10.87,5.19,77,77,0,0,0,6.89,11.1A105.25,105.25,0,0,0,126.6,80.22h0C129.24,52.84,122.09,29.11,107.7,8.07ZM42.45,65.69C36.18,65.69,31,60,31,53s5-12.74,11.43-12.74S54,46,53.89,53,48.84,65.69,42.45,65.69Zm42.24,0C78.41,65.69,73.25,60,73.25,53s5-12.74,11.44-12.74S96.23,46,96.12,53,91.08,65.69,84.69,65.69Z" />
                    </svg></div>
            </a>
            <div>Share your suggestions on Discord!</div>

        </div>
    </footer>

</body>

</html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js';
import Piano from './piano/script.js';
import { Chord, ChordLibrary } from "./chord-library/script.js"
import MIDIAccessManager from "./midi-integration/script.js"
import { ProgressionGenerator } from './progression-generator/main.js';
import { settings } from './chord-factory/constants.js';
import { noteToNumber, numberToNote } from "./chord-factory/utils.js";



document.addEventListener('DOMContentLoaded', () => {
    function debounce(func, wait) {
        let timeout;
        return function () {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }



    // Import the MidiManager
    const midiManager = new MIDIAccessManager();

    const MIDIStatusDiv = document.getElementById('MIDIStatusDiv');

    MIDIStatusDiv.style.display = "none";


    // Event listener to update the device list when devices change
    window.addEventListener('MIDIdeviceChange', (event) => {
        const devices = event.detail.devicelist; // Receive the detailed list of devices
        if (!devices.length) {
            MIDIStatusDiv.style.display = "none";
            midiToggleIcon.style.display = "none"; // Hide the MIDI toggle icon if no devices
            return;
        }

        MIDIStatusDiv.innerHTML = ''; // Clear existing options

        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.name;
            option.textContent = "MIDI: " + device.name;
            MIDIStatusDiv.appendChild(option);
        });

        MIDIStatusDiv.style.display = "flex";
        midiToggleIcon.style.display = "flex"; // Show the MIDI toggle icon when devices are connected

        // Restore the selected device if it is available, or set the first device as default
        if (MIDIStatusDiv.querySelector(`option[value="${event.detail.selectedDeviceName}"]`)) {
            MIDIStatusDiv.value = event.detail.selectedDeviceName;
        } else {
            midiManager.setMIDIDevice(devices[0].name);
            MIDIStatusDiv.value = devices[0].name;
        }
    });


    document.getElementById('MIDIStatusDiv').addEventListener('change', function () {
        const selectedDeviceId = this.value;
        midiManager.setMIDIDevice(selectedDeviceId);
    });

    // Event listener to update the device list when devices change

    // Initial update on page load















    var visualPianoOctaves = 3


    // Function to calculate the number of octaves based on screen width
    function calculateOctaves() {
        const screenWidth = window.innerWidth;
        const maxOctaves = 3; // Base octaves to start with
        const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25);
        visualPianoOctaves = Math.min(maxOctaves, extraOctaves)
        return visualPianoOctaves;
    }



    // Create a new Piano instance with dynamic number of octaves
    const myPiano = new Piano('.pianoContainer', { octaves: calculateOctaves() });


    // Get All Chords From the Libaray
    const chordLibrary = new ChordLibrary

    // Create the Search and Drag and Drop

    const allChordLibraryItems = chordLibrary.getAllChords()


    const dropzone = 'selectedItems';
    const itemsContainer = "itemsContainer";
    const itemSearch = "itemSearch";
    const selectedItems = "selectedItems";
    const emptyMessageContainer = "emptyMessageContainer";
    const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer);

    var isVolumeOn
    const volumeIcon = document.getElementById('volumeIcon');




    function setPianoVolume(state = true) {
        if (state == "off") {
            console.error("TRIGGERED OFF", localStorage.getItem('volumeState'))

            myPiano.volumeOff()
            localStorage.setItem('volumeState', "off");
            isVolumeOn = false;
            volumeIcon.innerHTML = `<title>Unmute Piano</title><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"/>`;
            return
        } else {
            console.error("TRIGGERED ON", localStorage.getItem('volumeState'))

            myPiano.volumeOn()
            localStorage.setItem('volumeState', "on");
            isVolumeOn = true;
            volumeIcon.innerHTML = `<title>Mute Piano</title><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"/>`;
            return
        }
    }
    setPianoVolume(localStorage.getItem('volumeState'))

    window.toggleVolume = function () {
        if (isVolumeOn) {
            setPianoVolume("off")
        } else {
            setPianoVolume("on")

        }
    };



    window.playPiano = function () {
        setPianoVolume(true)
        myPiano.playChord();
        console.log("Piano played");
    };


    window.clearPiano = function () {
        document.getElementById("itemSearch").value = ""
        myPiano.clearPiano();
        console.log("Piano cleared");
    };

    window.clearProgression = function () {
        dragAndDropList.clearSelectedList();
        console.log("Selected Items cleared");
    };

    // Handle window resize to adjust the number of octaves dynamically
    window.onresize = function () {
        const newOctaves = calculateOctaves();
        myPiano.setOctaves(newOctaves); // Assuming there's a method to update the octaves dynamically
    };













    // MIDI state variable
    let isMIDIOn = localStorage.getItem('MIDIState') === 'on';

    const midiToggleIcon = document.getElementById('midiToggleIcon');

    function setMIDIState(state = true) {
        if (state === "off") {
            localStorage.setItem('MIDIState', "off");
            MIDIStatusDiv.style.textDecoration = "line-through"
            MIDIStatusDiv.style.opacity = 0.8
            MIDIStatusDiv.style.color="#ff5555"

            isMIDIOn = false;
            midiToggleIcon.innerHTML = `<title>Enable MIDI</title><desc>Enable MIDI input</desc><path d="m813-61-59-59H180q-24.75 0-42.37-17.63Q120-155.25 120-180v-574l-59-59 43-43 752 752-43 43Zm27-145-60-60v-514H673v360q0 9-5 17t-14 11L533-513v-267H427v161L206-840h574q24.75 0 42.38 17.62Q840-804.75 840-780v574Zm-660 26h157v-210h-20q-12.75 0-21.37-8.63Q287-407.25 287-420v-167L180-694v514Zm197 0h206v-111L427-447v27q0 13-8.5 21.5T397-390h-20v210Zm246 0h71l-71-71v71Z"/>`;
            midiToggleIcon.style.fill = "#ff5555"
        } else {
            localStorage.setItem('MIDIState', "on");
            MIDIStatusDiv.style.textDecoration = "none"
            MIDIStatusDiv.style.opacity = 1
            MIDIStatusDiv.style.color=""
            isMIDIOn = true;
            midiToggleIcon.innerHTML = `<title>Disable MIDI</title><desc>Disable MIDI input</desc><path d="M180-120q-24 0-42-18t-18-42v-600q0-23 18-41.5t42-18.5h600q23 0 41.5 18.5T840-780v600q0 24-18.5 42T780-120H180Zm0-60h157v-210h-20q-12.75 0-21.37-8.63Q287-407.25 287-420v-360H180v600Zm443 0h157v-600H673v360q0 12.75-8.62 21.37Q655.75-390 643-390h-20v210Zm-246 0h206v-210h-20q-12.75 0-21.37-8.63Q533-407.25 533-420v-360H427v360q0 12.75-8.62 21.37Q409.75-390 397-390h-20v210Z"/>`;
            midiToggleIcon.style.fill = ""

        }
    }

    // Set initial MIDI state based on localStorage
    setMIDIState(isMIDIOn ? "on" : "off");

    window.toggleMIDI = function () {
        if (isMIDIOn) {
            setMIDIState("off");
        } else {
            setMIDIState("on");
        }
    };
















    document.querySelector('.pianoContainer').addEventListener('notesChanged', async (e) => {

        if (document.visibilityState === 'visible') {
            let items
            if (e.detail.notes.length > 0) {
                console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote)
                items = await chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50)
            } else {
                items = allChordLibraryItems
            }
            //dragAndDropList.ceateAndInsertElement(e.detail.notes)
            dragAndDropList.updateItems(items)
        }
        // Additional logic to handle the change in notes}
    });


    //Midi Integration for Pinao Notes 
    let actualPressedKeys = new Map(); // Maps actual notes to their counts
    let visualPressedKeys = new Set();

    function mapNoteToVisualKey(note) {
        return note % (visualPianoOctaves * 12);
    }

    window.addEventListener('noteOn', (e) => {
        if (document.visibilityState === 'visible' && isMIDIOn) {
            const { note } = e.detail;
            const visualKey = mapNoteToVisualKey(note);
            let count = actualPressedKeys.get(note) || 0;
            actualPressedKeys.set(note, count + 1);
            visualPressedKeys.add(visualKey);
            myPiano.activateKey(visualKey);
            updateRootNote();
        }
    });

    window.addEventListener('noteOff', (e) => {
        if (document.visibilityState === 'visible') {
            const { note } = e.detail;
            if (actualPressedKeys.has(note)) {
                let count = actualPressedKeys.get(note);
                if (count > 1) {
                    actualPressedKeys.set(note, count - 1);
                } else {
                    actualPressedKeys.delete(note);
                    // Check if any other actual key maps to the same visual key
                    const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note));
                    if (!anyOther) {
                        visualPressedKeys.delete(mapNoteToVisualKey(note));
                        myPiano.deactivateKey(mapNoteToVisualKey(note));
                    }
                }
            }
            updateRootNote();
        }
    });

    function updateRootNote() {
        if (isMIDIOn) {
            if (actualPressedKeys.size > 0) {
                // Convert actualPressedKeys to an array and sort it
                const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b);

                // Determine if the lowest note should be set as the root note
                const lowestNote = sortedNotes[0];
                const lowestNoteMod12 = lowestNote % 12;
                let setRoot = false;

                // Check if the lowest note is doubled in higher octaves
                if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) {
                    setRoot = true;
                }

                // Check if the lowest note is 12 interval steps away from the second lowest note
                if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6)) {
                    setRoot = true;
                }

                // Set or clear the root note based on the above conditions
                if (setRoot) {
                    const visualKey = mapNoteToVisualKey(lowestNote);
                    myPiano.setRootNote(visualKey);
                } else {
                    myPiano.clearRootNote();
                }
            } else {
                myPiano.clearRootNote();
            }
        }
    }


    /*     window.addEventListener("statusUpdated", async (e) => {
            document.getElementById("MIDIStatusDiv").innerHTML = e.detail
        }) */


    //Functionality to autom,atically add Chord when played by midi:
    window.addEventListener('notesOutput', async (e) => {
        if (document.visibilityState === 'visible' && isMIDIOn) {
            const notes = e.detail;
            if (notes.length > 0) {
                const rootNote = Math.min(...notes);
                const searchResults = await chordLibrary.searchChords(notes, rootNote, 100);
                if (searchResults.length > 0) {
                    const chord = searchResults[0];
                    dragAndDropList.addSelectedItem(chord);
                    //popUp.open("Added: " +chord.name, { autoClose: true, duration: 1000 });
                }
            }
        }
    });



    //Scale Detector Listener
    const scaleDisplay = document.getElementById("scaleDisplay")
    window.addEventListener('scaleDetected', async function (event) {
        scaleDisplay.innerHTML = event.detail.scale
    });







    function updateURLWithChordNames(selectedItems) {
        // Extract chord names from the selected items
        const chordNames = selectedItems.map(item => item.name);

        // Join all chord names into a comma-separated string
        const chordsParam = chordNames.join(',');

        // Create the new URL
        const newURL = `${window.location.pathname}?chords=${encodeURIComponent(chordsParam)}`;

        // Update the URL without reloading the page
        window.history.replaceState({ path: newURL }, '', newURL);
        console.log("URL Updated with Chords: " + newURL);
    }






    function getChordsFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const chordsParam = urlParams.get('chords');
        if (chordsParam) {
            const chordNames = chordsParam.split(',');
            return chordNames.map(decodeURIComponent);
        }
        return [];
    }

    function loadChordsFromURL() {
        const chordNames = getChordsFromURL();
        if (chordNames.length > 0) {
            let chords = chordNames.map(chord => chordLibrary.getChordByName(chord))
            dragAndDropList.loadChords(chords);
            console.log("Chords loaded from URL:", chords);
        }
    }










    let soundQualityValue = 0.7;
    document.getElementById("soundQualitySlider").value = soundQualityValue * 100
    let progressionGenerator = new ProgressionGenerator([], true, chordLibrary, "#ffffff", "onNote", true)

    document.addEventListener('selectedItemsUpdated', async function (event) {
        console.log('Updated Selected Items:', event.detail.selectedItems);
        await progressionGenerator.setProgression(event.detail.selectedItems)
        await updateProgressionDynamic(soundQualityValue)
        await updateProgressionEasy()
        await updateProgressionTransposed()
        updateURLWithChordNames(event.detail.selectedItems);


    });




    const soundQualitySlider = document.getElementById("soundQualitySlider");
    soundQualitySlider.addEventListener('input', async (e) => {
        soundQualityValue = e.target.value / 100;
        console.log("Slider Value:", soundQualityValue, progressionGenerator);
        await updateProgressionDynamic(soundQualityValue)
    });

    async function updateProgressionDynamic(soundQualityValue) {
        let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue);
        document.getElementById("dynamicProgressionWrapper").innerHTML = "";
        document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML);
    };
















    //How many capo suggestions are displayed
    const easyProgressionCapoAmmount = 3

    // Add event listener for transpositionsDetermined event
    window.addEventListener('transpositionsDetermined', (event) => {
        const bestTranspositions = event.detail.bestTranspositions;
        console.log("bestTranspositions:", bestTranspositions)
        let easyProgressionCapo = document.getElementById("easyProgressionCapo");
        let easyProgressionCapoWrapper = document.getElementById("easyProgressionCapoWrapper");

        easyProgressionCapo.innerHTML = ""; // Clear existing content
        if (bestTranspositions == "none") {
            easyProgressionCapoWrapper.style.display = "none"
            return;
        }
        easyProgressionCapoWrapper.style.display = "flex"

        // This array will hold all capo elements to manage classes later
        let capoElements = [];

        for (let i = 0; i < easyProgressionCapoAmmount; i++) {
            let suffix = "";
            let capo = (12 - bestTranspositions[i]) % 12
            switch (capo) {
                case 0:
                    capo = "No Capo"
                    break;
                case 1:
                    suffix = "<sup>st</sup>";  // Unicode for 'st'
                    break;
                case 2:
                    suffix = "<sup>nd</sup>";  // Unicode for 'nd'
                    break;
                case 3:
                    suffix = "<sup>rd</sup>";  // Unicode for 'rd'
                    break;
                default:
                    suffix = "<sup>th</sup>";  // Unicode for 'th'
                    break;
            }

            let capoElement = document.createElement("div");
            capoElement.classList.add("dragDropItem");
            if (i == 0) {
                capoElement.classList.add("active");
            }

            capoElement.id = `easyProgressionCapo-${i}`;
            capoElement.dataset.transposition = i;  // Set data attribute
            capoElement.innerHTML = `${capo}${suffix}`;

            // Attach click event listener
            capoElement.addEventListener('click', function (event) {
                // Remove active class from all capo elements
                capoElements.forEach(el => el.classList.remove('active'));

                // Add active class to the clicked element
                capoElement.classList.add('active');

                const transposition = parseInt(event.currentTarget.dataset.transposition);
                updateProgressionEasy(transposition);
            });

            // Store the capo element in the array
            capoElements.push(capoElement);

            // Append the capo element to the container
            easyProgressionCapo.appendChild(capoElement);
        };
    });

    async function updateProgressionEasy(transposition = 0) {
        let [progressionHTML, capo] = await progressionGenerator.getProgressionEasyHTML(transposition);
        document.getElementById("easyProgressionWrapper").innerHTML = "";
        document.getElementById("easyProgressionWrapper").appendChild(progressionHTML);



    };


    let transposeValue = 0;
    const transposeSlider = document.getElementById("transposeSlider");
    const labels = document.querySelectorAll('.sliderLables div');

    // Event listener for slider input changes
    transposeSlider.addEventListener('input', (e) => {
        transposeValue = parseInt(e.target.value);
        updateSliderValue(transposeValue);
    });

    // Event listener for label clicks
    labels.forEach(label => {
        label.addEventListener('click', (e) => {
            transposeValue = parseInt(e.target.getAttribute('data-value'));
            updateSliderValue(transposeValue);
        });
    });

    // Function to update slider value and handle highlighting
    function updateSliderValue(value) {
        // Update slider value
        transposeSlider.value = transposeValue;

        // Remove 'active' class from all labels
        labels.forEach(label => label.classList.remove('active'));

        // Add 'active' class to the clicked label
        const currentLabel = document.querySelector(`.sliderLables div[data-value="${transposeValue}"]`);
        if (currentLabel) {
            currentLabel.classList.add('active');
        }
        updateProgressionTransposed(transposeValue)
    }

    async function updateProgressionTransposed(transposeValue) {
        let [progressionHTML, capo] = await progressionGenerator.getProgressionTransposedHTML(transposeValue);
        document.getElementById("transposedProgressionWrapper").innerHTML = "";
        document.getElementById("transposedProgressionWrapper").appendChild(progressionHTML);
    };





    document.addEventListener('keydown', function (event) {
        if (event.key === "Escape") { // Check if the pressed key is Escape
            let settingsScreen = document.getElementById("settings");

            // Check if any settings panel is currently visible
            if (settingsScreen.classList.contains('visible')) {
                toggleSettings()
                console.log("Settings panels hidden due to Escape key.");
            }
        }
    });




    //ADVANCED SETTINGS
    window.toggleAdvSettings = async function () {

        let advSettingsScreen = document.getElementById("settingsAdvanced");
        advSettingsScreen.classList.toggle("visible")

    }

    let reloadFlag = false;

    // Make Settings Button functional
    window.toggleSettings = async function () {
        let settingsScreen = document.getElementById("settings");
        let closeSettings = document.getElementById("closeSettings");
        let advSettingsScreen = document.getElementById("settingsAdvanced");


        console.log("Toggle Settings clicked");

        // If the main settings are being closed, also close the advanced settings
        if (settingsScreen.classList.contains('visible') && advSettingsScreen.classList.contains('visible')) {
            advSettingsScreen.classList.remove('visible');
        }

        // Toggle a class that controls the visibility and opacity
        settingsScreen.classList.toggle('visible');
        closeSettings.classList.toggle('visible');

        console.log("Settings screen visibility toggled:", settingsScreen.classList.contains('visible'));

        if (reloadFlag) {
            console.log("Reload flag is true, updating tuning settings.");
            localStorage.setItem('guitarTuning', JSON.stringify(settings.tuning));
            console.warn("Settings at Reload", settings)

            console.log("New tuning saved to localStorage:", settings.tuning);

            await progressionGenerator.reloadProgression();
            console.log("Progression reloaded.");

            await updateProgressionDynamic(soundQualityValue);
            console.log("Progression dynamic updated.");

            await updateProgressionEasy();
            console.log("Progression easy updated.");

            await updateProgressionTransposed();
            console.log("Progression easy updated.");

            reloadFlag = false;
        }
    };

    // Function to load tuning settings into the select elements
    function loadTuningSettings() {
        console.log("Loading tuning settings...");
        if (localStorage.getItem('guitarTuning')) {
            settings.tuning = JSON.parse(localStorage.getItem('guitarTuning'));
            console.log("Stored tuning from localStorage:", settings.tuning);

        }
        settings.tuning.forEach((element, index) => {
            const selectElement = document.getElementById(`settingsString${index + 1}`);
            const displayElement = document.getElementById(`settingsStringValue${index + 1}`);

            displayElement.innerHTML = numberToNote(element);
            selectElement.value = element
        });
    }


    // Add event listeners to the select elements
    for (let i = 0; i < 6; i++) {
        let selectElement = document.getElementById("settingsString" + (i + 1));
        if (selectElement) {
            selectElement.addEventListener('input', () => {
                let displayElement = document.getElementById(`settingsStringValue${i + 1}`);
                displayElement.innerHTML = numberToNote(parseInt(selectElement.value));
                document.getElementById('settingsCommonTunings').value = ""
                settings.tuning[i] = parseInt(selectElement.value);  // Ensure parsing as integer
                reloadFlag = true;
                console.log(`String ${i + 1} tuning changed to:`, settings.tuning[i]);
                checkCommonTunings();  // Check if current tuning matches a common tuning

            });
            console.log(`Event listener added for string ${i + 1}`);
        } else {
            console.warn(`Element with ID settingsString${i + 1} not found.`);
        }
    }



    function setTuning(tuning) {
        const tuningArray = tuning.split(' ').map(Number);
        settings.tuning = tuningArray;

        tuningArray.forEach((value, index) => {
            const selectElement = document.getElementById(`settingsString${index + 1}`);
            const displayElement = document.getElementById(`settingsStringValue${index + 1}`);

            selectElement.value = value;
            displayElement.innerHTML = numberToNote(value);
        });

        reloadFlag = true;
        console.log("Tuning set to:", tuningArray);
        checkCommonTunings(); // Check if the new tuning matches a common tuning
    }

    // Add event listener to dropdown
    document.getElementById('settingsCommonTunings').addEventListener('change', function () {
        if (this.value) {
            setTuning(this.value);
        }
    });

    // Function to compare current tuning with common tunings
    function checkCommonTunings() {
        const dropdown = document.getElementById('settingsCommonTunings');
        const currentTuning = settings.tuning.join(' ');

        let found = false;
        for (let i = 0; i < dropdown.options.length; i++) {
            if (dropdown.options[i].value === currentTuning) {
                dropdown.value = currentTuning;
                found = true;
                break;
            }
        }

        if (!found) {
            dropdown.value = "";
        }
    }




    //FretRange

    // Function to set fret range
    function setFretRange(fret) {
        // Update the fret range display
        const fretValueDisplay = document.getElementById('settingsFretValue');
        fretValueDisplay.textContent = `${fret} Frets`;

        // Update the settings.fretRange
        settings.fingerFretRange = fret;

        // Set the reloadFlag to true
        reloadFlag = true;

        // Update the localStorage
        localStorage.setItem('fretRange', fret);

        // Update the selected fret bar
        const fretBars = document.querySelectorAll('.settingsFretBar');
        fretBars.forEach((bar, index) => {
            if (index < fret) {
                bar.classList.add('selected');
                bar.setAttribute('data-fret', index + 1); // Set data attribute for the selected fret

            } else {
                bar.classList.remove('selected');
                bar.removeAttribute('data-fret'); // Remove data attribute for unselected frets

            }
            bar.textContent = index + 1;
        });

        console.log(`Fret range set to: ${fret} frets`);
    }

    // Add event listeners to the fret bars
    const fretBars = document.querySelectorAll('.settingsFretBar');
    fretBars.forEach((bar, index) => {
        bar.addEventListener('click', () => {
            setFretRange(index + 1);
        });
        console.log(`Event listener added for fret ${index + 1}`);
    });

    // Load the fret range setting from localStorage
    function loadFretRangeSetting() {
        console.log("Loading fret range setting...");
        if (localStorage.getItem('fretRange')) {
            const storedFretRange = parseInt(localStorage.getItem('fretRange'));
            setFretRange(storedFretRange);
            console.log("Stored fret range from localStorage:", storedFretRange);
        } else {
            setFretRange(settings.fingerFretRange)
        }
    }







    //ADVANCED
    //settingsmutePermutations
    document.getElementById('settingsmutePermutations').addEventListener('change', function () {
        settings.mutePermutations = this.checked;
        localStorage.setItem('mutePermutations', this.checked);
        reloadFlag = true; // Ensure the progression is updated
        console.log(`Only mute if necessary set to: ${this.checked}`);
    });

    function loadMuteSetting() {
        console.log("Loading mute setting...");
        if (localStorage.getItem('mutePermutations') !== null) {
            const storedMuteSetting = JSON.parse(localStorage.getItem('mutePermutations'));
            settings.mutePermutations = storedMuteSetting;
            document.getElementById('settingsmutePermutations').checked = storedMuteSetting;
            console.log("Stored mute setting from localStorage:", storedMuteSetting);
        } else {
            settings.mutePermutations = false; // Default value
            document.getElementById('settingsmutePermutations').checked = false;
        }
    }

    //startWithRoot
    document.getElementById('settingsStartWithRoot').addEventListener('change', function () {
        settings.startWithRoot = this.checked;
        localStorage.setItem('startWithRoot', this.checked);
        reloadFlag = true; // Ensure the progression is updated
        console.log(`Start with root set to: ${this.checked}`);
    });

    function loadRootSetting() {
        console.log("Loading root setting...");
        if (localStorage.getItem('startWithRoot') !== null) {
            const storedRootSetting = JSON.parse(localStorage.getItem('startWithRoot'));
            settings.startWithRoot = storedRootSetting;
            document.getElementById('settingsStartWithRoot').checked = storedRootSetting;
            console.log("Stored root setting from localStorage:", storedRootSetting);
        } else {
            settings.startWithRoot = true; // Default value
            document.getElementById('settingsStartWithRoot').checked = true;
        }
    }

    // Trailing Notes
    document.getElementById('settingsTrailing').addEventListener('change', function () {
        settings.trailing = this.checked;
        localStorage.setItem('trailing', this.checked);
        reloadFlag = true; // Ensure the progression is updated
        console.log(`Trailing used notes set to: ${this.checked}`);
    });

    function loadTrailingSetting() {
        console.log("Loading trailing setting...");
        if (localStorage.getItem('trailing') !== null) {
            const storedTrailingSetting = JSON.parse(localStorage.getItem('trailing'));
            settings.trailing = storedTrailingSetting;
            document.getElementById('settingsTrailing').checked = storedTrailingSetting;
            console.log("Stored trailing setting from localStorage:", storedTrailingSetting);
        } else {
            settings.trailing = false; // Default value
            document.getElementById('settingsTrailing').checked = false;
        }
    }

    loadTrailingSetting();
    loadFretRangeSetting();
    loadTuningSettings();
    loadMuteSetting();
    loadRootSetting();
    reloadFlag = false;

    checkCommonTunings();
    updateProgressionDynamic(soundQualityValue);
    updateProgressionEasy();
    updateProgressionTransposed();
    loadChordsFromURL();
})


File: index.html
Path: midi-integration\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Note Logger</title>
</head>
<body>
<h1>MIDI Note Logger</h1>
<div id="status">Waiting for MIDI...</div>
<div id="log"></div>
<script src="script.js"></script>
</body>
</html>


File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 50;
        this.notesPlayed = new Set();
        this.activeNotes = new Set();
        this.selectedDeviceName = localStorage.getItem('selectedMIDIName') || null;

        if (navigator.requestMIDIAccess) {
            this.attemptMIDIAccess();
        } else {
            console.log("Web MIDI API not supported!");
        }
    }


    setMIDIDevice(deviceName) {
        // Store the selected device name in localStorage
        this.selectedDeviceName = deviceName
        localStorage.setItem('selectedMIDIName', deviceName);
    
        // First, disconnect all existing connections
        this.midiAccess.inputs.forEach(input => {
            input.onmidimessage = null;
        });
    
        // Convert inputs to an array and find the device by name
        const devices = Array.from(this.midiAccess.inputs.values());
        let device = devices.find(d => d.name === deviceName);
    
        // If the device is not found, log an error and use the first device in the list
        if (!device) {
            console.error("Device not found:", deviceName);
            device = devices[0]; // Default to the first device if the specified one isn't found
        }
    
        // Set the MIDI message handler
        device.onmidimessage = this.onMIDIMessage.bind(this);
        console.log(`MIDI device set: ${device.name}`);
    
        // Dispatch the event with updated devices list and the selected device name
        this.dispatchMIDIDeviceChange();
    }
    

    dispatchMIDIDeviceChange() {
        window.dispatchEvent(new CustomEvent('MIDIdeviceChange', {
            detail: {
                devicelist: Array.from(this.midiAccess.inputs.values()),
                selectedDeviceName: this.selectedDeviceName,
            }
        }));
    }

    attemptMIDIAccess() {
        navigator.requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))
            .catch(err => {
                console.error('Error accessing MIDI devices:', err);
                this.handleRetry(err);
            });
    }


    onMIDISuccess(midiAccess) {
        this.updateStatus("MIDI ready...");
        this.midiAccess = midiAccess; // Store midiAccess for later use
        midiAccess.onstatechange = this.handleMIDIStateChange.bind(this);
        this.addMIDIInputs(midiAccess.inputs);

        // Attempt to set the previously selected MIDI device
        if (this.selectedDeviceName) {
            this.setMIDIDevice(this.selectedDeviceName);
        }
    }
    handleMIDIStateChange(event) {
        this.updateDeviceState(event);
        this.dispatchMIDIDeviceChange(); // Dispatch on every state change
    }


    addMIDIInputs(inputs) {
        Array.from(inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this));
    }

    onMIDIFailure() {
        this.updateStatus("");
        this.handleRetry(new Error("Initial connection failed"));
    }

     handleRetry(err) {
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            console.log(`Retrying... Attempt ${this.retryCount}`);
            setTimeout(() => this.attemptMIDIAccess(), 3000); // Retry after 3 seconds
        } else {
            console.error(`Failed to connect after ${this.maxRetries} attempts: ${err.message}`);
            this.updateStatus("");
        }
    }

    onMIDIMessage({ data: [command, note, velocity] }) {
        const eventDetail = { command, note, velocity };
        if (command === 144 && velocity > 0) {
            if (this.activeNotes.size === 0) { // New session
                this.notesPlayed.clear();
            }
            this.notesPlayed.add(note);
            this.activeNotes.add(note);
            window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail }));
        } else if (command === 128 || velocity === 0) {
            this.activeNotes.delete(note);
            window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail }));
            if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) {
                this.outputNotes();
                this.notesPlayed.clear();
            }
        }
    }

    outputNotes() {
        const uniqueNotes = Array.from(this.notesPlayed);
        if (uniqueNotes.length > 0) {
            console.log(uniqueNotes);
            window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes }));
        }
    }

    updateStatus(message) {
        window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message }));
    }

    updateDeviceState({ port }) {
        const status = `MIDI: ${port.name} ${port.state}`;
        this.updateStatus(status);
        window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } }));


        if (port.state === "disconnected" || port.state === "unavailable") {
            this.handleDisconnection();
        }
        this.dispatchMIDIDeviceChange();
    }

    handleDisconnection() {
        console.log("MIDI device disconnected. Attempting to reconnect...");
        this.attemptMIDIAccess();
    }
}

export default MIDIAccessManager;


File: script.js
Path: piano\script.js

const NOTE_ARRAY = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];


class Piano {
    constructor(containerSelector, options = {}) {
        this.container = document.querySelector(containerSelector);
        this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50);

        this.octaves = options.octaves || 2;
        this.playedNotes = [];
        this.rootNote = null; // Add a property for the root note

        this.lastClickTime = 0;
        this.clickDelay = 300; // 300 milliseconds delay

        this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        this.keysPerOctave = this.layout.length;
        this.whiteKeyCount = this.layout.filter(x => x === 0).length;
        this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
        this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
        this.blackKeyHeight = 0.63;
        this.totalKeys = this.octaves * this.keysPerOctave;

        this.audioElements = [];
        this.volume = true
        this.globalVolume = 0.7;  // Global volume set to maximum by default


        this.createPiano();
        this.addKeyListeners();
    }

    volumeOff() {
        this.volume = false
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });

    }

    volumeOn() {
        this.volume = true
    }

    updateVolume() {
        const activeCount = this.playedNotes.length;
        const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
        this.audioElements.forEach(audio => {
            if (!audio.paused) {  // Only update audio elements that are currently playing
                audio.volume = volume;
            }
        });
    }
    
    

    createPiano() {
        this.container.innerHTML = ''; // Clear existing piano keys
        let whiteCounter = 0;

        for (let index = 0; index < this.totalKeys; index++) {
            let key = document.createElement("div");
            key.setAttribute('data-note', index);
            key.title = NOTE_ARRAY[index%12]
            if (this.layout[index % this.keysPerOctave] === 1) {
                key.classList.add("key", "black");
                key.style.left = `${(whiteCounter * this.whiteKeyWidth) - (this.blackKeyWidth / 2)}%`;
                key.style.width = `${this.blackKeyWidth}%`;
                key.style.height = `${this.blackKeyHeight * 100}%`;
                key.style.boxSizing = "border-box";
                key.style.position = `absolute`;
            } else {
                key.classList.add("key", "white");
                key.style.boxSizing = "border-box";
                key.style.width = `${this.whiteKeyWidth}%`;
                whiteCounter++;
            }
            this.container.appendChild(key);
            
            this.audioElements[index] = new Audio(`../audio/${index % 24}.mp3`);
            this.audioElements[index].preload = 'auto'; // This prevents the audio from loading until it is explicitly needed


        }
    }

    addKeyListeners() {
        this.container.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                //console.log("Click triggered")
                let currentTime = Date.now();



                const note = key.getAttribute('data-note');

                
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    if (currentTime - this.lastClickTime > 200) {
                        this.lastClickTime = currentTime;
                        //console.log("Set Time to: "+currentTime)
                    }

                    this.rootNote = null;

                } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) {
                    this.playedNotes = this.playedNotes.filter(n => n !== note);
                    key.classList.remove("selectedKey");
                } else {
                    if (!this.playedNotes.includes(note)) {
                        this.playedNotes.push(note);
                    }
                    key.classList.add("selectedKey");
                    this.playSoundLong(note, 0.75);
                }
                this.updatePlayedNotesDebounced();
            });

            key.addEventListener('dblclick', (event) => {
                //console.log("Doubleclick triggered")
                const note = key.getAttribute('data-note');
                if (this.rootNote === note) {
                    key.classList.add("selectedKey");
                    key.classList.remove("rootNote");
                    this.rootNote = null;
                } else {
                    if (this.rootNote !== null) {
                        this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
                    }
                    let currentTime = Date.now();
                    if (currentTime - this.lastClickTime < 500) {
                    } else {
                        this.rootNote = note;
                        if (!this.playedNotes.includes(note)) {
                            this.playedNotes.push(note);
                        }
                        key.classList.add('rootNote', 'selectedKey');
                    }

                }
                this.updatePlayedNotesDebounced();
            });
        });
    }


    debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }


    playSoundLong(index, localVolume) {
        if (this.volume) {
            const audio = this.audioElements[index];
            audio.volume = localVolume * this.globalVolume; // Apply global volume scaling
            if (!audio.paused) {
                audio.currentTime = 0; // Reset if it is already playing
            }
            audio.play();
        }
    }


    
    playChord() {
        this.playedNotes.sort((a, b) => a - b);
        const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1);
        this.playedNotes.forEach((note, index) => {
            const randomDelay = Math.random() * 20;
            setTimeout(() => {
                this.playSoundLong(note, localVolume);
            }, 20 * index + randomDelay);
        });
    }

    activateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (!key.classList.contains("selectedKey")) {
            key.classList.add("selectedKey");
            this.playedNotes.push(index);
            this.updatePlayedNotesDebounced();
            this.updateVolume(); // Adjust volume based on the new number of active notes
        }
        this.playSoundLong(index, 0.75); // Initial play sound with default volume
    }
    
    

    deactivateKey(index) {
        const key = this.container.querySelector(`.key[data-note="${index}"]`);
        if (key.classList.contains("selectedKey")) {
            key.classList.remove("selectedKey");
            this.playedNotes = this.playedNotes.filter(n => n !== index);
            this.updatePlayedNotesDebounced();
            // Do not update volume here to keep it consistent with the number of keys pressed
        }
    }
    
    setRootNote(note) {
        const key = this.container.querySelector(`.key[data-note="${note}"]`);
        if (this.rootNote !== null) {
            // Remove rootNote class from the old root note
            this.container.querySelector(`.key[data-note="${this.rootNote}"]`).classList.remove('rootNote');
        }
        this.rootNote = note; // Update the rootNote to the new note
        key.classList.add('rootNote', 'selectedKey'); // Add rootNote class to new root note
        if (!this.playedNotes.includes(note)) {
            this.playedNotes.push(note); // Add root note to playedNotes if it's not already there
        }
        this.updatePlayedNotesDebounced();
    }

    clearRootNote() {
        if (this.rootNote !== null) {
            const key = this.container.querySelector(`.key[data-note="${this.rootNote}"]`);
            key.classList.remove('rootNote'); // Remove the rootNote class
            this.rootNote = null; // Reset the rootNote property
            this.updatePlayedNotesDebounced();
        }
    }

    updatePlayedNotes() {
        const event = new CustomEvent('notesChanged', { detail: { notes: this.playedNotes, rootNote: this.rootNote } });
        console.log("Dispatching Note Change Event: " + this.playedNotes + " Root: " + this.rootNote)
        this.container.dispatchEvent(event);
    }
    clearPiano() {

        this.playedNotes = []; // Clear the array of played notes
        this.rootNote = null; // Clear the root note
        this.container.querySelectorAll('.key.selectedKey').forEach(key => {
            key.classList.remove("selectedKey");
        });
        this.container.querySelectorAll('.key.rootNote').forEach(key => {
            key.classList.remove("rootNote");
        });
        this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; });
        this.updatePlayedNotes();
    }

    setOctaves(newOctaves) {
        if (newOctaves !== this.octaves) {
            this.octaves = newOctaves;
            this.totalKeys = this.octaves * this.keysPerOctave;
            this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves);
            this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234;
            this.clearPiano();
            this.createPiano();
            this.addKeyListeners();
        }
    }
}

export default Piano;


File: main.js
Path: progression-generator\main.js

import { settings } from '../chord-factory/constants.js';
import { ChordFactory } from '../chord-factory/chordfactory.js';
import { Chord } from '../chord-library/script.js';
import { numberToNote } from '../chord-factory/utils.js';
import { TabHTML } from './tabhtml.js';


class ChordFactoryManager {
    constructor(useRoot) {
        this.chordFactoryMap = {};
        this.useRoot = useRoot;
    }

    getChordFactory(chord, key) {
        if (!this.chordFactoryMap[key]) {
            this.chordFactoryMap[key] = {};
        }

        if (this.chordFactoryMap[key][chord.name]) {
            console.log(`ChordFactory retrieved for: ${chord.name} in key: ${key}`);
            return this.chordFactoryMap[key][chord.name];
        } else {
            const chordFactory = new ChordFactory(chord, this.useRoot, settings.tuning);
            this.chordFactoryMap[key][chord.name] = chordFactory;
            console.log(`New ChordFactory created for: ${chord.name} in key: ${key}`);
            return chordFactory;
        }
    }
}


export class ProgressionGenerator {
    constructor(initialProgression = [], useRoot = true, chordLibrary, color, fingerNumbers = "belowString", showOpenStrings = true) {
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.progression = [];
        this.progressionChords = [];
        this.useRoot = useRoot; // This flag determines if the root note should be the starting note
        this.keyAnalysis = []
        this.chordLibrary = chordLibrary

        // Initialize ChordFactoryManager
        this.chordFactoryManager = new ChordFactoryManager(this.useRoot);

        // Call the asynchronous initialization function
        this.initialize(initialProgression);
    }

    async initialize(initialProgression) {
        await this.setProgression(initialProgression);

        await this.getEasiestChords();


    }

    addKeyAnalysis(root, keyscale, prob) {
        // Push a new object to the array with the analysis data
        this.keyAnalysis.push({
            rootNote: root,
            scale: keyscale,
            probability: prob
        });
    }
    analyzeKey() {

        this.keyAnalysis = []
        //Define Possible Scales
        //Higher Prioroty means They get artifically boostes at the Raking
        const scaleStructures = {
            'Major': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 },  // Major Scale: C, D, E, F, G, A, B
            'Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 },  // Natural Minor Scale: A, B, C, D, E, F, G
            'Minor Pentatonic': { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 },  // Minor Pentatonic Scale: A, C, D, E, G
            'Major Pentatonic': { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 },  // Major Pentatonic Scale: C, D, E, G, A
            'Harmonic Minor': { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 },  // Harmonic Minor Scale: A, B, C, D, E, F, G#
            'Blues': { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 },  // Blues Scale: A, C, D, D#, E, G
            'Mixolydian': { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 },  // Mixolydian Mode: G, A, B, C, D, E, F
            'Dorian': { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, // Dorian Mode: D, E, F, G, A, B, C
            'Phrygian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, // Phrygian Mode: E, F, G, A, B, C, D
            'Lydian': { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, // Lydian Mode: F, G, A, B, C, D, E
            'Locrian': { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 }  // Locrian Mode: B, C, D, E, F, G, A
        };


        //Generate an Array of Notes and How often They are present
        let notesSet = Array(12).fill(0);
        this.progression.forEach(element => {
            element.notes.forEach(note => {
                notesSet[note]++
            })
        })
        console.log("analyzeKey - notesSet:", notesSet)





        //Now GO through The NoteSet and Calucalte A Number for The Probability of the Key
        notesSet.forEach((scopeNote, index) => {


            //Only Look at occuring Notes
            if (scopeNote != 0) {
                //Loop Through the scaleStrucurtres and the notes array

                Object.keys(scaleStructures).forEach(key => {
                    let ammountWeight = 0.01
                    let rootWeight = 0.01
                    //DO NOT CHANGE
                    let distanceToRootWeight = 1
                    let keyProbability = 0
                    for (let relativeNote = 0; relativeNote < 11; relativeNote++) {
                        if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) {
                            keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight))
                            distanceToRootWeight += rootWeight
                        }
                    }
                    this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority)
                })

            }
        })
        this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability);
        return
    }


    // Set initial progression with ChordFactory instances for each chord
    async setProgression(initialProgression) {
        if (!initialProgression) {
            return;
        }

        this.progressionChords = initialProgression;

        // Populate this.progression with ChordFactory instances
        this.progression = initialProgression.map(chord => {
            if (chord instanceof Chord) {
                return this.chordFactoryManager.getChordFactory(chord, "dynamic");
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
                return null;
            }
        }).filter(chordFactory => chordFactory !== null);

        // Populate this.progression with references from the new map
        if (this.progression.length > 1) {
            this.analyzeKey()
            this.bestTranspositions = await this.determineBestTranspositions(structuredClone(this.progressionChords));
            console.log("analyzeKey: ", this.keyAnalysis)
            const event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: <b>" + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale + "</b>" } });
            console.log("Key Change Event: " + numberToNote(this.keyAnalysis[0].rootNote) + " " + this.keyAnalysis[0].scale)
            window.dispatchEvent(event);
            
        } else {
            let event = new CustomEvent('scaleDetected', { detail: { scale: "Scale: ..." } });
            console.log("Key Change Event: none")
            window.dispatchEvent(event);
            //Clear the List of Capo Positions
            let bestTranspositions = "none"
            event = new CustomEvent('transpositionsDetermined', { detail: { bestTranspositions } });
            window.dispatchEvent(event);
        }

    }

    async reloadProgression() {
        this.tuning = settings.tuning;
        this.chordFactoryManager = new ChordFactoryManager(this.useRoot);
        this.progression = [];
        this.initialize(this.progressionChords);
        console.log("ProgressionGenerator: Reloaded Progression");
    }


    getPlaceholderHTML() {
        let diagramsContainer = document.createElement('div');
        diagramsContainer.classList.add("progressionGeneratorContainer");
        diagramsContainer.style.opacity = 0.2

        let placeholderhtml = new TabHTML().generatePlaceholder(3)

        placeholderhtml.forEach(element => {
            diagramsContainer.appendChild(element);

        })
        return diagramsContainer; // Return the container with all placeholder SVGs
    }



    async getProgressionDynamicHTML(soundQuality = 0.5, amount = 2) {
        if (this.progression.length < 1) {
            return this.getPlaceholderHTML();
        }

        let diagramsContainer = document.createElement('div');
        diagramsContainer.classList.add("progressionGeneratorContainer");


        this.progression.forEach((chordFactory, index) => {
            let container = document.createElement("div")
            let placeholderhtml = new TabHTML().generatePlaceholder(1, "Loading...")
            placeholderhtml[0].style.opacity = 0.2
            container.id = "progression-generator-dynamic-" + index
            container.appendChild(placeholderhtml[0])
            diagramsContainer.appendChild(container);
        })

        this.progression.forEach(async (chordFactory, index) => {
            const tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);
            const chordDiagrams = await tabHTML.generateHTML(soundQuality, amount);
            let container = document.getElementById("progression-generator-dynamic-" + index)
            container.innerHTML = ""
            //container.appendChild(chordDiagrams[Math.floor(5 * soundQuality * (1 - soundQuality))])
            container.appendChild(chordDiagrams[0])
        });

        return diagramsContainer;
    }


    async determineBestTranspositions(originalProgression) {
        if (!this.easiestChords) {
            await this.getEasiestChords();  // Make sure easiestChords are loaded
        }

        let transpositionResults = [];
        const totalChords = originalProgression.length;
        
        for (let i = 0; i < 12; i++) {
            let overlapCount = 0;
            let transposedProgression = await Promise.all(
                originalProgression.map(chord =>
                    this.chordLibrary.simplifySlashChord(this.chordLibrary.transposeChord(chord, i))
                )
            );

            transposedProgression.forEach(chord => {
                this.easiestChords.forEach(easyChord => {
                    if (chord.name === easyChord.name) {
                        overlapCount++;
                    }
                });
            });

            let overlapScore = overlapCount / totalChords;
            let capoHeight = (12 - i) % 12;
            let capoHeightScore = 1-(capoHeight / 11);  // Normalized between 0 and 1

            let combinedScore = overlapScore * 0.7+ capoHeightScore * 0.3;  // Adjust weights as needed
            transpositionResults.push({ transposition: i, combinedScore, overlapScore, capoHeightScore });
        }

        // Sort the results based on the combined score in descending order
        transpositionResults.sort((a, b) => b.combinedScore - a.combinedScore);

        const bestTranspositions = transpositionResults.map(result => result.transposition);
        this.bestTranspositions = bestTranspositions;

        // Dispatch a custom event with the transpositions data
        const event = new CustomEvent('transpositionsDetermined', { detail: { bestTranspositions } });
        window.dispatchEvent(event);

        // Return the array of transpositions sorted by their combined score
        return bestTranspositions;
    }



    async getProgressionEasyHTML(transposeId = 0) {
        //console.log("getProgressionEasyHTML CALLED")
        if (!this.easiestChords) {
            await this.getEasiestChords();  // Make sure easiestChords are loaded
        }

        if (this.progression.length < 1) {
            return [this.getPlaceholderHTML(), 0];
        }
        let bestTransposition = 0
        const originalProgression = structuredClone(this.progressionChords);
        if (this.bestTranspositions) {
            bestTransposition = this.bestTranspositions[transposeId];
        }

        let bestTransposedProgression = await Promise.all(
            originalProgression.map(chord =>
                this.chordLibrary.simplifySlashChord(this.chordLibrary.transposeChord(chord, bestTransposition))
            )
        );

        bestTransposedProgression = bestTransposedProgression.map(chord => {
            if (chord instanceof Chord) {
                return this.chordFactoryManager.getChordFactory(chord, "easy");
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
                return null;
            }
        });


        // Generate the HTML for the best transposed progression
        let diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.classList.add("progressionGeneratorContainer");



        bestTransposedProgression.forEach((chordFactory, index) => {
            let container = document.createElement("div")
            let placeholderhtml = new TabHTML().generatePlaceholder(1, "Loading...")
            placeholderhtml[0].style.opacity = 0.2
            container.id = "progression-generator-easy-" + index
            container.appendChild(placeholderhtml[0])
            diagramsContainer.appendChild(container);
        })

        // Iterate over each ChordFactory instance in the progression
        bestTransposedProgression.forEach(async (chordFactory, index) => {
            // Create an instance of TabHTML for the current chordFactory
            let tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);

            // Generate the HTML for the current chordFactory
            let chordDiagrams = await tabHTML.generateHTML(0, 1);
            // Append the generated HTML to the main container

            let container = document.getElementById("progression-generator-easy-" + index)
            container.innerHTML = ""
            container.appendChild(chordDiagrams[0])

        });

        // Return the container with all chord diagrams
        return [diagramsContainer, (12 - bestTransposition) % 12];
    }

    async getProgressionTransposedHTML(capo = 0) {
        if (!this.easiestChords) {
            await this.getEasiestChords();  // Assumed to properly fetch and set this.easiestChords
        }

        if (this.progression.length < 1) {
            return [this.getPlaceholderHTML(), 0];
        }
        const originalProgression = structuredClone(this.progressionChords); // Make a copy of the progression chords

        // Function to transpose a chord by a given number of semitones
        let transposeChord = (chord, semitones) => {
            return this.chordLibrary.transposeChord(chord, semitones);
        };


        let transposedProgression = await Promise.all(
            originalProgression.map(chord =>
                this.chordLibrary.simplifySlashChord(transposeChord(chord, capo))
            )
        );


        transposedProgression = transposedProgression.map(chord => {
            if (chord instanceof Chord) {
                return this.chordFactoryManager.getChordFactory(chord, "easyCapo");
            } else {
                console.error('ProgressionGenerator: Invalid chord object in initial progression. Each chord must be an instance of Chord.');
                return null;
            }
        });


        // Generate the HTML for the best transposed progression
        let diagramsContainer = document.createElement('div'); // Container for chord diagrams
        diagramsContainer.classList.add("progressionGeneratorContainer");



        transposedProgression.forEach((chordFactory, index) => {
            let container = document.createElement("div")
            let placeholderhtml = new TabHTML().generatePlaceholder(1, "Loading...")
            placeholderhtml[0].style.opacity = 0.2
            container.id = "progression-generator-easy-capo-" + index
            container.appendChild(placeholderhtml[0])
            diagramsContainer.appendChild(container);
        })

        // Iterate over each ChordFactory instance in the progression
        transposedProgression.forEach(async (chordFactory, index) => {
            // Create an instance of TabHTML for the current chordFactory
            let tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings);

            // Generate the HTML for the current chordFactory
            let chordDiagrams = await tabHTML.generateHTML(0, 1);
            // Append the generated HTML to the main container

            let container = document.getElementById("progression-generator-easy-capo-" + index)
            container.innerHTML = ""
            container.appendChild(chordDiagrams[0])

        });

        // Return the container with all chord diagrams
        return [diagramsContainer, capo];
    }

    async getEasiestChords() {
        const easiestChordsArray = [
            [-1, 0, 2, 2, 2, 0],   // A major (A)
            [-1, 0, 2, 2, 1, 0],   // A minor (Am)
            [-1, 0, 2, 0, 1, 0],   // A minor 7 (Am7)
            [-1, 0, 2, 2, 0, 0],   // Asus2
            [-1, 3, 2, 0, 1, 0],   // C major (C)
            [-1, 3, 2, 0, 1, 0],   // C major 7 (Cmaj7)
            [-1, -1, 0, 2, 3, 2],  // D major (D)
            [-1, -1, 0, 2, 1, 2],  // D minor (Dm)
            [3, 2, 0, 0, 0, 3],    // G major (G)
            [0, 2, 2, 1, 0, 0],    // E major (E)
            [0, 2, 0, 1, 0, 0],    // E7
            [0, 2, 2, 0, 0, 0],    // E minor (Em)
            [1, 3, 3, 2, 1, 1],    // F major (F)
        ];


        let easiestChords = [];
        let currentChord = new Set();

        for (const element of easiestChordsArray) {
            currentChord = new Set();
            for (let i = 0; i < 6; i++) {
                if (element[i] != -1) {
                    currentChord.add((settings.tuning[i] + element[i]) % 12);
                }
            }
            let root = -1
            for (let i = 0; i < 6; i++) {
                if (element[i] != -1) {
                    root = (settings.tuning[i] + element[i]) % 12
                    break;
                }
            }
            const foundChords = await this.chordLibrary.searchChords(Array.from(currentChord), root, 100);
            if (foundChords[0]) {
                easiestChords.push(foundChords[0]);
            }
        }

        console.log("getEasiestChords:", easiestChords)
        this.easiestChords = easiestChords
        return
    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
}

File: tabhtml.js
Path: progression-generator\tabhtml.js

import TabGenerator from "../tab-generator/script.js";
import { settings } from "../chord-factory/constants.js";

export class TabHTML {
    constructor(chordFactory = [], color = "#fff", fingerNumbers = "belowString", showOpenStrings = true) {
        this.chordFactory = chordFactory; // Pointer to the ChordFactory instance
        this.color = color;
        this.fingerNumbers = fingerNumbers;
        this.showOpenStrings = showOpenStrings;
        this.currentIndex = 0; // Track the current index of playable chords
        this.maxChords = chordFactory.playableChords?.length ?? 0;


    }

    invertColor(hex) {
        // Remove the hash at the start if it's there
        hex = hex.startsWith('#') ? hex.slice(1) : hex;

        // Convert hex to RGB
        let r = parseInt(hex.substr(0, 2), 16);
        let g = parseInt(hex.substr(2, 2), 16);
        let b = parseInt(hex.substr(4, 2), 16);

        // Invert each component by subtracting from 255
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;

        // Convert the inverted RGB values back to hex
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }

    vibrateElement(element) {
        element.classList.add('vibrate');
        setTimeout(() => {
            element.classList.remove('vibrate');
        }, 200); // Match this duration with the animation duration in CSS
    }

    updateChordDiagram(svgContainer, voicingInfoDiv, direction) {
        const playableChords = this.chordFactory.playableChords;
        const currentIndex = parseInt(svgContainer.getAttribute('data-current-index'), 10);
        voicingInfoDiv.innerHTML = currentIndex + 1 + " / " + this.maxChords
        if (this.currentIndex < playableChords.length && currentIndex >= 0) {
            let slideOutClass, slideInClass;

            if (direction === 'next') {
                slideOutClass = 'slide-out-left';
                slideInClass = 'slide-in-right';
            } else if (direction === 'previous') {
                slideOutClass = 'slide-out-right';
                slideInClass = 'slide-in-left';
            }

            // Apply slide-out animation to the current SVG
            svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
            svgContainer.classList.add(slideOutClass);

            // Wait for the slide-out animation to complete
            setTimeout(() => {
                const chord = playableChords[currentIndex];
                const chordDiagram = new TabGenerator(
                    chord.voicing,
                    chord.fingerPositions,
                    chord.minAboveZero,
                    chord.barres,
                    this.color,
                    this.invertColor(this.color),
                    this.fingerNumbers,
                    this.showOpenStrings
                );
                const newSvg = chordDiagram.generateChordSVG();

                // Replace the old SVG with the new one
                svgContainer.innerHTML = '';
                svgContainer.appendChild(newSvg);

                // Apply slide-in animation to the new SVG
                svgContainer.classList.remove(slideOutClass);
                svgContainer.classList.add(slideInClass);
                setTimeout(() => {
                    svgContainer.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-right', 'slide-out-left');
                }, 100)
            }, 100); // Match this duration with the animation duration in CSS

        }
    }

    async generateHTML(soundQuality = 0.5, amount = 1) {
        await this.chordFactory.sortPlayableChordsByCombinedRating(soundQuality);
        this.maxChords = this.chordFactory.playableChords.length;

        let diagrams = [];
        for (let i = 0; i < amount; i++) {
            if (this.chordFactory.playableChords[i]) {
                try {
                    const chord = this.chordFactory.playableChords[i];
                    const chordDiagram = new TabGenerator(
                        chord.voicing,
                        chord.fingerPositions,
                        chord.minAboveZero,
                        chord.barres,
                        this.color,
                        this.invertColor(this.color),
                        this.fingerNumbers,
                        this.showOpenStrings
                    );

                    const svg = chordDiagram.generateChordSVG();
                    let svgContainer = document.createElement('div');
                    svgContainer.classList.add("progressionGeneratorSvgContainer");
                    svgContainer.setAttribute('data-current-index', i);
                    svgContainer.appendChild(svg);

                    let chordSwitchContainer = this.createChordSwitchContainer(svgContainer);

                    let chordNameContainer = document.createElement('div');
                    chordNameContainer.innerHTML = this.chordFactory.identifier;
                    chordNameContainer.classList.add("progressionGeneratorChordName");

                    let chordInfoContainer = document.createElement('div');
                    chordInfoContainer.classList.add("progressionGeneratorChordInfoContainer");
                    chordInfoContainer.appendChild(chordNameContainer);
                    chordInfoContainer.appendChild(chordSwitchContainer);

                    let diagramsContainer = document.createElement('div');
                    diagramsContainer.classList.add("progressionGeneratorDiagramsContainer");
                    diagramsContainer.appendChild(svgContainer);
                    diagramsContainer.appendChild(chordInfoContainer);

                    diagrams.push(diagramsContainer);
                } catch (error) {
                    console.error('Error generating chord diagram:', error);
                }
            } else {
                let diagramsContainer = this.generatePlaceholder(1, this.chordFactory.identifier)

                diagramsContainer[0].style.opacity = 0.4
                diagramsContainer[0].style.filter = "blur(3px)"

                let impossibleWrapper = []
                impossibleWrapper[0] = document.createElement('div');
                impossibleWrapper[0].appendChild(diagramsContainer[0])
                impossibleWrapper[0].classList.add("progressionGeneratorImpossibleWrapper");


                let impossible = document.createElement('div');
                impossible.innerHTML = "<strong>IMPOSSIBLE</strong><br>with these<br>settings"
                impossible.classList.add("progressionGeneratorImpossible");
                impossibleWrapper[0].appendChild(impossible)

                return impossibleWrapper
            }
        }
        return diagrams;
    }

    createChordSwitchContainer(svgContainer) {
        let chordSwitchContainer = document.createElement('div');
        chordSwitchContainer.classList.add("progressionGeneratorChordSwitchContainer");

        let chordSwitchInfo = document.createElement('div');
        let currentIndex = parseInt(svgContainer.getAttribute('data-current-index'), 10);
        chordSwitchInfo.innerHTML = (currentIndex + 1) + " / " + this.maxChords;

        const nextButton = document.createElement('div');
        nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"/></svg>';
        nextButton.classList.add("progressionGeneratorChordSwitchButton");

        nextButton.onclick = () => {
            currentIndex = parseInt(svgContainer.getAttribute('data-current-index'), 10);
            if (currentIndex + 1 < this.chordFactory.playableChords.length) {
                currentIndex++;
                svgContainer.setAttribute('data-current-index', currentIndex);
                this.updateChordDiagram(svgContainer, chordSwitchInfo, 'next');
            } else {
                this.vibrateElement(svgContainer);
            }
        };

        const prevButton = document.createElement('div');
        prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"/></svg>';
        prevButton.classList.add("progressionGeneratorChordSwitchButton");

        prevButton.onclick = () => {
            currentIndex = parseInt(svgContainer.getAttribute('data-current-index'), 10);
            if (currentIndex > 0) {
                currentIndex--;
                svgContainer.setAttribute('data-current-index', currentIndex);
                this.updateChordDiagram(svgContainer, chordSwitchInfo, 'previous');
            } else {
                this.vibrateElement(svgContainer);
            }
        };

        chordSwitchContainer.appendChild(prevButton);
        chordSwitchContainer.appendChild(chordSwitchInfo);
        chordSwitchContainer.appendChild(nextButton);

        return chordSwitchContainer;
    }

    generatePlaceholder(placeholderCount = 4, label) {
        let diagrams = [];

        for (let i = 0; i < placeholderCount; i++) {
            let voicing = [0, 0, 0, 0, 0, 0];
            let indices = new Set();
            while (indices.size < 4) {
                let index = Math.floor(Math.random() * voicing.length);
                indices.add(index);
            }

            indices.forEach(index => {
                voicing[index] = Math.floor(Math.random() * (settings.fingerFretRange + 1));
            });

            const fingerPositions = [0, 0, 0, 0, 0, 0];

            const chordDiagram = new TabGenerator(
                voicing,
                fingerPositions,
                0,
                [],
                this.color,
                this.invertColor(this.color),
                this.fingerNumbers,
                this.showOpenStrings
            );
            const svg = chordDiagram.generateChordSVG();

            // Container for the actual SVG element
            let svgContainer = document.createElement('div');
            svgContainer.classList.add("progressionGeneratorSvgContainer");
            svgContainer.appendChild(svg);

            // Container for the chord switching
            let chordSwitchContainer = document.createElement('div');
            chordSwitchContainer.classList.add("progressionGeneratorChordSwitchContainer");

            // Div for displaying the current chord number
            let chordSwitchInfo = document.createElement('div');
            let random = Math.floor(Math.random() * 500)
            chordSwitchInfo.innerHTML = `1 / ${random}`;

            // Next button and functions
            const nextButton = document.createElement('div');
            nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="M579-480 285-774q-15-15-14.5-35.5T286-845q15-15 35.5-15t35.5 15l307 308q12 12 18 27t6 30q0 15-6 30t-18 27L356-115q-15 15-35 14.5T286-116q-15-15-15-35.5t15-35.5l293-293Z"/></svg>';
            nextButton.classList.add("progressionGeneratorChordSwitchButton");

            nextButton.onclick = () => {
                this.vibrateElement(svgContainer); // Placeholder does not actually switch
            };

            // Previous button and functions
            const prevButton = document.createElement('div');
            prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" ><path fill="currentColor" d="m142-480 294 294q15 15 14.5 35T435-116q-15 15-35 15t-35-15L57-423q-12-12-18-27t-6-30q0-15 6-30t18-27l308-308q15-15 35.5-14.5T436-844q15 15 15 35t-15 35L142-480Z"/></svg>';
            prevButton.classList.add("progressionGeneratorChordSwitchButton");

            prevButton.onclick = () => {
                this.vibrateElement(svgContainer); // Placeholder does not actually switch
            };

            // Adding the three elements to the switch div
            chordSwitchContainer.appendChild(prevButton);
            chordSwitchContainer.appendChild(chordSwitchInfo);
            chordSwitchContainer.appendChild(nextButton);




            //Crafting the CHordname contsainer
            let chordNameContainer = document.createElement('div'); // Container for chord diagrams
            let underscores = ""

            if (!label) {
                console.log("Label", label)
                random = Math.floor(Math.random() * 3) + 2;

                underscores = "_".repeat(random);
                let easteregg = Math.floor(Math.random() * 2000);
                if (easteregg == 1) {
                    underscores = "Hannah"
                }
                if (easteregg == 2) {
                    underscores = "Lukas"
                }
                if (easteregg == 3) {
                    underscores = "Marc"
                }
            } else { underscores = label }
            chordNameContainer.innerHTML = underscores;

            chordNameContainer.classList.add("progressionGeneratorChordName");

            //Putting chordSwitchContainer and chordNameContainer into a div so they dont have any gap
            let chordInfoContainer = document.createElement('div');
            chordInfoContainer.classList.add("progressionGeneratorChordInfoContainer");
            chordInfoContainer.appendChild(chordNameContainer);

            chordInfoContainer.appendChild(chordSwitchContainer);


            //Creating the Full Container WIth everhting in it
            let diagramsContainer = document.createElement('div');
            diagramsContainer.classList.add("progressionGeneratorDiagramsContainer");
            diagramsContainer.appendChild(svgContainer);
            diagramsContainer.appendChild(chordInfoContainer);








            // Pushing it into the diagrams
            diagrams.push(diagramsContainer);
        }

        return diagrams; // Return the container with all SVGs
    }

}

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Diagram Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <h1>Guitar Chord Diagram Generator</h1>
        <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input">
        <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)">
        <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button>
        <div id="diagram" class="diagram-container"></div>
    </div>
    <script type="module">
        import TabGenerator from "./script.js"

        const fingerPositions = ['-1', '5', '6', '5', '0', '0'];
        const fingerNumbers = ['1', '1', '2', '1', '', ''];
        const barre = 10;
        const minAboveZero = 15
        const barres = [[5,1,3], [3,0,5]]
        const color = "#fff";
        const textColor = "#000";
        const showOpenStrings = true;

        try {
            const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, minAboveZero, barres, color, textColor, 'belowString', showOpenStrings);
            const svg = chordDiagram.generateChordSVG();
            document.getElementById('diagram').appendChild(svg);
        } catch (error) {
            console.error('Error generating chord diagram:', error);
        }
    </script>
</body>

</html>

File: script.js
Path: tab-generator\script.js

/**
 * Represents a TabGenerator for creating guitar chord diagrams as SVG elements.
 * This class allows the configuration of various aspects of the diagram, including finger positions,
 * barre chords, string and note visualization, and color customization.
 */
class TabGenerator {
    /**
     * Creates an instance of TabGenerator.
     * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings.
     * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string.
     * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used.
     * @param {string} [barre=null] - Specific fret where the barre is placed.
     * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes.
     * @param {string} [textColor="#fff"] - Color for the text used in the diagram.
     * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately.
     * @param {boolean} showOpenStrings - Whether to display open strings in the diagram.
     */
    constructor(fingerPositions, fingerNumbers, minAboveZero = 0, barres = [], elementColor = "#000", textColor = "#fff", numberPosition = 'onNote', showOpenStrings) {

        if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) {
            console.error("Error: fingerPositions must be an array of length 6.");
        }
        if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) {
            console.error("Error: fingerNumbers must be an array of length 6 or null.");
        }
        if (typeof elementColor !== 'string') {
            console.error("Error: elementColor must be a string.");
        }
        if (typeof textColor !== 'string') {
            console.error("Error: textColor must be a string.");
        }
        if (numberPosition !== 'onNote' && numberPosition !== 'belowString') {
            console.error("Error: numberPosition must be either 'onNote' or 'belowString'.");
        }
        if (typeof showOpenStrings !== 'boolean') {
            console.error("Error: showOpenStrings must be a boolean.");
        }
        // Assign instance variables
        this.fingerPositions = fingerPositions;
        this.fingerNumbers = fingerNumbers;
        this.barres = barres;               // Specific fret where the barre is placed
        this.color = elementColor; // Color for diagram elements
        this.textColor = textColor;       // Color for the text
        this.numberPosition = numberPosition; // Position of the numbers
        this.showOpenStrings = showOpenStrings; // Whether to display open strings
        this.maxFret = Math.max(...fingerPositions)



        // Diagram layout constants
        this.topSpacing = 25;
        this.topBarHeight = 7;
        this.fretSpacing = 25;
        this.stringSpacing = 24;
        this.paddingLeft = 10;
        this.barreSidesOverflow = 10;
        this.stringOverflowBotom = 10;
        this.fretCount = 4;
        this.circleRadius = 10;
        this.infoPadding = 10;
        this.openStringRadius = 7;


        //Offset
        this.offset = 1
        if (this.maxFret > this.fretCount){
            this.offset = minAboveZero
        }

        //Global Framw Width
        this.width = 180;
        this.height = 145
    }

    generateChordSVG() {
        const svgAttributes = {
            width:  this.width,
            height: this.height,
            viewBox: "0 0 " +  this.width + " " +this.height  // This sets the viewBox attribute
        };
        const svg = this.createSVGElement('svg', svgAttributes);
        this.drawDiagramComponents(svg);
        return svg;
    }

    drawDiagramComponents(svg) {
        this.drawTopBar(svg);
        if (this.barres) {
            this.barres.forEach(element => {
                this.drawBarre(svg, element[0], element[1], element[2]);

            });
        }
        this.drawStrings(svg);
        this.drawFrets(svg);
        if (this.showOpenStrings) {
            this.drawOpenStrings(svg);
        }
        this.drawNotes(svg);
        this.drawMuteIndicators(svg);
        this.drawFretHeight(svg)
    }


    createSVGElement(tag, attributes) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const attr in attributes) {
            element.setAttribute(attr, attributes[attr]);
        }
        return element;
    }

    drawTopBar(svg) {
        const topBar = this.createSVGElement('rect', {
            x: this.paddingLeft,
            y: this.topSpacing,
            width: this.stringSpacing * 5,
            height: this.topBarHeight,
            fill: this.color,
            stroke: this.color,
            'stroke-width': '2'
        });
        svg.appendChild(topBar);
    }

    drawStrings(svg) {
        for (let i = 0; i < 6; i++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft + i * this.stringSpacing, y1: this.topSpacing,
                x2: this.paddingLeft + i * this.stringSpacing, y2: this.fretSpacing * this.fretCount + this.topSpacing + this.stringOverflowBotom + this.topBarHeight,
                stroke: this.color, 'stroke-width': ((6 - i) / 3) + 1
            });
            svg.appendChild(line);
        }
    }

    drawFrets(svg) {
        for (let j = 0; j < this.fretCount + 1; j++) {
            const line = this.createSVGElement('line', {
                x1: this.paddingLeft, y1: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                x2: this.paddingLeft + this.stringSpacing * 5, y2: this.topSpacing + j * this.fretSpacing + this.topBarHeight,
                stroke: this.color, 'stroke-width': '2'
            });
            svg.appendChild(line);
        }
    }

    drawNotes(svg) {
        for (let string = 0; string < 6; string++) {
            if (this.fingerPositions[string] > 0) {
                let fret = parseInt(this.fingerPositions[string]);
                if (fret > 0) {
                    let position = this.topSpacing + this.topBarHeight + ((fret) - this.offset) * this.fretSpacing - this.circleRadius / 2;
                    let circle = this.createSVGElement('circle', {
                        cx: this.paddingLeft + string * this.stringSpacing, cy: position + this.topSpacing - 8,
                        r: this.circleRadius, fill: this.color
                    });
                    svg.appendChild(circle);

                    if (this.fingerNumbers && this.fingerNumbers[string]) {
                        const textPositionY = this.numberPosition === 'onNote' ? position + this.topSpacing : this.topSpacing + this.topBarHeight + (this.fretCount + 1) * this.fretSpacing + this.stringOverflowBotom;
                        const text = this.createSVGElement('text', {
                            x: this.paddingLeft + string * this.stringSpacing,
                            y: textPositionY,
                            'font-family': 'Arial',
                            'font-size': '20',
                            'font-weight': '500',
                            fill: this.numberPosition === 'onNote' ? this.textColor : this.color,
                            'text-anchor': 'middle'
                        });
                        text.textContent = this.fingerNumbers[string];
                        svg.appendChild(text);
                    }
                }
            }
        }
    }

    drawMuteIndicators(svg) {
        const radius = 10
        const height = radius * Math.sqrt(2)

        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] == -1) {
                const line1 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - height - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                const line2 = this.createSVGElement('line', {
                    x1: this.paddingLeft + i * this.stringSpacing - height / 2,
                    y1: this.topSpacing - this.infoPadding,
                    x2: this.paddingLeft + i * this.stringSpacing + height / 2,
                    y2: this.topSpacing - height - this.infoPadding,
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(line1);
                svg.appendChild(line2);
            }
        }
    }

    drawOpenStrings(svg) {
        for (let i = 0; i < 6; i++) {
            if (this.fingerPositions[i] === '0') {
                const circle = this.createSVGElement('circle', {
                    cx: this.paddingLeft + i * this.stringSpacing,
                    cy: this.topSpacing - this.infoPadding - this.openStringRadius,
                    r: this.openStringRadius,
                    fill: 'none',
                    stroke: this.color,
                    'stroke-width': '2'
                });
                svg.appendChild(circle);
            }
        }
    }

    drawBarre(svg, barreFret, barreStartString, barreEndString) {
        if (barreFret != 0) {
            barreFret = barreFret - this.offset 
            const barreWidth = barreEndString - barreStartString
            const barreHeight = 10;
            const barreX = this.paddingLeft - this.barreSidesOverflow + barreStartString * this.stringSpacing;
            const barreY = barreFret * this.fretSpacing + this.topSpacing + this.topBarHeight + (this.fretSpacing / 2) - barreHeight / 2;

            const rect = this.createSVGElement('rect', {
                x: barreX, y: barreY,
                width: barreWidth * this.stringSpacing + 2 * this.barreSidesOverflow, height: barreHeight,
                rx: '5', ry: '5',
                fill: this.color
            });
            svg.appendChild(rect);


        }
    }

    drawFretHeight(svg) {
        if (this.offset  > 1) {
            const text = this.createSVGElement('text', {
                x:this.paddingLeft + this.stringSpacing*5 + this.infoPadding, y: this.topSpacing + this.topBarHeight + this.fretSpacing * 0.5,
                'font-family': 'Arial', 'font-size': '20', fill: this.color,
                'text-anchor': 'left',
                "alignment-baseline": "central"
            });
            text.textContent = this.offset  + "fr";
            svg.appendChild(text);
        }
    }
}

export default TabGenerator;

