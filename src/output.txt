Directory Structure:
audio/
chord-factory/
  chordfactory.js (Path: chord-factory\chordfactory.js)
  chordvoicing.js (Path: chord-factory\chordvoicing.js)
  constants.js (Path: chord-factory\constants.js)
  main.js (Path: chord-factory\main.js)
  utils.js (Path: chord-factory\utils.js)
chord-library/
  script.js (Path: chord-library\script.js)
chordviewer/
  index.html (Path: chordviewer\index.html)
  index.js (Path: chordviewer\index.js)
createChatGPTContext.js (Path: createChatGPTContext.js)
css/
drag-drop/
  script.js (Path: drag-drop\script.js)
index.html (Path: index.html)
index.js (Path: index.js)
midi-integration/
  index.html (Path: midi-integration\index.html)
  script.js (Path: midi-integration\script.js)
piano/
  script.js (Path: piano\script.js)
progression-generator/
  main.js (Path: progression-generator\main.js)
  svg/
  tabhtml.js (Path: progression-generator\tabhtml.js)
svg/
tab-generator/
  index.html (Path: tab-generator\index.html)
  script.js (Path: tab-generator\script.js)

File Contents:
File: chordfactory.js
Path: chord-factory\chordfactory.js

import { settings, MAX_FRETS } from './constants.js'; import { ChordVoicing } from './chordvoicing.js'; export class ChordFactory { constructor(chord, startWithRoot = true, tuning = settings.tuning) { console.log("ChordFactory Recieved Notes: ", chord.notes) this.identifier = chord.name this.notes = chord.notes; settings.startWithRoot = settings.startWithRoot this.root = chord.rootNote this.tuning = tuning; this.fingerPositions = this.calculateValidFingerPositions(); this.allChords = this.generateAllChordCombinations2() this.playableChords = this.filterPlayableChords2(structuredClone(this.allChords)) //this.getFretSpanStatistics() this.sortPlayableChordsByCombinedRating(1) } getFretSpanStatistics() { let spanCounts = {}; // Object to store the count of each span // Iterate over all chord combinations this.allChords.forEach(chord => { // Filter out muted and open strings, keeping only fretted notes const frets = chord.filter(fret => fret > 0); if (frets.length > 1) { // Ensure there's more than one fretted note to calculate a span const minFret = Math.min(...frets); const maxFret = Math.max(...frets); const span = maxFret - minFret; // Update the count for the calculated span if (span in spanCounts) { spanCounts[span] = spanCounts[span] + 1; } else { spanCounts[span] = 1; } } }); // Log the statistics for review console.log("Fret Span Statistics:", spanCounts); return spanCounts; } calculateValidFingerPositions() { const fingerPositions = []; for (let stringIndex of this.tuning) { const positions = []; for (let chordIndex of this.notes) { const validPositions = this.getValidFretPositionsForNote(chordIndex, stringIndex % 12); positions.push(...validPositions); } if (settings.mutePermutations) { positions.push(-1); // Add -1 only if there is no 0 } positions.sort((a, b) => a - b); // Sort the positions from lowest to highest fingerPositions.push(positions); } return fingerPositions; } getValidFretPositionsForNote(noteIndex, stringIndex) { const baseFret = (noteIndex - stringIndex + 120) % 12; return [baseFret, baseFret + 12]; } cartesianProduct(arrays) { return arrays.reduce((acc, curr) => { return acc.flatMap(a => curr.map(b => [...a, b])); }, [[]]); } //Highly efficent Variant of the Cartesian Product, That will not calulate any position twice generateAllChordCombinations2() { const startTime = performance.now(); let insertedTempIndexes = []; let chords = []; //console.log("Initial chords array:", chords); let maskScope = Array.from({ length: 6 }, () => []); // Initialize the Masscope Array, so that it has stuff loaded. THe algorithm cant work without anything in there, as then the laoding will not make it pssible to catch the firdst few permutations /* for (let string = 0; string < 6; string++) { maskScope[string][0] = this.fingerPositions[string][0] } */ //console.log("Initial maskScope array:", maskScope); const fingerIndexStorage = Array(6).fill(0); //console.log("Initial fingerIndexStorage array:", fingerIndexStorage); let fingerIndexLength = [] this.fingerPositions.forEach((element, index) => { fingerIndexLength[index] = element.length - 1 }) //console.log("Finger index lengths for all strings:", fingerIndexLength); // As the first entry of the chords is allways -1 we can skip this for (let fret = -1; fret < 13; fret++) { //console.log("generateAllChordCombinations2 - FRET: ", fret) for (let string = 0; string < 6; string++) { console.log("maskScope before" ,structuredClone(maskScope)) for (let validPosition = 0; validPosition < maskScope[string].length; validPosition++) { // FIrst remove all Non Fitting Elements From Out current maskScope on All Strings. // Exclude The -1 (muted) and 0 (open string) Because they can be used everywhere if (maskScope[string][validPosition] > 0 && maskScope[string][validPosition] < fret) { maskScope[string].splice(validPosition, 1); } } } //for (let i = 0; i < 6; i++) { //console.log("generateAllChordCombinations2 - maskScope: ", i, maskScope[i]) //} //Now We deleted all old ElementInternals, we can start inserting New elements one by one for (let string = 0; string < 6; string++) { //console.log("generateAllChordCombinations2 Fret, String", fret, string) // Add The New Element, if there is one // First Check If there is a New Element inside the Array if (fingerIndexStorage[string] < fingerIndexLength[string]) { // CHeck if its in range for Valid CHord, if so add it if (this.fingerPositions[string][fingerIndexStorage[string]] < fret + settings.fingerFretRange) { console.log("generateAllChordCombinations2 Pushing into maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]] ", maskScope[string], string, this.fingerPositions[string][fingerIndexStorage[string]]) console.log("fret, string", fret, string) maskScope[string].push(this.fingerPositions[string][fingerIndexStorage[string]]) console.log("maskScope after" ,structuredClone(maskScope)) //As The For Loop exists if one mask scope is not set = [] we need to populate the not set masks with -1 as there is no valid string in reach we can play, so we need to mute it. insertedTempIndexes = []; for (let i = 0; i < maskScope.length; i++) { if (maskScope[i].length == 0) { maskScope[i].push(-1); insertedTempIndexes.push(i); } } for (let pos1 of maskScope[(string + 1) % 6]) { for (let pos2 of maskScope[(string + 2) % 6]) { for (let pos3 of maskScope[(string + 3) % 6]) { for (let pos4 of maskScope[(string + 4) % 6]) { for (let pos5 of maskScope[(string + 5) % 6]) { let newVoicing = [] newVoicing[string] = this.fingerPositions[string][fingerIndexStorage[string]] newVoicing[(string + 1) % 6] = pos1 newVoicing[(string + 2) % 6] = pos2 newVoicing[(string + 3) % 6] = pos3 newVoicing[(string + 4) % 6] = pos4 newVoicing[(string + 5) % 6] = pos5 console.log("NEW: ", structuredClone(newVoicing)) chords.push(newVoicing); } } } } } //Flag the next index to be looked at later fingerIndexStorage[string]++ //Remove The -1s we added from maskscope. for (let i of insertedTempIndexes) { maskScope[i].pop(); } } else { //Break because the element found is too big to be inserte into the maskScope } } else { //break because there are no more elments left in the Array } //Calculate the Cartesian Product From the Inserted element // Add each element to the chords } } // Track end time const endTime = performance.now(); // Calculate the time taken const timeTaken = endTime - startTime; console.log("generateAllChordCombinations2 - Time taken:", timeTaken, "milliseconds"); return chords; } filterPlayableChords(allChordsCopy) { const startTime = performance.now(); const playableChordsSet = new Set(); allChordsCopy.forEach(voicing => { // Start By Muting All Chords if (settings.startWithRoot) { for (let string = 0; string < 6; string++) { if (voicing[string] == -1) { continue; } else if (((voicing[string] + this.tuning[string]) % 12) != this.root) { voicing[string] = -1; } else { break; } } } // Faster Way to Calculate the MinaboveZero let minAboveZero = Infinity; for (let i = 0; i < voicing.length; i++) { if (voicing[i] > 0 && voicing[i] < minAboveZero) { minAboveZero = voicing[i]; } } if (minAboveZero === Infinity) { minAboveZero = 0; } let fingersUsed = 0; let barreStop = false; let barreUseFingers = 0; let barreAddFingers = 0; for (let i = 5; i >= 0; i--) { if (voicing[i] <= 0) { barreStop = true; } if (voicing[i] >= minAboveZero && barreStop == false) { barreUseFingers++; if (voicing[i] > minAboveZero) { barreAddFingers++; } } else if (voicing[i] > 0 && voicing[i] !== "x") { barreAddFingers++; } } if (barreUseFingers) { if (barreUseFingers >= 2 && barreAddFingers > 3) { return; } else if (barreUseFingers < 2) { fingersUsed = voicing.filter(fret => fret >= minAboveZero).length; barreUseFingers = 0; } } if (fingersUsed <= 4) { let newVoicing = new ChordVoicing( voicing, barreUseFingers > 0 ? minAboveZero : null, barreUseFingers > 0 ? barreAddFingers : fingersUsed, barreUseFingers, minAboveZero, this.notes, settings.startWithRoot ? this.root : -1 ); playableChordsSet.add(JSON.stringify(newVoicing)); } }); // Convert the Set back to an array of unique ChordVoicing objects const playableChords = Array.from(playableChordsSet).map(voicingString => JSON.parse(voicingString)); // Track end time const endTime = performance.now(); // Calculate the time taken const timeTaken = endTime - startTime; console.log("filterPlayableChords - Time taken:", timeTaken, "milliseconds"); return playableChords; } filterPlayableChords2(allChordsCopy) { const startTime = performance.now(); let playableChordsVoicingSet = new Set(); let playableChordsArray = [] let totalChordVoicingTime = 0; // Initialize a variable to accumulate time for ChordVoicing creation // Pre-create and reuse these objects - Testing Showed This is faster than Creating them newly let barreClass = Array.from({ length: MAX_FRETS }, () => Array.from({ length: 6 }, () => [])); let barreClassesUsed = new Set(); let barreSeparatorIndex = Array.from({ length: MAX_FRETS }, () => 0); let minAboveZero = 99; let mutingTillRoot = true; let touchedSet = new Set(); let barres = [] let touchedIndices = []; let fingerPositionsCounter = 0 let fingerPositions = [-1, -1, -1, -1, -1, -1] let fingerPositionsAmmount = 0 let actuallyPlayedNotes = [-1, -1, -1, -1, -1, -1] allChordsCopy.forEach(voicing => { minAboveZero = 99; mutingTillRoot = true; // Reset values for each iteration barreClass.forEach(fretArray => fretArray.forEach(stringArray => stringArray.length = 0)); barreClassesUsed.clear(); touchedSet.clear() barreSeparatorIndex.fill(0); barres = [] touchedIndices = []; fingerPositionsCounter = 0 fingerPositions = [-1, -1, -1, -1, -1, -1] fingerPositionsAmmount = 0 //Calcualte the Real played Notes for (let i = 0; i < 6; i++) { if (voicing[i] >= 0) { actuallyPlayedNotes[i] = (voicing[i] + settings.tuning[i]) } else { actuallyPlayedNotes[i] = voicing[i] } } for (let string = 0; string < 6; string++) { //Mute Strings That are not the Root Note if (settings.startWithRoot && mutingTillRoot) { if (actuallyPlayedNotes[string] == -1) { // Do Nothing } else if (((actuallyPlayedNotes[string]) % 12) != this.root) { // Mute The String voicing[string] = -1; } else { mutingTillRoot = false; } } //Count Total Fingers Used in this voicing. if (voicing[string] > 0) { fingerPositionsAmmount++ if (voicing[string] < minAboveZero) { minAboveZero = voicing[string]; } } } // Check if the voicing is already in the set let voicingString = "V-" + voicing[0] + voicing[1] + voicing[2] + voicing[3] + voicing[4] + voicing[5]; if (playableChordsVoicingSet.has(voicingString)) { //console.log("Allready Has Voicing, Skipping...") return; // Skip processing if voicing is already in the set } //Remove Chords Below two fingers used. if (fingerPositionsAmmount < 2) { return } //Take a Look at the Ammount of fingers Required. If is less than 5 no barre needs to be caluclated. if (fingerPositionsAmmount > 4) { for (let string = 0; string < 6; string++) { //Mute Strings That are not the Root Note //Now, Place the Strings in their Corresponding barreClass if (voicing[string] >= 0) { barreClassesUsed.forEach((index) => { if (voicing[string] < index) { barreSeparatorIndex[index] += 1; } }); barreClassesUsed.add(voicing[string]); barreClass[voicing[string]][barreSeparatorIndex[voicing[string]]].push(string); const newIndex = `${voicing[string]}-${barreSeparatorIndex[voicing[string]]}`; if (!touchedSet.has(newIndex)) { touchedIndices.push([voicing[string], barreSeparatorIndex[voicing[string]]]); touchedSet.add(newIndex); } } } // Sort touchedIndices from lowest to highest fret touchedIndices.sort(([fretA], [fretB]) => fretA - fretB); //console.log(touchedIndices) touchedIndices.forEach(([fret, index]) => { if (barreClass[fret][index].length > 0) { if (barreClass[fret][index].length > 1 && fret != 0) { barres.push([fret, Math.min(...barreClass[fret][index]), Math.max(...barreClass[fret][index])]) fingerPositionsCounter++ barreClass[fret][index].forEach(element => { fingerPositions[element] = fingerPositionsCounter }) } else if (fret != 0) { fingerPositionsCounter++ fingerPositions[barreClass[fret][index]] = fingerPositionsCounter } } }); //Check if 5 Finger are still used, If so, Remove the CHord. if (fingerPositionsCounter > 4) { return } } else { //console.log("SkippedBarre Because The Fingers are to less") //No Barre Requred, so we can just calulate Where each finger goes. for (let fret = 0; fret < settings.fingerFretRange; fret++) { for (let string = 0; string < 6; string++) { if (minAboveZero + fret == voicing[string] && fingerPositions[string] !== 1 && voicing[string] !== 0) { fingerPositionsCounter++ fingerPositions[string] = fingerPositionsCounter } } } } //IF minabove Zero Was note set, Set it to zero if (minAboveZero == 99) { minAboveZero = 0 } const chordVoicingStartTime = performance.now(); let newVoicing = new ChordVoicing( voicing, fingerPositions, barres, minAboveZero, fingerPositionsAmmount, this.notes, settings.startWithRoot ? this.root : -1, actuallyPlayedNotes ); const chordVoicingEndTime = performance.now(); const chordVoicingTimeTaken = chordVoicingEndTime - chordVoicingStartTime; totalChordVoicingTime += chordVoicingTimeTaken; playableChordsVoicingSet.add(voicingString); playableChordsArray.push(newVoicing); //console.log("filterPlayableChords2 - voicing, barres", voicing, barres); //Now Check For each Barre Class Starting at MinAboveZero... }); const endTime = performance.now(); // Calculate the time taken const totalTimeTaken = endTime - startTime; console.log("filterPlayableChords2 - Total time taken:", totalTimeTaken, "milliseconds"); console.log("Total time taken for ChordVoicings:", totalChordVoicingTime, "milliseconds"); return playableChordsArray } /** * Sorts the playable chords by a combined rating based on sound quality and * playability. The combined rating is calculated using a weighted sum of * the sound quality rating and the playability rating. * * @param {number} soundWeight - A value between 0 and 1 that determines the weight * given to the sound quality rating. The weight given to the playability rating * will be (1 - soundWeight). * * Usage example: * ```javascript * const chordFactory = new ChordFactory(notes, root, startWithRoot, tuning); * chordFactory.sortPlayableChordsByCombinedRating(0.7); * console.log(chordFactory.playableChords); // Sorted chords based on the combined rating * ``` * * @throws {Error} If `soundWeight` is not a number between 0 and 1. */ sortPlayableChordsByCombinedRating(soundWeight = 0) { if (typeof soundWeight !== 'number' || soundWeight < 0 || soundWeight > 1) { throw new Error("soundWeight must be a number between 0 and 1."); } console.log("Sorting...") this.playableChords.sort((a, b) => { let aCombinedRating = (a.soundQualityRating * soundWeight) + (a.playabilityRating * (1 - soundWeight)); let bCombinedRating = (b.soundQualityRating * soundWeight) + (b.playabilityRating * (1 - soundWeight)); return bCombinedRating - aCombinedRating; }); } }

File: chordvoicing.js
Path: chord-factory\chordvoicing.js

import { settings } from './constants.js'; 

File: constants.js
Path: chord-factory\constants.js

// constants.js export const BARRE_RATING = 1 export const MAX_FRETS = 24 /** * Class representing application settings. */ class Settings { /** * Create a settings object with default values. */ constructor() { this._tuning = [40, 45, 50, 55, 59, 64]; this._fingerFretRange = 4; this._mutePermutations = false this._startWithRoot = true; } /** * Get the current tuning values. * @returns {number[]} The current tuning values as an array of integers. */ get tuning() { return this._tuning; } /** * Set new tuning values. * @param {number[]} value - An array of integers representing the new tuning values. * @throws {Error} Throws an error if the value is not an array of integers. */ set tuning(value) { if (Array.isArray(value) && value.every(num => Number.isInteger(num))) { this._tuning = value; } else { throw new Error(__PRESERVED__0__); } } /** * Get the current finger fret range. * @returns {number} The current finger fret range as a positive integer. */ get fingerFretRange() { return this._fingerFretRange; } /** * Set a new finger fret range. * @param {number} value - A positive integer representing the new finger fret range. * @throws {Error} Throws an error if the value is not a positive integer. */ set fingerFretRange(value) { if (Number.isInteger(value) && value > 0) { this._fingerFretRange = value; } else { throw new Error(__PRESERVED__1__); } } /** * Get the current mutePermutations value. * @returns {boolean} The current mutePermutations value. */ get mutePermutations() { return this._mutePermutations; } /** * Set a new mutePermutations value. * @param {boolean} value - A boolean representing the new mutePermutations value. * @throws {Error} Throws an error if the value is not a boolean. */ set mutePermutations(value) { if (typeof value === __PRESERVED__2__) { this._mutePermutations = value; } else { throw new Error(__PRESERVED__3__); } } /** * Get the current startWithRoot value. * @returns {boolean} The current startWithRoot value. */ get startWithRoot() { return this._startWithRoot; } /** * Set a new startWithRoot value. * @param {boolean} value - A boolean representing the new startWithRoot value. * @throws {Error} Throws an error if the value is not a boolean. */ set startWithRoot(value) { if (typeof value === 'boolean') { this._startWithRoot = value; } else { throw new Error("Invalid startWithRoot value. It must be a boolean."); } } } export const settings = new Settings();

File: main.js
Path: chord-factory\main.js

import { settings } from './constants.js'; import { ChordFactory } from './chordfactory.js'; let totalDuration = 0; const repetitions = 50; let lastPlayChords; for (let i = 0; i < repetitions; i++) { const startTime = performance.now(); const chord = new ChordFactory("E, G, B", 4, true, settings.tuning); const playableChords = chord.playableChords if (i === repetitions - 1) { // Only save the last result lastPlayChords = playableChords; } const endTime = performance.now(); totalDuration += endTime - startTime; // Calculate the duration for this iteration } // Sort lastPlayChords by difficulty if (lastPlayChords && lastPlayChords.length > 0) { lastPlayChords.sort((a, b) => a.rating - b.rating); } lastPlayChords.forEach((chord) => console.log(chord)); // Calculate the average time const averageTime = totalDuration / repetitions; console.log(`Average Processing Time: ${averageTime.toFixed(2)} ms`);

File: utils.js
Path: chord-factory\utils.js

// Mapping of musical notes to their respective index numbers export const NOTE_INDEX_MAP = { __PRESERVED__0__: 0, __PRESERVED__1__: 1, __PRESERVED__2__: 1, __PRESERVED__3__: 2, __PRESERVED__4__: 3, __PRESERVED__5__: 3, __PRESERVED__6__: 4, __PRESERVED__7__: 4, __PRESERVED__8__: 5, __PRESERVED__9__: 6, __PRESERVED__10__: 6, __PRESERVED__11__: 7, __PRESERVED__12__: 8, __PRESERVED__13__: 8, __PRESERVED__14__: 9, __PRESERVED__15__: 10, __PRESERVED__16__: 10, __PRESERVED__17__: 11, __PRESERVED__18__: 11 }; // Reverse mapping for number to note conversion const NOTE_ARRAY = [__PRESERVED__19__, __PRESERVED__20__, __PRESERVED__21__, __PRESERVED__22__, __PRESERVED__23__, __PRESERVED__24__, __PRESERVED__25__, __PRESERVED__26__, __PRESERVED__27__, __PRESERVED__28__, __PRESERVED__29__, __PRESERVED__30__]; // Convert a note to its respective index number export function noteToNumber(note) { const normalizedNote = note.toUpperCase().replace(/[\s#]+/g, __PRESERVED__31__).replace(/[\sB]+/g, __PRESERVED__32__); return NOTE_INDEX_MAP.hasOwnProperty(normalizedNote) ? NOTE_INDEX_MAP[normalizedNote] : __PRESERVED__33__; } // Convert a number to its respective musical note export function numberToNote(number) { return NOTE_ARRAY[number % 12]; } export function parseNotes(input) { return input.toUpperCase() .replace(/B#/g, __PRESERVED__34__).replace(/E#/g, __PRESERVED__35__) .split(/[\s,]+/) .filter(note => NOTE_INDEX_MAP.hasOwnProperty(note)); } export function removeDuplicateArrays(arrays) { const uniqueArrays = new Set(); return arrays.filter(array => { const serialized = JSON.stringify(array); if (!uniqueArrays.has(serialized)) { uniqueArrays.add(serialized); return true; } return }); }

File: script.js
Path: chord-library\script.js

import { DragAndDropItem } from "../drag-drop/script.js"; /** * Represents a musical chord. * * @class Chord * @constructor * @param {number} rootNote - The root note of the chord, represented as an integer from 0 to 11. * 0 corresponds to C, 1 to C#, 2 to D, and so on. * @param {number[]} notes - An array of integers representing the notes of the chord. * Each note is represented as an integer from 0 to 11. * @param {string} name - The full name of the chord, e.g., "Gm", "Asus4". * @param {boolean} customRoot - A flag indicating if the root note is custom. * * @example * // Create a G minor chord * const gMinor = new Chord(7, [7, 10, 2], __PRESERVED__3__, false); * * @example * // Create an A suspended 4th chord with a custom root * const aSus4 = new Chord(9, [9, 0, 5], __PRESERVED__4__, true); * * @property {number} rootNote - The root note of the chord. * @property {number[]} notes - The notes that make up the chord. * @property {string} name - The name of the chord. * @property {boolean} customRoot - Indicates if the root note is custom. */ export class Chord { constructor(rootNote, notes, name, customRoot) { this.rootNote = rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc. this.notes = notes; // Array of integers representing notes of the chord this.name = name; // String representing the full name of the chord, e.g., __PRESERVED__5__, __PRESERVED__6__ this.customRoot = customRoot console.log(__PRESERVED__7__ + this.name + __PRESERVED__8__ + this.rootNote + __PRESERVED__9__ + this.notes) } } export class ChordLibrary { constructor() { this.chords = []; this.noteNames = [__PRESERVED__10__, __PRESERVED__11__, __PRESERVED__12__, __PRESERVED__13__, __PRESERVED__14__, __PRESERVED__15__, __PRESERVED__16__, __PRESERVED__17__, __PRESERVED__18__, __PRESERVED__19__, __PRESERVED__20__, __PRESERVED__21__]; this.chordStructures = { __PRESERVED__22__: { notes: [0, 4, 7], priority: 1 }, // Major __PRESERVED__23__: { notes: [0, 3, 7], priority: 2 }, // Minor __PRESERVED__24__: { notes: [0, 4, 7, 10], priority: 3 }, // Dominant 7th __PRESERVED__25__: { notes: [0, 4, 7, 11], priority: 4 }, // Major 7th __PRESERVED__26__: { notes: [0, 3, 7, 10], priority: 5 }, // Minor 7th __PRESERVED__27__: { notes: [0, 3, 7, 11], priority: 18 }, // Minor Major 7th __PRESERVED__28__: { notes: [0, 2, 7], priority: 7 }, // Suspended 2nd __PRESERVED__29__: { notes: [0, 5, 7], priority: 6 }, // Suspended 4th __PRESERVED__30__: { notes: [0, 3, 6], priority: 9 }, // Diminished __PRESERVED__31__: { notes: [0, 4, 8], priority: 8 }, // Augmented __PRESERVED__32__: { notes: [0, 4, 7, 10, 14], priority: 11 }, // Dominant 9th __PRESERVED__33__: { notes: [0, 4, 7, 11, 14], priority: 12 }, // Major 9th __PRESERVED__34__: { notes: [0, 3, 7, 10, 14], priority: 13 }, // Minor 9th __PRESERVED__35__: { notes: [0, 4, 7, 10, 14, 17], priority: 16 }, // Dominant 11th __PRESERVED__36__: { notes: [0, 4, 7, 10, 14, 17, 21], priority: 24 }, // Dominant 13th __PRESERVED__37__: { notes: [0, 2, 4, 7], priority: 17 }, // Added 9th __PRESERVED__38__: { notes: [0, 3, 7, 9], priority: 14 }, // Minor 6th __PRESERVED__39__: { notes: [0, 4, 7, 9], priority: 15 }, // Major 6th __PRESERVED__40__: { notes: [0, 7], priority: 10 }, // Power chord __PRESERVED__41__: { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6/9 'm11': { notes: [0, 3, 7, 10, 14, 17], priority: 39 }, // Minor 11 __PRESERVED__43__: { notes: [0, 4, 7, 11, 18], priority: 29 }, // Major 7#11 __PRESERVED__44__: { notes: [0, 3, 6, 10], priority: 19 }, // Half-Diminished __PRESERVED__45__: { notes: [0, 4, 8, 10], priority: 21 }, // Augmented 7th __PRESERVED__46__: { notes: [0, 3, 6, 9], priority: 20 }, // Diminished 7th __PRESERVED__47__: { notes: [0, 4, 8, 11], priority: 28 }, // Augmented Major 7th __PRESERVED__48__: { notes: [0, 3, 7, 11, 14], priority: 18 }, // Minor Major 9th __PRESERVED__49__: { notes: [0, 3, 6, 11], priority: 22 }, // Diminished Major 7th __PRESERVED__50__: { notes: [0, 4, 6, 10, 13], priority: 23 }, // Altered Dominant __PRESERVED__51__: { notes: [0, 4, 7, 11, 14, 17, 21], priority: 24 }, // Major 13th __PRESERVED__52__: { notes: [0, 4, 7, 11, 14, 17], priority: 25 }, // Major 11th __PRESERVED__53__: { notes: [0, 5, 7, 11], priority: 26 }, // Major 7th Suspended 4th __PRESERVED__54__: { notes: [0, 3, 8, 10], priority: 27 }, // Minor 7th #5 __PRESERVED__55__: { notes: [0, 4, 8], priority: 28 }, // Major #5 __PRESERVED__56__: { notes: [0, 4, 7, 10, 14, 18], priority: 29 }, // Dominant 9th #11 __PRESERVED__57__: { notes: [0, 4, 7, 10, 14, 18, 21], priority: 30 }, // Dominant 13th #11 __PRESERVED__58__: { notes: [0, 4, 6, 10], priority: 31 }, // Dominant 7th Flat Five __PRESERVED__59__: { notes: [0, 4, 6, 11], priority: 32 }, // Major 7th Flat Five __PRESERVED__60__: { notes: [0, 4, 8, 11], priority: 33 }, // Major 7th Sharp Five __PRESERVED__61__: { notes: [0, 3, 7, 10, 13], priority: 34 }, // Minor 7th Flat Nine __PRESERVED__62__: { notes: [0, 4, 6, 10, 14], priority: 34 }, // 9th Flat Five __PRESERVED__63__: { notes: [0, 4, 8, 10, 14], priority: 35 }, // 9th Sharp Five __PRESERVED__64__: { notes: [0, 4, 7, 10, 13], priority: 36 }, // Dominant 7th Flat Nine __PRESERVED__65__: { notes: [0, 4, 7, 10, 15], priority: 37 }, // Dominant 7th Sharp Nine __PRESERVED__66__: { notes: [0, 4, 7, 10, 18], priority: 38 }, // Dominant 7th Sharp Eleven __PRESERVED__67__: { notes: [0, 3, 7, 10, 17], priority: 39 }, // Minor 7th Add 11 __PRESERVED__68__: { notes: [0, 2, 4, 7], priority: 40 }, // Major Add 2 __PRESERVED__69__: { notes: [0, 4, 5, 7], priority: 41 }, // Major Add 4 __PRESERVED__70__: { notes: [0, 4, 7, 9, 14], priority: 42 }, // Major 6 Add 9 __PRESERVED__71__: { notes: [0, 4, 7], root: 0, priority: 43 }, // C Major __PRESERVED__72__: { notes: [0, 3, 7], root: 0, priority: 44 }, // C Minor __PRESERVED__73__: { notes: [0, 4, 7], root: 1, priority: 43 }, // C# Major __PRESERVED__74__: { notes: [0, 3, 7], root: 1, priority: 44 }, // C# Minor __PRESERVED__75__: { notes: [0, 4, 7], root: 2, priority: 43 }, // D Major __PRESERVED__76__: { notes: [0, 3, 7], root: 2, priority: 44 }, // D Minor __PRESERVED__77__: { notes: [0, 4, 7], root: 3, priority: 43 }, // D# Major __PRESERVED__78__: { notes: [0, 3, 7], root: 3, priority: 44 }, // D# Minor __PRESERVED__79__: { notes: [0, 4, 7], root: 4, priority: 43 }, // E Major __PRESERVED__80__: { notes: [0, 3, 7], root: 4, priority: 44 }, // E Minor __PRESERVED__81__: { notes: [0, 4, 7], root: 5, priority: 43 }, // F Major __PRESERVED__82__: { notes: [0, 3, 7], root: 5, priority: 44 }, // F Minor __PRESERVED__83__: { notes: [0, 4, 7], root: 6, priority: 43 }, // F# Major __PRESERVED__84__: { notes: [0, 3, 7], root: 6, priority: 44 }, // F# Minor __PRESERVED__85__: { notes: [0, 4, 7], root: 7, priority: 43 }, // G Major __PRESERVED__86__: { notes: [0, 3, 7], root: 7, priority: 44 }, // G Minor __PRESERVED__87__: { notes: [0, 4, 7], root: 8, priority: 43 }, // G# Major __PRESERVED__88__: { notes: [0, 3, 7], root: 8, priority: 44 }, // G# Minor __PRESERVED__89__: { notes: [0, 4, 7], root: 9, priority: 43 }, // A Major __PRESERVED__90__: { notes: [0, 3, 7], root: 9, priority: 44 }, // A Minor __PRESERVED__91__: { notes: [0, 4, 7], root: 10, priority: 43 }, // A# Major __PRESERVED__92__: { notes: [0, 3, 7], root: 10, priority: 44 }, // A# Minor __PRESERVED__93__: { notes: [0, 4, 7], root: 11, priority: 43 }, // B Major __PRESERVED__94__: { notes: [0, 3, 7], root: 11, priority: 44 } // B Minor }; this.generateChords(); } generateChords() { Object.entries(this.chordStructures).forEach(([suffix, structure]) => { for (let i = 0; i < 12; i++) { let rootNote = i let customRoot = false let notes = structure.notes.map(interval => (i + interval) % 12); const chordName = __PRESERVED__95__; if (structure.root !== undefined) { // Filter Dumb Chord Like C/C D/D if (structure.root == rootNote) { continue; } rootNote = structure.root; customRoot = true; notes.push(rootNote); } const chord = new Chord(rootNote, notes, chordName, customRoot); chord.priority = structure.priority; this.chords.push(chord); } }); // Sort chords by priority this.chords.sort((a, b) => a.priority - b.priority); } async searchChords(noteArray, rootNote, threshold = 50) { console.log(__PRESERVED__96__) const results = []; noteArray = noteArray.map(note => note % 12); // Normalize notes to be within octave if (rootNote) { rootNote = rootNote % 12 } const inputNotesSet = new Set(noteArray); this.chords.forEach(chord => { let chordNotes = [...chord.notes]; //console.log(__PRESERVED__97__ + chord.name) //Add the Root note to the Chords For Cases like A/D //console.log(__PRESERVED__98__, inputNotesSet); const commonNotes = new Set([...chordNotes].filter(note => inputNotesSet.has(note))); //console.log(__PRESERVED__99__, commonNotes); const totalUniqueNotes = new Set([...chordNotes, ...noteArray]); //console.log(__PRESERVED__100__, totalUniqueNotes); let matchPercentage = (commonNotes.size / totalUniqueNotes.size) * 100; //console.log(__PRESERVED__101__ + rootNote + __PRESERVED__102__ + chord.rootNote); // Adjusting match percentage based on root note comparison if (rootNote !== null) { if (chord.rootNote == rootNote) { //console.log(__PRESERVED__103__ + chord.name + __PRESERVED__104__ + chord.rootNote + __PRESERVED__105__ + chordNotes) // If root notes match, this is fine as calculated } else { // Penalize the match percentage slightly if root notes don__PRESERVED__106__Chord found:__PRESERVED__107__No chord found with the name:__PRESERVED__108__C__PRESERVED__109__C#__PRESERVED__110__D__PRESERVED__111__D#__PRESERVED__112__E__PRESERVED__113__F__PRESERVED__114__F#__PRESERVED__115__G__PRESERVED__116__G#__PRESERVED__117__A__PRESERVED__118__A#__PRESERVED__119__B__PRESERVED__120__/')) { [mainChordName, bassNote] = chord.name.split('/__PRESERVED__122__'; if (bassNote) { // Find the index of the bass note const bassNoteIndex = noteNames.indexOf(bassNote); // Transpose the bass note const transposedBassNote = (bassNoteIndex + semitones) % 12; transposedBassNoteName = noteNames[transposedBassNote]; } // Construct the transposed chord name const transposedName = transposedBassNoteName ? `${transposedMainChordName}/${transposedBassNoteName}` : transposedMainChordName; return new Chord(transposedRootNote, transposedNotes, transposedName, chord.customRoot); } }

File: index.html
Path: chordviewer\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Piano2Guitar</title> <!-- STYLESHEETS --> <link rel="stylesheet" href="../piano/style.css" /> <link rel="stylesheet" href="../progression-generator/style.css" /> <link rel="stylesheet" href="../css/output-styles.css" /> <link rel="stylesheet" href="../css/input-styles.css" /> <link rel="stylesheet" href="../css/slider-styles.css" /> <link rel="stylesheet" href="../css/settings-styles.css" /> <link rel="stylesheet" href="styles.css" /> <!-- FONT --> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet"> <!-- SCRIPTS --> <script type="module" src="./index.js"></script> </head> <body> <div class="inputWrapper"> <div class="header"> PianoToGuitar.com - ChordViewer <svg class="visualPianoIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" /> </svg> </div> <div class="searchContainer"> <div class="searchContainerWrapper"> <div class="searchContainer"> <div class="searchWordContainer"> <div class="blackFadeBottom"></div> <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name..."> <div class="searchChordList" id="itemsContainer"> <!-- Items will be populated here by JavaScript --> </div> </div> </div> </div> <div class="selectedItemWrapper"> <div class="selectedItemsHeading"> <div>Your Selected Chord</div> </div> <div class="selectedItemsWrapper"> <div class="selectedItems" id="selectedItems"> <!-- Dragged items will appear here --> </div> <svg class="visualPianoIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> </div> </div> <div class="outputWrapper" id="outputWrapper"> <div class="progression"> <div class="progressionWrapper" id="dynamicProgressionWrapper"></div> <div class="progressionInfo"> <div class="progressionInfoText"> <div class="progressionInfoTextName"><i>DYNAMIC</i></div> <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the most beautifully sounding ones! </div> </div> <div class="soundQualityWrapper"> <input id="soundQualitySlider" type="range" min="0" max="100" value="50"> <div class="soundQualityLables"> <div>EASY</div> <div>BEST SOUND</div> </div> </div> </div> </div> </body> </html>

File: index.js
Path: chordviewer\index.js

import DragAndDropList from '../drag-drop/script.js'; import { ChordLibrary } from "../chord-library/script.js" import { ProgressionGenerator } from '../progression-generator/main.js'; import { settings } from '../chord-factory/constants.js'; document.addEventListener('DOMContentLoaded', () => { // Get All Chords From the Libaray const chordLibrary = new ChordLibrary // Create the Search and Drag and Drop const allChordLibraryItems = chordLibrary.getAllChords() const dropzone = __PRESERVED__5__; const itemsContainer = __PRESERVED__6__; const itemSearch = __PRESERVED__7__; const selectedItems = __PRESERVED__8__; const emptyMessageContainer = __PRESERVED__9__; const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer); window.clearProgression = function () { dragAndDropList.clearSelectedList(); console.log(__PRESERVED__10__); }; let soundQualityValue = 1; let progressionGenerator = new ProgressionGenerator([], true, settings.tuning, __PRESERVED__11__, __PRESERVED__12__, true) document.addEventListener(__PRESERVED__13__, async function (event) { console.log(__PRESERVED__14__, event.detail.selectedItems[0]); await progressionGenerator.setProgression([event.detail.selectedItems[0]]) await updateProgressionDynamic(soundQualityValue) dragAndDropList.clearSelectedList(); }); const soundQualitySlider = document.getElementById(__PRESERVED__15__); soundQualitySlider.addEventListener(__PRESERVED__16__, async (e) => { soundQualityValue = e.target.value / 100; console.log("Slider Value:", soundQualityValue); await updateProgressionDynamic(soundQualityValue) }); async function updateProgressionDynamic(soundQualityValue) { let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue, 20); document.getElementById("dynamicProgressionWrapper").innerHTML = ""; document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML); }; 

File: createChatGPTContext.js
Path: createChatGPTContext.js

const fs = require('fs'); const path = require('path'); function isHtmlOrJsFile(file) { return file.endsWith('.html') || file.endsWith('.js'); } function getDirectoryStructure(dir, fileStructure = {}, parentPath = '') { const items = fs.readdirSync(dir); items.forEach(item => { const fullPath = path.join(dir, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { fileStructure[item] = {}; getDirectoryStructure(fullPath, fileStructure[item], path.join(parentPath, item)); } else if (isHtmlOrJsFile(item)) { fileStructure[item] = { path: fullPath, relativePath: path.join(parentPath, item), size: stats.size, lastModified: stats.mtime }; } }); return fileStructure; } function removeWhitespace(text) { return text.replace(/\s+/g, __PRESERVED__5__).trim(); } function removeComments(text) { const singleLineCommentPattern = /\/\/.*(?=[\n\r]|$)/g; const multiLineCommentPattern = /\/\*[\s\S]*?\*\//g; const stringPattern = /(['"`])(?:(?!\1|\\).|\\.)*\1/g; const regexPattern = /\/(?!\*)[^/\\\n]+\/[gimsuy]*/g; // Improved regex for JS regex patterns // Preserve strings and regex to avoid removing comment-like patterns within them const preservedItems = []; let preservedText = text.replace(stringPattern, match => { preservedItems.push(match); return `__PRESERVED__${preservedItems.length - 1}__`; }).replace(regexPattern, match => { preservedItems.push(match); return `__PRESERVED__${preservedItems.length - 1}__`; }); // Remove comments preservedText = preservedText.replace(singleLineCommentPattern, ''); preservedText = preservedText.replace(multiLineCommentPattern, ''); // Restore strings and regex patterns preservedText = preservedText.replace(/__PRESERVED__(\d+)__/g, (_, index) => preservedItems[Number(index)]); return preservedText; } function readAllFiles(dir, parentPath = '', removeWhitespaceSetting = false, removeCommentsSetting = false) { let allText = ''; const items = fs.readdirSync(dir); items.forEach(item => { const fullPath = path.join(dir, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { allText += readAllFiles(fullPath, path.join(parentPath, item), removeWhitespaceSetting, removeCommentsSetting); } else if (isHtmlOrJsFile(item)) { let fileContent = fs.readFileSync(fullPath, 'utf8'); if (removeWhitespaceSetting) { fileContent = removeWhitespace(fileContent); } if (removeCommentsSetting && item.endsWith('.js')) { fileContent = removeComments(fileContent); } allText += `File: ${item}\n`; allText += `Path: ${path.join(parentPath, item)}\n\n`; allText += fileContent + '\n\n'; } }); return allText; } function formatStructure(fileStructure, indent = 0) { let structureText = ''; const indentString = ' '.repeat(indent); for (const key in fileStructure) { if (typeof fileStructure[key] === 'object' && 'relativePath' in fileStructure[key]) { const { relativePath, size, lastModified } = fileStructure[key]; structureText += `${indentString}${key} (Path: ${relativePath})\n`; } else { structureText += `${indentString}${key}/\n`; structureText += formatStructure(fileStructure[key], indent + 2); } } return structureText; } try { const targetDir = path.join(__dirname, ''); // Change '' to your target folder const outputFilePath = path.join(__dirname, 'output.txt'); const removeWhitespaceSetting = true ; // Set to true to remove whitespace const removeCommentsSetting = true; // Set to true to remove comments // Get the folder and file structure const fileStructure = getDirectoryStructure(targetDir); // Format the structure to a string const structureText = formatStructure(fileStructure); // Read all the text from HTML and JS files const filesText = readAllFiles(targetDir, '', removeWhitespaceSetting, removeCommentsSetting); // Combine structure and file texts const finalOutput = `Directory Structure:\n${structureText}\nFile Contents:\n${filesText}`; // Write the final output to a file fs.writeFileSync(outputFilePath, finalOutput); console.log('Folder structure and file contents have been saved to output.txt'); } catch (error) { console.error('Error reading directory:', error.message); }

File: script.js
Path: drag-drop\script.js

import { Chord } from "../chord-library/script.js"; export class DragAndDropItem extends Chord { constructor(chord, probability = -1) { super(chord) this.rootNote = chord.rootNote; // Integer 0-11, where 0 = C, 1 = C#, 2 = D, etc. this.notes = chord.notes; // Array of integers representing notes of the chord this.name = chord.name; // String representing the full name of the chord, e.g., __PRESERVED__1__, __PRESERVED__2__ this.customRoot = chord.customRoot this.probability = probability } } export default class DragAndDropList { constructor(items, dropzoneId, itemsContainer, itemSearch, selectedItems, emptyMessage) { this.items = [] this.idCounter = 0; items.forEach(item => { this.items.push(new DragAndDropItem(item)) }) this.dropzoneId = dropzoneId; this.selectedItemsEvent = new CustomEvent(__PRESERVED__3__, { bubbles: true, detail: { selectedItems: [] } }); this.emptyMessageContainer = document.getElementById(emptyMessage); this.itemsContainer = document.getElementById(itemsContainer); this.selectedItemsContainer = document.getElementById(selectedItems); this.itemFilterInput = document.getElementById(itemSearch); this.selectedItemsArray = []; this.addEventListeners(); this.populateItemsList(); this.emptyMessage = __PRESERVED__4__; this.emptyMessageElement = document.createElement(__PRESERVED__5__); this.emptyMessageElement.id = __PRESERVED__6__; const words = this.emptyMessage.split(__PRESERVED__7__); const baseElement = this.createItemElement({ name: __PRESERVED__8__ }); baseElement.draggable = false; baseElement.isSelectable = false; words.forEach(word => { const clone = baseElement.cloneNode(true); clone.innerHTML = word; this.emptyMessageElement.appendChild(clone); }); this.selectedItemsContainer.appendChild(this.emptyMessageElement); } addEventListeners() { window.addEventListener(__PRESERVED__9__, this.handleWindowDragOver.bind(this)); window.addEventListener(__PRESERVED__10__, this.handleWindowDrop.bind(this)); this.selectedItemsContainer.addEventListener(__PRESERVED__11__, this.allowDrop.bind(this)); this.selectedItemsContainer.addEventListener(__PRESERVED__12__, this.handleDropOnContainer.bind(this)); this.itemFilterInput.addEventListener(__PRESERVED__13__, this.filterItems.bind(this)); } handleWindowDragOver(e) { e = e || event; if (e.target.id !== this.dropzoneId) { e.preventDefault(); } } handleWindowDrop(e) { e = e || event; if (e.target.id !== this.dropzoneId) { e.preventDefault(); } } last100PercentItemIndex() { let lastIndex = -1; for (let i = 0; i < this.items.length; i++) { if (this.items[i].probability === 100) { lastIndex = i; } } return lastIndex; } populateItemsList() { const lastIndex100Percent = this.last100PercentItemIndex(); let first100Percent = false; this.items.forEach((item, index) => { if (item.probability === 100 && !first100Percent) { first100Percent = true; const firstElement = document.createElement(__PRESERVED__14__); firstElement.style.width = __PRESERVED__15__; firstElement.innerHTML = __PRESERVED__16__; firstElement.style.backgroundColor = __PRESERVED__17__; firstElement.style.color = __PRESERVED__18__; firstElement.style.fontSize = __PRESERVED__19__; this.itemsContainer.appendChild(firstElement); } const itemElement = this.createItemElement(item, true); this.itemsContainer.appendChild(itemElement); if (index === lastIndex100Percent) { const breakElement = document.createElement(__PRESERVED__20__); breakElement.style.width = __PRESERVED__21__; breakElement.style.height = __PRESERVED__22__; breakElement.style.backgroundColor = __PRESERVED__23__; breakElement.style.boxShadow = __PRESERVED__24__; this.itemsContainer.appendChild(breakElement); } }); } createItemElement(item, isSelectable = false) { const itemElement = document.createElement(__PRESERVED__25__); itemElement.textContent = item.name; itemElement.className = __PRESERVED__26__; itemElement.id = __PRESERVED__27__; if (item.probability > 0) { const probabilitySpan = document.createElement(__PRESERVED__28__); probabilitySpan.textContent = __PRESERVED__29__; probabilitySpan.style.backgroundColor = this.getBackgroundColor(item.probability); if (item.probability === 100) { itemElement.style.boxShadow = __PRESERVED__30__; itemElement.style.fontWeight = __PRESERVED__31__; } itemElement.appendChild(probabilitySpan); } if (isSelectable) { itemElement.addEventListener(__PRESERVED__32__, () => this.addSelectedItem(item)); } return itemElement; } getBackgroundColor(probability) { const startColor = [255, 130, 130]; const endColor = [230, 230, 30]; const winnerColor = [150, 200, 0]; probability = Math.max(50, Math.min(100, probability)); const scaledProbability = (probability - 50) / 50; const adjustedProbability = Math.log10(1 + 9 * scaledProbability); let blendedColor = startColor.map((component, index) => { return Math.round(component + (endColor[index] - component) * adjustedProbability); }); if (probability === 100) { blendedColor = winnerColor; } return `rgb(${blendedColor.join(',')})`; } createSelectedItemElement(item) { const selectedItemElement = document.createElement('div'); selectedItemElement.className = 'selected-dragDropItem dragDropItem'; selectedItemElement.draggable = true; selectedItemElement.id = `selected-dragDropItem-${this.idCounter++}`; selectedItemElement.textContent = item.name; selectedItemElement.addEventListener('dragstart', this.handleDragStart.bind(this)); selectedItemElement.addEventListener('dragover', this.handleDragOver.bind(this)); selectedItemElement.addEventListener('drop', this.handleDropReorder.bind(this)); selectedItemElement.addEventListener('dragend', this.handleDragEnd.bind(this)); selectedItemElement.addEventListener('dragleave', this.handleDragLeave.bind(this)); selectedItemElement.addEventListener('click', this.removeSelectedItem.bind(this)); return selectedItemElement; } removeSelectedItem(event) { event.target.remove(); this.updateArrayFromList(); } addSelectedItem(item) { this.selectedItemsArray.push(item); this.updateDisplayArray(); } updateItems(newItems) { console.log("Updating Library..."); this.clearList(); this.items = newItems; this.populateItemsList(); } clearList() { this.items = []; while (this.itemsContainer.firstChild) { this.itemsContainer.removeChild(this.itemsContainer.firstChild); } } clearSelectedList() { this.selectedItemsArray = []; while (this.selectedItemsContainer.firstChild) { this.selectedItemsContainer.removeChild(this.selectedItemsContainer.firstChild); } this.updateDisplayArray(); } handleDropOnItemList(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (droppedItemElement && droppedItemElement.classList.contains('selected-dragDropItem')) { droppedItemElement.remove(); this.updateDisplayArray(); } } handleDragStart(event) { event.dataTransfer.setData('text/plain', event.target.id); if (event.target.classList.contains('selected-dragDropItem')) { event.target.classList.add('dragging'); } } handleDragOver(event) { event.preventDefault(); const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { targetElement.classList.add('over'); } } handleDragLeave(event) { event.preventDefault(); const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { targetElement.classList.remove('over'); } } handleDropReorder(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (!droppedItemElement) return; const targetElement = event.target.closest('.selected-dragDropItem'); if (targetElement) { if (droppedItemElement.classList.contains('selected-dragDropItem')) { this.insertAtCorrectPosition(droppedItemElement, targetElement); } } else { if (!droppedItemElement.classList.contains('selected-dragDropItem')) { const chordName = droppedItemElement.textContent.split(' (')[0]; const chord = this.items.find(item => item.name === chordName); if (chord) { const newClone = this.createSelectedItemElement(chord); this.selectedItemsContainer.appendChild(newClone); this.selectedItemsArray.push(chord); } } else { this.selectedItemsContainer.appendChild(droppedItemElement); this.updateDisplayArray(); } } this.updateDisplayArray(); } handleDragEnd(event) { event.target.classList.remove('dragging'); const overItems = document.querySelectorAll('.selected-dragDropItem'); overItems.forEach(item => item.classList.remove('over')); } allowDrop(event) { event.preventDefault(); } handleDropOnContainer(event) { event.preventDefault(); const droppedItemId = event.dataTransfer.getData('text/plain'); const droppedItemElement = document.getElementById(droppedItemId); if (droppedItemElement && !droppedItemElement.classList.contains('selected-dragDropItem')) { const chordName = droppedItemElement.textContent.split(' (')[0]; const chord = this.items.find(item => item.name === chordName); if (chord) { const newClone = this.createSelectedItemElement(chord); this.selectedItemsContainer.appendChild(newClone); this.selectedItemsArray.push(chord); this.updateDisplayArray(); } } } insertAtCorrectPosition(droppedItemElement, targetElement) { const droppedIndex = Array.from(this.selectedItemsContainer.children).indexOf(droppedItemElement); const targetIndex = Array.from(this.selectedItemsContainer.children).indexOf(targetElement); if (droppedIndex < targetIndex) { targetElement.after(droppedItemElement); } else { targetElement.before(droppedItemElement); } targetElement.classList.remove('over'); this.updateArrayFromList(); } updateArrayFromList(){ this.selectedItemsArray = Array.from(this.selectedItemsContainer.children).map(el => { const chordName = el.textContent.split(' (')[0]; return this.items.find(item => item.name === chordName); }); this.updateDisplayArray(); } updateDisplayArray() { this.selectedItemsContainer.innerHTML = "" if (this.selectedItemsArray.length == 0) { if (!this.emptyMessageElement.parentNode) { this.selectedItemsContainer.appendChild(this.emptyMessageElement); } } else { this.emptyMessageElement.remove(); } this.selectedItemsArray.forEach(item => { const selectedItemElement = this.createSelectedItemElement(item); this.selectedItemsContainer.appendChild(selectedItemElement); }) this.selectedItemsEvent.detail.selectedItems = [...this.selectedItemsArray]; document.dispatchEvent(this.selectedItemsEvent); console.log(`Selected Items: ${this.selectedItemsArray.map(item => item.name).join(', ')}`); } filterItems() { const filterValue = this.itemFilterInput.value.toUpperCase(); const itemElements = this.itemsContainer.querySelectorAll('.dragDropItem'); itemElements.forEach(itemElement => { const itemText = itemElement.textContent.toUpperCase(); itemElement.style.display = itemText.includes(filterValue) ? '' : 'none'; }); } getArray() { return [...this.selectedItemsArray]; } }

File: index.html
Path: index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Piano2Guitar</title> <!-- STYLESHEETS --> <link rel="stylesheet" href="piano/style.css" /> <link rel="stylesheet" href="progression-generator/style.css" /> <link rel="stylesheet" href="css/output-styles.css" /> <link rel="stylesheet" href="css/input-styles.css" /> <link rel="stylesheet" href="css/slider-styles.css" /> <link rel="stylesheet" href="css/settings-styles.css" /> <link rel="stylesheet" href="css/adv-settings.css" /> <link rel="stylesheet" href="css/footer.css" /> <link rel="stylesheet" href="css/header.css" /> <!-- FONT --> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet"> <!-- SCRIPTS --> <script type="module" src="./index.js"></script> </head> <body> <header>PianoToGuitar.com</header> <div class="content"> <div class="inputWrapper"> <div id="closeSettings" onClick="toggleSettings()"></div> <div id="settings"> <div class="settingsHeader">Settings</div> <div class="settingsContent"> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div>Guitar Tuning</div> </div> <div class="settingSubDescription"> Choose a common tuning from the dropdown or adjust each string's pitch manually with the sliders. </div> </div> <select id="settingsCommonTunings"> <option value="40 45 50 55 59 64">Standard (E A D G B E)</option> <option value="38 45 50 55 59 64">Drop D (D A D G B E)</option> <option value="38 45 50 55 57 62">DADGAD (D A D G A D)</option> <option value="38 43 50 55 59 62">Open G (D G D G B D)</option> <option value="38 45 50 54 57 62">Open D (D A D F# A D)</option> <option value="40 47 52 56 59 64">Open E (E B E G# B E)</option> <option value="36 43 48 55 60 64">Open C (C G C G C E)</option> <option value="38 45 50 55 59 62">Double Drop D (D A D G B D)</option> <option value="">Custom</option> </select> <div class="settingsStringTuning"> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue6">A</div> <input class="settingsStringSlider string6" id="settingsString6" type="range" min="59" max="70" value="64"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue5">A</div> <input class="settingsStringSlider string5" id="settingsString5" type="range" min="54" max="65" value="59"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue4">A</div> <input class="settingsStringSlider string4" id="settingsString4" type="range" min="50" max="61" value="55"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue3">A</div> <input class="settingsStringSlider string3" id="settingsString3" type="range" min="45" max="56" value="50"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue2">A</div> <input class="settingsStringSlider string2" id="settingsString2" type="range" min="40" max="51" value="45"> </div> <div class="settingsStringWrapper"> <div class="settingsStringValue" id="settingsStringValue1">A</div> <input class="settingsStringSlider string1" id="settingsString1" type="range" min="35" max="46" value="40"> </div> </div> </div> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div>Maximum Frets</div> </div> <div class="settingSubDescription"> Set the maximum number of frets a chord can span. </div> </div> <div class="settingsFretWrapper"> <div class="settingsFretSliderWrapper"> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar selected">1</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">2</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">3</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">4</div> <div class="settingsFretBarSeparator"></div> <div class="settingsFretBar ">5</div> <div class="settingsFretBarSeparator"></div> </div> <div id="settingsFretValue">4 Frets</div> </div> </div> </div> <div id="settingsFooter"> <div id="settingsAdvancedButton" onclick="toggleAdvSettings()"> <div>ADVANCED</div><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"> <path d="m620-284 56-56q6-6 6-14t-6-14L540-505q4-11 6-22t2-25q0-57-40.5-97.5T410-690q-11 0-21 1t-20 5q-9 4-11 14t5 17l74 74-56 56-74-74q-7-7-17-5t-14 11q-3 10-4.5 20t-1.5 21q0 57 40.5 97.5T408-412q13 0 24.5-2t22.5-6l137 136q6 6 14 6t14-6ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" /> </svg> </div> <div onClick="toggleSettings()"><svg xmlns="http://www.w3.org/2000/svg" class=" visualIcon" height="48px" viewBox="0 -960 960 960" width="48px" fill="currentColor"> <path d="m378-332 363-363q9.27-9 21.64-9 12.36 0 21.36 9.05 9 9.06 9 21.5 0 12.45-9 21.45L399-267q-9 9-21 9t-21-9L175-449q-9-9.07-8.5-21.53.5-12.47 9.55-21.47 9.06-9 21.5-9 12.45 0 21.45 9l159 160Z" /> </svg></div> </div> <div id="settingsAdvanced" class=""> <div class="settingsHeader">Advanced Settings</div> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div>Muted Strings Permutation</div> </div> <div class="settingSubDescription"> When this setting is enabled, the chord generator will consider every possible configuration of muted strings, even if some strings could be played.<br>If disabled, the chord generator avoids unnecessarily muting strings. </div> </div> <div class="checkbocWrapper"> <input id="settingsmutePermutations" type="checkbox" /><label for="settingsmutePermutations"></label> </div> </div> <div class="settingsItem"> <div class="settingsInfo"> <div class="settingsSubHeader"> <div> Start with Root </div> </div> <div class="settingSubDescription"> If enabled, the lowest note of a chord will always be the root note.<br>If disabled, chords can start with any note that is part of the chord. </div> </div> <div class="checkbocWrapper"> <input id="settingsStartWithRoot" type="checkbox" /><label for="settingsStartWithRoot"></label> </div> </div> </div> </div> <div class="header"> <div class="mainHeader"> PianoToGuitar.com<div class="versionDescription">ALPHA<div class="versionInformation">Last Update: {{BUILD_DATE}}</div> </div> </div> <div class="settingsWrapper"><div class="settingsWrapperText">SETTINGS</div> <svg class="visualIcon" id="settingsIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleSettings()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m370-80-16-128q-13-5-24.5-12T307-235l-119 50L78-375l103-78q-1-7-1-13.5v-27q0-6.5 1-13.5L78-585l110-190 119 50q11-8 23-15t24-12l16-128h220l16 128q13 5 24.5 12t22.5 15l119-50 110 190-103 78q1 7 1 13.5v27q0 6.5-2 13.5l103 78-110 190-118-50q-11 8-23 15t-24 12L590-80H370Zm112-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z" /> </svg> </div> </div> <div class="searchContainer"> <div class="visualPianoContainer"> <div class="pianoMIDIWrapper"> <div class="pianoContainer"></div> <div id="MIDIStatusDiv"> Initializing MIDI... </div> </div> <div class="pianoIconContainer"> <svg class="visualIcon" id="volumeIcon" xmlns="http://www.w3.org/2000/svg" onclick="toggleVolume()" height="24" viewBox="0 -960 960 960" width="24"> <path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z" /> </svg> <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="playPiano()" height="24" viewBox="0 -960 960 960" width="24"> <path d="m380-300 280-180-280-180v360ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" /> </svg> <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearPiano()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> <div class="searchWordContainer"> <div class="blackFadeBottom"></div> <input class="searchBox" type="text" id="itemSearch" placeholder="Search chords by name..."> <div class="searchChordList" id="itemsContainer"> <!-- Items will be populated here by JavaScript --> </div> </div> </div> <div class="selectedItemsHeading"> <div class="selectedItemsHeaderText">Your Selected Progression</div> <div id="scaleDisplay"></div> </div> <div class="selectedItemsWrapper"> <div class="selectedItems" id="selectedItems"> <!-- Dragged items will appear here --> </div> <svg class="visualIcon" xmlns="http://www.w3.org/2000/svg" onclick="clearProgression()" height="24" viewBox="0 -960 960 960" width="24"> <path fill="currentColor" d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm80-160h80v-360h-80v360Zm160 0h80v-360h-80v360Z" /> </svg> </div> </div> <div class="outputWrapper" id="outputWrapper"> <div class="progression"> <div class="progressionInfo"> <div class="progressionInfoText"> <div class="progressionInfoTextName"><i>DYNAMIC</i></div> <div class="progressionInfoTextSubtitle">Adjust the slider to transition from simple chords to the most beautifully sounding ones! </div> </div> <div class="soundQualityWrapper"> <input id="soundQualitySlider" type="range" min="0" max="100" value="50"> <div class="soundQualityLables"> <div>EASY</div> <div>BEST SOUND</div> </div> </div> </div> <div class="progressionWrapper" id="dynamicProgressionWrapper"></div> </div> <div class="progression"> <div class="progressionInfo"> <div class="progressionInfoText"> <div class="progressionInfoTextName"><i>EASY</i></div> <div class="progressionInfoTextSubtitle">Get the Easiest transposed Progression </div> <div id="easyProgressionCapo">No Capo</div> </div> </div> <div class="progressionWrapper" id="easyProgressionWrapper"></div> </div> </div> </div> <footer> <div class="footerItem"> <div>PianoToGuitar.com <br> 2024 Lukas Marschhausen </div> </div> <div class="footerItem"> <a href="https://discord.gg/cXVU96cqPm" target="_blank"> <div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 127.14 96.36"> <path fill="#fff" d="M107.7,8.07A105.15,105.15,0,0,0,81.47,0a72.06,72.06,0,0,0-3.36,6.83A97.68,97.68,0,0,0,49,6.83,72.37,72.37,0,0,0,45.64,0,105.89,105.89,0,0,0,19.39,8.09C2.79,32.65-1.71,56.6.54,80.21h0A105.73,105.73,0,0,0,32.71,96.36,77.7,77.7,0,0,0,39.6,85.25a68.42,68.42,0,0,1-10.85-5.18c.91-.66,1.8-1.34,2.66-2a75.57,75.57,0,0,0,64.32,0c.87.71,1.76,1.39,2.66,2a68.68,68.68,0,0,1-10.87,5.19,77,77,0,0,0,6.89,11.1A105.25,105.25,0,0,0,126.6,80.22h0C129.24,52.84,122.09,29.11,107.7,8.07ZM42.45,65.69C36.18,65.69,31,60,31,53s5-12.74,11.43-12.74S54,46,53.89,53,48.84,65.69,42.45,65.69Zm42.24,0C78.41,65.69,73.25,60,73.25,53s5-12.74,11.44-12.74S96.23,46,96.12,53,91.08,65.69,84.69,65.69Z" /> </svg></div> </a> <div>Share your suggestions on Discord!</div> </div> </footer> </body> </html>

File: index.js
Path: index.js

import DragAndDropList from './drag-drop/script.js'; import Piano from './piano/script.js'; import { Chord, ChordLibrary } from "./chord-library/script.js" import MIDIAccessManager from "./midi-integration/script.js" import { ProgressionGenerator } from './progression-generator/main.js'; import { settings } from './chord-factory/constants.js'; import { noteToNumber, numberToNote } from "./chord-factory/utils.js"; document.addEventListener('DOMContentLoaded', () => { function debounce(func, wait) { let timeout; return function () { const context = this, args = arguments; clearTimeout(timeout); timeout = setTimeout(() => { func.apply(context, args); }, wait); }; } // Import the MidiManager const midiManager = new MIDIAccessManager(); var visualPianoOctaves = 3 // Function to calculate the number of octaves based on screen width function calculateOctaves() { const screenWidth = window.innerWidth; const maxOctaves = 3; // Base octaves to start with const extraOctaves = Math.ceil((Math.sqrt(screenWidth)) / 25); visualPianoOctaves = Math.min(maxOctaves, extraOctaves) return visualPianoOctaves; } // Create a new Piano instance with dynamic number of octaves const myPiano = new Piano(__PRESERVED__8__, { octaves: calculateOctaves() }); // Get All Chords From the Libaray const chordLibrary = new ChordLibrary // Create the Search and Drag and Drop const allChordLibraryItems = chordLibrary.getAllChords() const dropzone = __PRESERVED__9__; const itemsContainer = __PRESERVED__10__; const itemSearch = __PRESERVED__11__; const selectedItems = __PRESERVED__12__; const emptyMessageContainer = __PRESERVED__13__; const dragAndDropList = new DragAndDropList(allChordLibraryItems, dropzone, itemsContainer, itemSearch, selectedItems, emptyMessageContainer); var isVolumeOn = localStorage.getItem(__PRESERVED__14__) == __PRESERVED__15__ ? false : true; const volumeIcon = document.getElementById(__PRESERVED__16__); updateVolumeIcon(); // Update the icon at load window.toggleVolume = function () { if (isVolumeOn) { myPiano.volumeOff(); // Turn volume off isVolumeOn = false; localStorage.setItem(__PRESERVED__17__, __PRESERVED__18__); } else { myPiano.volumeOn(); // Turn volume on isVolumeOn = true; localStorage.setItem(__PRESERVED__19__, __PRESERVED__20__); } updateVolumeIcon(); }; function updateVolumeIcon() { if (!isVolumeOn) { myPiano.volumeOn() volumeIcon.innerHTML = __PRESERVED__21__; } else { myPiano.volumeOff() volumeIcon.innerHTML = __PRESERVED__22__; } } window.playPiano = function () { myPiano.playChord(); console.log(__PRESERVED__23__); }; window.clearPiano = function () { document.getElementById(__PRESERVED__24__).value = __PRESERVED__25__ myPiano.clearPiano(); console.log(__PRESERVED__26__); }; window.clearProgression = function () { dragAndDropList.clearSelectedList(); console.log(__PRESERVED__27__); }; // Handle window resize to adjust the number of octaves dynamically window.onresize = function () { const newOctaves = calculateOctaves(); myPiano.setOctaves(newOctaves); // Assuming there's a method to update the octaves dynamically }; document.querySelector('.pianoContainer').addEventListener('notesChanged', async (e) => { let items if (e.detail.notes.length > 0) { console.log("Reviced notesChanged Event: " + e.detail.notes + " Root: " + e.detail.rootNote) items = await chordLibrary.searchChords(e.detail.notes, e.detail.rootNote, 50) } else { items = allChordLibraryItems } //dragAndDropList.ceateAndInsertElement(e.detail.notes) dragAndDropList.updateItems(items) // Additional logic to handle the change in notes }); //Midi Integration for Pinao Notes let actualPressedKeys = new Map(); // Maps actual notes to their counts let visualPressedKeys = new Set(); function mapNoteToVisualKey(note) { return note % (visualPianoOctaves * 12); } window.addEventListener('noteOn', (e) => { const { note } = e.detail; const visualKey = mapNoteToVisualKey(note); let count = actualPressedKeys.get(note) || 0; actualPressedKeys.set(note, count + 1); visualPressedKeys.add(visualKey); myPiano.activateKey(visualKey); updateRootNote(); }); window.addEventListener('noteOff', (e) => { const { note } = e.detail; if (actualPressedKeys.has(note)) { let count = actualPressedKeys.get(note); if (count > 1) { actualPressedKeys.set(note, count - 1); } else { actualPressedKeys.delete(note); // Check if any other actual key maps to the same visual key const anyOther = [...actualPressedKeys.keys()].some(k => mapNoteToVisualKey(k) === mapNoteToVisualKey(note)); if (!anyOther) { visualPressedKeys.delete(mapNoteToVisualKey(note)); myPiano.deactivateKey(mapNoteToVisualKey(note)); } } } updateRootNote(); }); function updateRootNote() { if (actualPressedKeys.size > 0) { // Convert actualPressedKeys to an array and sort it const sortedNotes = Array.from(actualPressedKeys.keys()).sort((a, b) => a - b); // Determine if the lowest note should be set as the root note const lowestNote = sortedNotes[0]; const lowestNoteMod12 = lowestNote % 12; let setRoot = false; // Check if the lowest note is doubled in higher octaves if (sortedNotes.some(note => note !== lowestNote && note % 12 === lowestNoteMod12)) { setRoot = true; } // Check if the lowest note is 12 interval steps away from the second lowest note if (sortedNotes.length > 1 && (sortedNotes[1] - lowestNote >= 6)) { setRoot = true; } // Set or clear the root note based on the above conditions if (setRoot) { const visualKey = mapNoteToVisualKey(lowestNote); myPiano.setRootNote(visualKey); } else { myPiano.clearRootNote(); } } else { myPiano.clearRootNote(); } } window.addEventListener("statusUpdated", async (e) => { document.getElementById("MIDIStatusDiv").innerHTML = e.detail }) //Functionality to autom,atically add Chord when played by midi: window.addEventListener('notesOutput', async (e) => { const notes = e.detail; if (notes.length > 0) { const rootNote = Math.min(...notes); const searchResults = await chordLibrary.searchChords(notes, rootNote, 100); if (searchResults.length > 0) { const chord = searchResults[0]; dragAndDropList.addSelectedItem(chord); //popUp.open("Added: " +chord.name, { autoClose: true, duration: 1000 }); } } }); //Scale Detector Listener const scaleDisplay = document.getElementById("scaleDisplay") window.addEventListener('scaleDetected', async function (event) { scaleDisplay.innerHTML = event.detail.scale }); let soundQualityValue = 1; let progressionGenerator = new ProgressionGenerator([], true, chordLibrary, "#ffffff", "onNote", true) document.addEventListener('selectedItemsUpdated', async function (event) { console.log('Updated Selected Items:', event.detail.selectedItems); await progressionGenerator.setProgression(event.detail.selectedItems) await updateProgressionDynamic(soundQualityValue) await updateProgressionEasy() }); const soundQualitySlider = document.getElementById("soundQualitySlider"); soundQualitySlider.addEventListener('input', async (e) => { soundQualityValue = e.target.value / 100; console.log("Slider Value:", soundQualityValue, progressionGenerator); await updateProgressionDynamic(soundQualityValue) }); async function updateProgressionDynamic(soundQualityValue) { let progressionHTML = await progressionGenerator.getProgressionDynamicHTML(soundQualityValue); document.getElementById("dynamicProgressionWrapper").innerHTML = ""; document.getElementById("dynamicProgressionWrapper").appendChild(progressionHTML); }; async function updateProgressionEasy() { let [progressionHTML, capo] = await progressionGenerator.getProgressionEasyHTML(); document.getElementById("easyProgressionWrapper").innerHTML = ""; document.getElementById("easyProgressionWrapper").appendChild(progressionHTML); document.getElementById("easyProgressionCapo").innerHTML = "Capo: " + capo + "fr"; }; //ADVANCED SETTINGS window.toggleAdvSettings = async function () { let advSettingsScreen = document.getElementById("settingsAdvanced"); let advSettingsButton = document.getElementById("settingsAdvancedButton"); advSettingsScreen.classList.toggle("visible") } let reloadFlag = false; // Make Settings Button functional window.toggleSettings = async function () { let settingsScreen = document.getElementById("settings"); let closeSettings = document.getElementById("closeSettings"); let advSettingsScreen = document.getElementById("settingsAdvanced"); console.log("Toggle Settings clicked"); // If the main settings are being closed, also close the advanced settings if (settingsScreen.classList.contains('visible') && advSettingsScreen.classList.contains('visible')) { advSettingsScreen.classList.remove('visible'); } // Toggle a class that controls the visibility and opacity settingsScreen.classList.toggle('visible'); closeSettings.classList.toggle('visible'); console.log("Settings screen visibility toggled:", settingsScreen.classList.contains('visible')); if (reloadFlag) { console.log("Reload flag is true, updating tuning settings."); localStorage.setItem('guitarTuning', JSON.stringify(settings.tuning)); console.log("New tuning saved to localStorage:", settings.tuning); progressionGenerator.reloadProgression(); console.log("Progression reloaded."); updateProgressionDynamic(soundQualityValue); console.log("Progression dynamic updated."); updateProgressionEasy(); console.log("Progression easy updated."); reloadFlag = false; } }; // Function to load tuning settings into the select elements function loadTuningSettings() { console.log("Loading tuning settings..."); if (localStorage.getItem('guitarTuning')) { settings.tuning = JSON.parse(localStorage.getItem('guitarTuning')); console.log("Stored tuning from localStorage:", settings.tuning); } settings.tuning.forEach((element, index) => { const selectElement = document.getElementById(`settingsString${index + 1}`); const displayElement = document.getElementById(`settingsStringValue${index + 1}`); displayElement.innerHTML = numberToNote(element); selectElement.value = element }); } // Add event listeners to the select elements for (let i = 0; i < 6; i++) { let selectElement = document.getElementById("settingsString" + (i + 1)); if (selectElement) { selectElement.addEventListener('input', () => { let displayElement = document.getElementById(`settingsStringValue${i + 1}`); displayElement.innerHTML = numberToNote(parseInt(selectElement.value)); document.getElementById('settingsCommonTunings').value = "" settings.tuning[i] = parseInt(selectElement.value); // Ensure parsing as integer reloadFlag = true; console.log(`String ${i + 1} tuning changed to:`, settings.tuning[i]); checkCommonTunings(); // Check if current tuning matches a common tuning }); console.log(`Event listener added for string ${i + 1}`); } else { console.warn(`Element with ID settingsString${i + 1} not found.`); } } function setTuning(tuning) { const tuningArray = tuning.split(' ').map(Number); settings.tuning = tuningArray; tuningArray.forEach((value, index) => { const selectElement = document.getElementById(`settingsString${index + 1}`); const displayElement = document.getElementById(`settingsStringValue${index + 1}`); selectElement.value = value; displayElement.innerHTML = numberToNote(value); }); reloadFlag = true; console.log("Tuning set to:", tuningArray); checkCommonTunings(); // Check if the new tuning matches a common tuning } // Add event listener to dropdown document.getElementById('settingsCommonTunings').addEventListener('change', function () { if (this.value) { setTuning(this.value); } }); // Function to compare current tuning with common tunings function checkCommonTunings() { const dropdown = document.getElementById('settingsCommonTunings'); const currentTuning = settings.tuning.join(' '); let found = false; for (let i = 0; i < dropdown.options.length; i++) { if (dropdown.options[i].value === currentTuning) { dropdown.value = currentTuning; found = true; break; } } if (!found) { dropdown.value = ""; } } //FretRange // Function to set fret range function setFretRange(fret) { // Update the fret range display const fretValueDisplay = document.getElementById('settingsFretValue'); fretValueDisplay.textContent = `${fret} Frets`; // Update the settings.fretRange settings.fingerFretRange = fret; // Set the reloadFlag to true reloadFlag = true; // Update the localStorage localStorage.setItem('fretRange', fret); // Update the selected fret bar const fretBars = document.querySelectorAll('.settingsFretBar'); fretBars.forEach((bar, index) => { if (index < fret) { bar.classList.add('selected'); bar.setAttribute('data-fret', index + 1); // Set data attribute for the selected fret } else { bar.classList.remove('selected'); bar.removeAttribute('data-fret'); // Remove data attribute for unselected frets } bar.textContent = index + 1; }); console.log(`Fret range set to: ${fret} frets`); } // Add event listeners to the fret bars const fretBars = document.querySelectorAll('.settingsFretBar'); fretBars.forEach((bar, index) => { bar.addEventListener('click', () => { setFretRange(index + 1); }); console.log(`Event listener added for fret ${index + 1}`); }); // Load the fret range setting from localStorage function loadFretRangeSetting() { console.log("Loading fret range setting..."); if (localStorage.getItem('fretRange')) { const storedFretRange = parseInt(localStorage.getItem('fretRange')); setFretRange(storedFretRange); console.log("Stored fret range from localStorage:", storedFretRange); } else { setFretRange(settings.fingerFretRange) } } //ADVANCED //settingsmutePermutations document.getElementById('settingsmutePermutations').addEventListener('change', function () { settings.mutePermutations = this.checked; localStorage.setItem('mutePermutations', this.checked); reloadFlag = true; // Ensure the progression is updated console.log(`Only mute if necessary set to: ${this.checked}`); }); function loadMuteSetting() { console.log("Loading mute setting..."); if (localStorage.getItem('mutePermutations') !== null) { const storedMuteSetting = JSON.parse(localStorage.getItem('mutePermutations')); settings.mutePermutations = storedMuteSetting; document.getElementById('settingsmutePermutations').checked = storedMuteSetting; console.log("Stored mute setting from localStorage:", storedMuteSetting); } else { settings.mutePermutations = false; // Default value document.getElementById('settingsmutePermutations').checked = false; } } //startWithRoot document.getElementById('settingsStartWithRoot').addEventListener('change', function () { settings.startWithRoot = this.checked; localStorage.setItem('startWithRoot', this.checked); reloadFlag = true; // Ensure the progression is updated console.log(`Start with root set to: ${this.checked}`); }); function loadRootSetting() { console.log("Loading root setting..."); if (localStorage.getItem('startWithRoot') !== null) { const storedRootSetting = JSON.parse(localStorage.getItem('startWithRoot')); settings.startWithRoot = storedRootSetting; document.getElementById('settingsStartWithRoot').checked = storedRootSetting; console.log("Stored root setting from localStorage:", storedRootSetting); } else { settings.startWithRoot = true; // Default value document.getElementById('settingsStartWithRoot').checked = true; } } loadFretRangeSetting(); loadTuningSettings(); loadMuteSetting(); loadRootSetting() checkCommonTunings(); updateProgressionDynamic(soundQualityValue); updateProgressionEasy(); })

File: index.html
Path: midi-integration\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>MIDI Note Logger</title> </head> <body> <h1>MIDI Note Logger</h1> <div id="status">Waiting for MIDI...</div> <div id="log"></div> <script src="script.js"></script> </body> </html>

File: script.js
Path: midi-integration\script.js

export class MIDIAccessManager { constructor() { this.retryCount = 0; this.maxRetries = 50; this.notesPlayed = new Set(); this.activeNotes = new Set(); if (navigator.requestMIDIAccess) { this.attemptMIDIAccess(); } else { console.log("Web MIDI API not supported!"); } } attemptMIDIAccess() { navigator.requestMIDIAccess() .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this)) .catch(err => { console.error('Error accessing MIDI devices:', err); this.handleRetry(err); }); } onMIDISuccess(midiAccess) { this.updateStatus("MIDI ready..."); this.midiAccess = midiAccess; // Store midiAccess for later use midiAccess.onstatechange = this.updateDeviceState.bind(this); this.addMIDIInputs(midiAccess.inputs); } addMIDIInputs(inputs) { Array.from(inputs.values()).forEach(input => input.onmidimessage = this.onMIDIMessage.bind(this)); } onMIDIFailure() { this.updateStatus(__PRESERVED__3__); this.handleRetry(new Error(__PRESERVED__4__)); } handleRetry(err) { if (this.retryCount < this.maxRetries) { this.retryCount++; console.log(__PRESERVED__5__); setTimeout(() => this.attemptMIDIAccess(), 3000); // Retry after 3 seconds } else { console.error(__PRESERVED__6__); //No Midi Device Found this.updateStatus(__PRESERVED__7__); } } onMIDIMessage({ data: [command, note, velocity] }) { const eventDetail = { command, note, velocity }; if (command === 144 && velocity > 0) { if (this.activeNotes.size === 0) { // New session this.notesPlayed.clear(); } this.notesPlayed.add(note); this.activeNotes.add(note); window.dispatchEvent(new CustomEvent('noteOn', { detail: eventDetail })); } else if (command === 128 || velocity === 0) { this.activeNotes.delete(note); window.dispatchEvent(new CustomEvent('noteOff', { detail: eventDetail })); if (this.activeNotes.size === 0 && this.notesPlayed.size > 0) { this.outputNotes(); this.notesPlayed.clear(); } } } outputNotes() { const uniqueNotes = Array.from(this.notesPlayed); if (uniqueNotes.length > 0) { console.log(uniqueNotes); window.dispatchEvent(new CustomEvent('notesOutput', { detail: uniqueNotes })); } } updateStatus(message) { window.dispatchEvent(new CustomEvent('statusUpdated', { detail: message })); } updateDeviceState({ port }) { const status = `MIDI: ${port.name} ${port.state}`; this.updateStatus(status); window.dispatchEvent(new CustomEvent('deviceStateChanged', { detail: { name: port.name, state: port.state } })); if (port.state === "disconnected" || port.state === "unavailable") { this.handleDisconnection(); } } handleDisconnection() { console.log("MIDI device disconnected. Attempting to reconnect..."); this.attemptMIDIAccess(); } } export default MIDIAccessManager;

File: script.js
Path: piano\script.js

class Piano { constructor(containerSelector, options = {}) { this.container = document.querySelector(containerSelector); this.updatePlayedNotesDebounced = this.debounce(this.updatePlayedNotes, 50); this.octaves = options.octaves || 2; this.playedNotes = []; this.rootNote = null; // Add a property for the root note this.lastClickTime = 0; this.clickDelay = 300; // 300 milliseconds delay this.layout = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; this.keysPerOctave = this.layout.length; this.whiteKeyCount = this.layout.filter(x => x === 0).length; this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves); this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234; this.blackKeyHeight = 0.63; this.totalKeys = this.octaves * this.keysPerOctave; this.audioElements = []; this.volume = true this.globalVolume = 0.7; // Global volume set to maximum by default this.createPiano(); this.addKeyListeners(); } volumeOff() { this.volume = false this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; }); } volumeOn() { this.volume = true } updateVolume() { const activeCount = this.playedNotes.length; const volume = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1; this.audioElements.forEach(audio => { if (!audio.paused) { // Only update audio elements that are currently playing audio.volume = volume; } }); } createPiano() { this.container.innerHTML = __PRESERVED__0__; // Clear existing piano keys let whiteCounter = 0; for (let index = 0; index < this.totalKeys; index++) { let key = document.createElement(__PRESERVED__1__); key.setAttribute(__PRESERVED__2__, index); if (this.layout[index % this.keysPerOctave] === 1) { key.classList.add(__PRESERVED__3__, __PRESERVED__4__); key.style.left = __PRESERVED__5__; key.style.width = __PRESERVED__6__; key.style.height = __PRESERVED__7__; key.style.boxSizing = __PRESERVED__8__; key.style.position = __PRESERVED__9__; } else { key.classList.add(__PRESERVED__10__, __PRESERVED__11__); key.style.boxSizing = __PRESERVED__12__; key.style.width = __PRESERVED__13__; whiteCounter++; } this.container.appendChild(key); this.audioElements[index] = new Audio(__PRESERVED__14__); this.audioElements[index].preload = __PRESERVED__15__; // This tells the browser to load the audio as soon as the page is loaded } } addKeyListeners() { this.container.querySelectorAll(__PRESERVED__16__).forEach(key => { key.addEventListener(__PRESERVED__17__, () => { //console.log(__PRESERVED__18__) let currentTime = Date.now(); const note = key.getAttribute(__PRESERVED__19__); if (this.rootNote === note) { key.classList.add(__PRESERVED__20__); key.classList.remove(__PRESERVED__21__); if (currentTime - this.lastClickTime > 200) { this.lastClickTime = currentTime; //console.log(__PRESERVED__22__+currentTime) } this.rootNote = null; } else if (this.playedNotes.includes(note) && (currentTime - this.lastClickTime > 300)) { this.playedNotes = this.playedNotes.filter(n => n !== note); key.classList.remove(__PRESERVED__23__); } else { if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); } key.classList.add(__PRESERVED__24__); this.playSoundLong(note, 0.75); } this.updatePlayedNotesDebounced(); }); key.addEventListener(__PRESERVED__25__, (event) => { //console.log(__PRESERVED__26__) const note = key.getAttribute(__PRESERVED__27__); if (this.rootNote === note) { key.classList.add(__PRESERVED__28__); key.classList.remove(__PRESERVED__29__); this.rootNote = null; } else { if (this.rootNote !== null) { this.container.querySelector(__PRESERVED__30__).classList.remove(__PRESERVED__31__); } let currentTime = Date.now(); if (currentTime - this.lastClickTime < 500) { } else { this.rootNote = note; if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); } key.classList.add(__PRESERVED__32__, __PRESERVED__33__); } } this.updatePlayedNotesDebounced(); }); }); } debounce(func, delay) { let timeoutId; return function (...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => { func.apply(this, args); }, delay); }; } playSoundLong(index, localVolume) { if (this.volume) { const audio = this.audioElements[index]; audio.volume = localVolume * this.globalVolume; // Apply global volume scaling if (!audio.paused) { audio.currentTime = 0; // Reset if it is already playing } audio.play(); } } playChord() { this.playedNotes.sort((a, b) => a - b); const localVolume = 1 / Math.sqrt(this.playedNotes.length / 1); this.playedNotes.forEach((note, index) => { const randomDelay = Math.random() * 20; setTimeout(() => { this.playSoundLong(note, localVolume); }, 20 * index + randomDelay); }); } activateKey(index) { const key = this.container.querySelector(__PRESERVED__34__); if (!key.classList.contains(__PRESERVED__35__)) { key.classList.add(__PRESERVED__36__); this.playedNotes.push(index); this.updatePlayedNotesDebounced(); this.updateVolume(); // Adjust volume based on the new number of active notes } this.playSoundLong(index, 0.75); // Initial play sound with default volume } deactivateKey(index) { const key = this.container.querySelector(__PRESERVED__37__); if (key.classList.contains(__PRESERVED__38__)) { key.classList.remove(__PRESERVED__39__); this.playedNotes = this.playedNotes.filter(n => n !== index); this.updatePlayedNotesDebounced(); // Do not update volume here to keep it consistent with the number of keys pressed } } setRootNote(note) { const key = this.container.querySelector(__PRESERVED__40__); if (this.rootNote !== null) { // Remove rootNote class from the old root note this.container.querySelector(__PRESERVED__41__).classList.remove(__PRESERVED__42__); } this.rootNote = note; // Update the rootNote to the new note key.classList.add(__PRESERVED__43__, __PRESERVED__44__); // Add rootNote class to new root note if (!this.playedNotes.includes(note)) { this.playedNotes.push(note); // Add root note to playedNotes if it__PRESERVED__45__rootNote__PRESERVED__46__notesChanged__PRESERVED__47__.key.selectedKey__PRESERVED__48__.key.rootNote').forEach(key => { key.classList.remove(__PRESERVED__49__); }); this.audioElements.forEach(audio => { audio.pause(); audio.currentTime = 0; }); this.updatePlayedNotes(); } setOctaves(newOctaves) { if (newOctaves !== this.octaves) { this.octaves = newOctaves; this.totalKeys = this.octaves * this.keysPerOctave; this.whiteKeyWidth = 100 / (this.whiteKeyCount * this.octaves); this.blackKeyWidth = this.whiteKeyWidth * 0.5829787234; this.clearPiano(); this.createPiano(); this.addKeyListeners(); } } } export default Piano;

File: main.js
Path: progression-generator\main.js

import { settings } from '../chord-factory/constants.js'; import { ChordFactory } from '../chord-factory/chordfactory.js'; import { Chord } from '../chord-library/script.js'; import { numberToNote } from '../chord-factory/utils.js'; import { TabHTML } from './tabhtml.js'; class ChordFactoryManager { constructor(useRoot) { this.chordFactoryMap = {}; this.useRoot = useRoot; } getChordFactory(chord, key) { if (!this.chordFactoryMap[key]) { this.chordFactoryMap[key] = {}; } if (this.chordFactoryMap[key][chord.name]) { console.log(`ChordFactory retrieved for: ${chord.name} in key: ${key}`); return this.chordFactoryMap[key][chord.name]; } else { const chordFactory = new ChordFactory(chord, this.useRoot, settings.tuning); this.chordFactoryMap[key][chord.name] = chordFactory; console.log(`New ChordFactory created for: ${chord.name} in key: ${key}`); return chordFactory; } } } export class ProgressionGenerator { constructor(initialProgression = [], useRoot = true, chordLibrary, color, fingerNumbers = "belowString", showOpenStrings = true) { this.color = color; this.fingerNumbers = fingerNumbers; this.showOpenStrings = showOpenStrings; this.progression = []; this.progressionChords = []; this.useRoot = useRoot; // This flag determines if the root note should be the starting note this.keyAnalysis = [] this.chordLibrary = chordLibrary // Initialize ChordFactoryManager this.chordFactoryManager = new ChordFactoryManager(this.useRoot); // Call the asynchronous initialization function this.initialize(initialProgression); } async initialize(initialProgression) { this.setProgression(initialProgression); this.easiestChords = await this.getEasiestChords(); } addKeyAnalysis(root, keyscale, prob) { // Push a new object to the array with the analysis data this.keyAnalysis.push({ rootNote: root, scale: keyscale, probability: prob }); } analyzeKey() { this.keyAnalysis = [] //Define Possible Scales //Higher Prioroty means They get artifically boostes at the Raking const scaleStructures = { __PRESERVED__8__: { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], priority: 0.01 }, // Major Scale: C, D, E, F, G, A, B __PRESERVED__9__: { notes: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0.01 }, // Natural Minor Scale: A, B, C, D, E, F, G __PRESERVED__10__: { notes: [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0], priority: 0 }, // Minor Pentatonic Scale: A, C, D, E, G __PRESERVED__11__: { notes: [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], priority: 0 }, // Major Pentatonic Scale: C, D, E, G, A __PRESERVED__12__: { notes: [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], priority: 0 }, // Harmonic Minor Scale: A, B, C, D, E, F, G# __PRESERVED__13__: { notes: [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], priority: 0 }, // Blues Scale: A, C, D, D#, E, G __PRESERVED__14__: { notes: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], priority: 0 }, // Mixolydian Mode: G, A, B, C, D, E, F __PRESERVED__15__: { notes: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], priority: 0 }, // Dorian Mode: D, E, F, G, A, B, C __PRESERVED__16__: { notes: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], priority: 0 }, // Phrygian Mode: E, F, G, A, B, C, D __PRESERVED__17__: { notes: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], priority: 0 }, // Lydian Mode: F, G, A, B, C, D, E __PRESERVED__18__: { notes: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0], priority: 0 } // Locrian Mode: B, C, D, E, F, G, A }; //Generate an Array of Notes and How often They are present let notesSet = Array(12).fill(0); this.progression.forEach(element => { element.notes.forEach(note => { notesSet[note]++ }) }) console.log(__PRESERVED__19__, notesSet) //Now GO through The NoteSet and Calucalte A Number for The Probability of the Key notesSet.forEach((scopeNote, index) => { //Only Look at occuring Notes if (scopeNote != 0) { //Loop Through the scaleStrucurtres and the notes array Object.keys(scaleStructures).forEach(key => { let ammountWeight = 0.01 let rootWeight = 0.01 //DO NOT CHANGE let distanceToRootWeight = 1 let keyProbability = 0 for (let relativeNote = 0; relativeNote < 11; relativeNote++) { if ((notesSet[(relativeNote + index) % 12] > 0) && ((scaleStructures[key].notes[relativeNote]) > 0)) { keyProbability += (1 + (notesSet[(relativeNote + index) % 12]) * ammountWeight) * (1 / (distanceToRootWeight)) distanceToRootWeight += rootWeight } } this.addKeyAnalysis(index, key, keyProbability + scaleStructures[key].priority) }) } }) this.keyAnalysis = this.keyAnalysis.sort((a, b) => b.probability - a.probability); return } // Set initial progression with ChordFactory instances for each chord async setProgression(initialProgression) { if (!initialProgression) { return; } this.progressionChords = initialProgression; // Populate this.progression with ChordFactory instances this.progression = initialProgression.map(chord => { if (chord instanceof Chord) { return this.chordFactoryManager.getChordFactory(chord, __PRESERVED__20__); } else { console.error(__PRESERVED__21__); return null; } }).filter(chordFactory => chordFactory !== null); // Populate this.progression with references from the new map if (this.progression.length > 1) { this.analyzeKey() console.log(__PRESERVED__22__, this.keyAnalysis) const event = new CustomEvent(__PRESERVED__23__, { detail: { scale: __PRESERVED__24__ + numberToNote(this.keyAnalysis[0].rootNote) + __PRESERVED__25__ + this.keyAnalysis[0].scale + __PRESERVED__26__ } }); console.log(__PRESERVED__27__ + numberToNote(this.keyAnalysis[0].rootNote) + __PRESERVED__28__ + this.keyAnalysis[0].scale) window.dispatchEvent(event); } else { const event = new CustomEvent(__PRESERVED__29__, { detail: { scale: __PRESERVED__30__ } }); console.log(__PRESERVED__31__) window.dispatchEvent(event); } } async reloadProgression() { this.tuning = settings.tuning; this.chordFactoryManager = new ChordFactoryManager(this.useRoot); this.progression = []; this.initialize(this.progressionChords); console.log(__PRESERVED__32__); } getPlaceholderHTML() { let diagramsContainer = document.createElement(__PRESERVED__33__); diagramsContainer.classList.add(__PRESERVED__34__); diagramsContainer.style.opacity = 0.2 let placeholderhtml = new TabHTML().generatePlaceholder(3) placeholderhtml.forEach(element => { diagramsContainer.appendChild(element); }) return diagramsContainer; // Return the container with all placeholder SVGs } async getProgressionDynamicHTML(soundQuality = 0.5, amount = 1) { if (this.progression.length < 1) { return this.getPlaceholderHTML(); } let diagramsContainer = document.createElement(__PRESERVED__35__); diagramsContainer.classList.add(__PRESERVED__36__); this.progression.forEach(chordFactory => { const tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings); const chordDiagrams = tabHTML.generateHTML(soundQuality, amount); chordDiagrams.forEach(element => { diagramsContainer.appendChild(element); }); }); return diagramsContainer; } async getProgressionEasyHTML() { if (this.progression.length < 1) { return [this.getPlaceholderHTML(), 0]; } const originalProgression = structuredClone(this.progressionChords); // Make a copy of the progression chords let bestTransposition = 0; let maxOverlap = 0; // Function to transpose a chord by a given number of semitones const transposeChord = (chord, semitones) => { return this.chordLibrary.transposeChord(chord, semitones); }; for (let i = 0; i < 12; i++) { let overlapCount = 0; let transposedProgression = originalProgression.map(chord => transposeChord(chord, i)); transposedProgression.forEach(chord => { this.easiestChords.forEach(easyChord => { if (chord.name == easyChord.name) { overlapCount++; } }); }); if (overlapCount > maxOverlap) { maxOverlap = overlapCount; bestTransposition = i; } } // Transpose the original progression to the best transposition let bestTransposedProgression = originalProgression.map(chord => transposeChord(chord, bestTransposition)); bestTransposedProgression = bestTransposedProgression.map(chord => { if (chord instanceof Chord) { return this.chordFactoryManager.getChordFactory(chord, __PRESERVED__37__); } else { console.error(__PRESERVED__38__); return null; } }); // Generate the HTML for the best transposed progression let diagramsContainer = document.createElement(__PRESERVED__39__); // Container for chord diagrams diagramsContainer.classList.add(__PRESERVED__40__); // Iterate over each ChordFactory instance in the progression bestTransposedProgression.forEach(chordFactory => { // Create an instance of TabHTML for the current chordFactory let tabHTML = new TabHTML(chordFactory, this.color, this.fingerNumbers, this.showOpenStrings); // Generate the HTML for the current chordFactory let chordDiagrams = tabHTML.generateHTML(0, 1); // Append the generated HTML to the main container chordDiagrams.forEach(element => { diagramsContainer.appendChild(element); }); }); // Return the container with all chord diagrams return [diagramsContainer, bestTransposition]; } async getEasiestChords() { const easiestChordsArray = [ [-1, 0, 2, 2, 2, 0], // A major (A) [-1, 0, 2, 2, 1, 0], // A minor (Am) [-1, 0, 2, 0, 1, 0], // A minor 7 (Am7) [-1, 2, 2, 2, 0, 0], // A7 [-1, 0, 2, 0, 1, 3], // A7sus4 [-1, 3, 2, 0, 1, 0], // C major (C) [-1, 3, 2, 0, 1, 0], // C major 7 (Cmaj7) [-1, 3, 2, 2, 1, 3], // C7 [-1, -1, 0, 2, 3, 2], // D major (D) [-1, -1, 0, 2, 1, 2], // D minor (Dm) [3, 2, 0, 0, 0, 3], // G major (G) [3, 2, 0, 0, 3, 3], // G7 [0, 2, 2, 1, 0, 0], // E major (E) [0, 2, 0, 1, 0, 0], // E7 [0, 0, 2, 2, 1, 2], // E minor 7 (Em7) [0, 2, 2, 0, 0, 0], // E minor (Em) [1, 3, 3, 2, 1, 1], // F major (F) [1, 1, 3, 3, 2, 1], // F major 7 (Fmaj7) [1, 1, 3, 3, 3, 1], // F7 ]; let easiestChords = []; let currentChord = new Set(); for (const element of easiestChordsArray) { currentChord = new Set(); for (let i = 0; i < 6; i++) { if (element[i] != -1) { currentChord.add((settings.tuning[i] + element[i]) % 12); } } let root = -1 for (let i = 0; i < 6; i++) { if (element[i] != -1) { root = (settings.tuning[i] + element[i]) % 12 break; } } const foundChords = await this.chordLibrary.searchChords(Array.from(currentChord), root, 100); if (foundChords[0]) { easiestChords.push(foundChords[0]); } } console.log(__PRESERVED__41__, easiestChords) return easiestChords } invertColor(hex) { // Remove the hash at the start if it's there hex = hex.startsWith('#') ? hex.slice(1) : hex; // Convert hex to RGB let r = parseInt(hex.substr(0, 2), 16); let g = parseInt(hex.substr(2, 2), 16); let b = parseInt(hex.substr(4, 2), 16); // Invert each component by subtracting from 255 r = 255 - r; g = 255 - g; b = 255 - b; // Convert the inverted RGB values back to hex return '#' + [r, g, b].map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join(''); } }

File: tabhtml.js
Path: progression-generator\tabhtml.js

import TabGenerator from "../tab-generator/script.js"; import { settings } from "../chord-factory/constants.js"; export class TabHTML { constructor(chordFactory = [], color = "#fff", fingerNumbers = "belowString", showOpenStrings = true) { this.chordFactory = chordFactory; // Pointer to the ChordFactory instance this.color = color; this.fingerNumbers = fingerNumbers; this.showOpenStrings = showOpenStrings; this.currentIndex = 0; // Track the current index of playable chords this.maxChords = chordFactory.playableChords?.length ?? 0; } invertColor(hex) { // Remove the hash at the start if it__PRESERVED__4__#__PRESERVED__5__#__PRESERVED__6__0__PRESERVED__7____PRESERVED__8__vibrate__PRESERVED__9__vibrate__PRESERVED__10__next__PRESERVED__11__slide-out-left__PRESERVED__12__slide-in-right__PRESERVED__13__previous__PRESERVED__14__slide-out-right__PRESERVED__15__slide-in-left__PRESERVED__16__slide-in-left__PRESERVED__17__slide-in-right__PRESERVED__18__slide-out-right__PRESERVED__19__slide-out-left__PRESERVED__20____PRESERVED__21__slide-in-left__PRESERVED__22__slide-in-right__PRESERVED__23__slide-out-right__PRESERVED__24__slide-out-left__PRESERVED__25__ammount__PRESERVED__26__div__PRESERVED__27__div__PRESERVED__28__div__PRESERVED__29__div__PRESERVED__30__<svg xmlns=__PRESERVED__31__ height=__PRESERVED__32__ viewBox=__PRESERVED__33__ ><path fill=__PRESERVED__34__ d=__PRESERVED__35__/></svg>__PRESERVED__36__next__PRESERVED__37__div__PRESERVED__38__<svg xmlns=__PRESERVED__39__ height=__PRESERVED__40__ viewBox=__PRESERVED__41__ ><path fill=__PRESERVED__42__ d=__PRESERVED__43__/></svg>__PRESERVED__44__previous__PRESERVED__45__div__PRESERVED__46__div__PRESERVED__47__div__PRESERVED__48__Error generating chord diagram:__PRESERVED__49__div__PRESERVED__50__div__PRESERVED__51__div__PRESERVED__52__div__PRESERVED__53__div__PRESERVED__54__div__PRESERVED__55__<svg xmlns=__PRESERVED__56__ height=__PRESERVED__57__ viewBox=__PRESERVED__58__ ><path fill=__PRESERVED__59__ d=__PRESERVED__60__/></svg>__PRESERVED__61__div__PRESERVED__62__<svg xmlns=__PRESERVED__63__ height=__PRESERVED__64__ viewBox=__PRESERVED__65__ ><path fill=__PRESERVED__66__ d=__PRESERVED__67__/></svg>__PRESERVED__68__div__PRESERVED__69__div__PRESERVED__70__div'); diagramsContainer.classList.add(__PRESERVED__71__); diagramsContainer.appendChild(svgContainer); diagramsContainer.appendChild(chordInfoContainer); // Pushing it into the diagrams diagrams.push(diagramsContainer); } return diagrams; // Return the container with all SVGs } }

File: index.html
Path: tab-generator\index.html

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Guitar Chord Diagram Generator</title> <link rel="stylesheet" href="styles.css"> </head> <body> <div class="container"> <h1>Guitar Chord Diagram Generator</h1> <input type="text" id="chordInput" placeholder="Enter chord string like 555575" class="chord-input"> <input type="text" id="fingerInput" placeholder="Enter finger positions (e.g., 134211)"> <button onclick="generateChordDiagram()" class="generate-btn">Generate Diagram</button> <div id="diagram" class="diagram-container"></div> </div> <script type="module"> import TabGenerator from "./script.js" const fingerPositions = ['-1', '5', '6', '5', '0', '0']; const fingerNumbers = ['1', '1', '2', '1', '', '']; const barre = 10; const minAboveZero = 15 const barres = [[5,1,3], [3,0,5]] const color = "#fff"; const textColor = "#000"; const showOpenStrings = true; try { const chordDiagram = new TabGenerator(fingerPositions, fingerNumbers, minAboveZero, barres, color, textColor, 'belowString', showOpenStrings); const svg = chordDiagram.generateChordSVG(); document.getElementById('diagram').appendChild(svg); } catch (error) { console.error('Error generating chord diagram:', error); } </script> </body> </html>

File: script.js
Path: tab-generator\script.js

/** * Represents a TabGenerator for creating guitar chord diagrams as SVG elements. * This class allows the configuration of various aspects of the diagram, including finger positions, * barre chords, string and note visualization, and color customization. */ class TabGenerator { /** * Creates an instance of TabGenerator. * @param {Array<number>} fingerPositions - Array representing finger positions on the frets, with 'x' for muted strings and '0' for open strings. * @param {Array<number>} fingerNumbers - Array representing the finger numbers to use on each string. * @param {number} [barreSize=null] - Size of the barre to be drawn across strings, null if no barre is used. * @param {string} [barre=null] - Specific fret where the barre is placed. * @param {string} [elementColor="#000"] - Color for the diagram elements such as strings, frets, and notes. * @param {string} [textColor="#fff"] - Color for the text used in the diagram. * @param {string} [numberPosition='onNote'] - Position of the numbers, 'onNote' to place them on the note, or any other value to place them separately. * @param {boolean} showOpenStrings - Whether to display open strings in the diagram. */ constructor(fingerPositions, fingerNumbers, minAboveZero = 0, barres = [], elementColor = __PRESERVED__6__, textColor = __PRESERVED__7__, numberPosition = __PRESERVED__8__, showOpenStrings) { if (!Array.isArray(fingerPositions) || fingerPositions.length !== 6) { console.error(__PRESERVED__9__); } if (fingerNumbers && (!Array.isArray(fingerNumbers) || fingerNumbers.length !== 6)) { console.error(__PRESERVED__10__); } if (typeof elementColor !== __PRESERVED__11__) { console.error(__PRESERVED__12__); } if (typeof textColor !== __PRESERVED__13__) { console.error(__PRESERVED__14__); } if (numberPosition !== __PRESERVED__15__ && numberPosition !== __PRESERVED__16__) { console.error(__PRESERVED__17__); } if (typeof showOpenStrings !== __PRESERVED__18__) { console.error(__PRESERVED__19__); } // Assign instance variables this.fingerPositions = fingerPositions; this.fingerNumbers = fingerNumbers; this.barres = barres; // Specific fret where the barre is placed this.color = elementColor; // Color for diagram elements this.textColor = textColor; // Color for the text this.numberPosition = numberPosition; // Position of the numbers this.showOpenStrings = showOpenStrings; // Whether to display open strings this.maxFret = Math.max(...fingerPositions) // Diagram layout constants this.topSpacing = 25; this.topBarHeight = 7; this.fretSpacing = 25; this.stringSpacing = 25; this.paddingLeft = 10; this.barreSidesOverflow = 10; this.stringOverflowBotom = 10; this.fretCount = 4; this.circleRadius = 10; this.infoPadding = 10; this.openStringRadius = 7; //Offset this.offset = 1 if (this.maxFret > this.fretCount){ this.offset = minAboveZero } //Global Framw Width this.width = 185; this.height = 145 } generateChordSVG() { const svgAttributes = { width: this.width, height: this.height, viewBox: __PRESERVED__20__ + this.width + __PRESERVED__21__ +this.height // This sets the viewBox attribute }; const svg = this.createSVGElement(__PRESERVED__22__, svgAttributes); this.drawDiagramComponents(svg); return svg; } drawDiagramComponents(svg) { this.drawTopBar(svg); if (this.barres) { this.barres.forEach(element => { this.drawBarre(svg, element[0], element[1], element[2]); }); } this.drawStrings(svg); this.drawFrets(svg); if (this.showOpenStrings) { this.drawOpenStrings(svg); } this.drawNotes(svg); this.drawMuteIndicators(svg); this.drawFretHeight(svg) } createSVGElement(tag, attributes) { const element = document.createElementNS(__PRESERVED__23__, tag); for (const attr in attributes) { element.setAttribute(attr, attributes[attr]); } return element; } drawTopBar(svg) { const topBar = this.createSVGElement(__PRESERVED__24__, { x: this.paddingLeft, y: this.topSpacing, width: this.stringSpacing * 5, height: this.topBarHeight, fill: this.color, stroke: this.color, __PRESERVED__25__: __PRESERVED__26__ }); svg.appendChild(topBar); } drawStrings(svg) { for (let i = 0; i < 6; i++) { const line = this.createSVGElement(__PRESERVED__27__, { x1: this.paddingLeft + i * this.stringSpacing, y1: this.topSpacing, x2: this.paddingLeft + i * this.stringSpacing, y2: this.fretSpacing * this.fretCount + this.topSpacing + this.stringOverflowBotom + this.topBarHeight, stroke: this.color, __PRESERVED__28__: ((6 - i) / 3) + 1 }); svg.appendChild(line); } } drawFrets(svg) { for (let j = 0; j < this.fretCount + 1; j++) { const line = this.createSVGElement('line', { x1: this.paddingLeft, y1: this.topSpacing + j * this.fretSpacing + this.topBarHeight, x2: this.paddingLeft + this.stringSpacing * 5, y2: this.topSpacing + j * this.fretSpacing + this.topBarHeight, stroke: this.color, 'stroke-width': '2' }); svg.appendChild(line); } } drawNotes(svg) { for (let string = 0; string < 6; string++) { if (this.fingerPositions[string] > 0) { let fret = parseInt(this.fingerPositions[string]); if (fret > 0) { let position = this.topSpacing + this.topBarHeight + ((fret) - this.offset) * this.fretSpacing - this.circleRadius / 2; let circle = this.createSVGElement(__PRESERVED__32__, { cx: this.paddingLeft + string * this.stringSpacing, cy: position + this.topSpacing - 8, r: this.circleRadius, fill: this.color }); svg.appendChild(circle); if (this.fingerNumbers && this.fingerNumbers[string]) { const textPositionY = this.numberPosition === __PRESERVED__33__ ? position + this.topSpacing : this.topSpacing + this.topBarHeight + (this.fretCount + 1) * this.fretSpacing + this.stringOverflowBotom; const text = this.createSVGElement(__PRESERVED__34__, { x: this.paddingLeft + string * this.stringSpacing, y: textPositionY, __PRESERVED__35__: __PRESERVED__36__, __PRESERVED__37__: __PRESERVED__38__, __PRESERVED__39__: __PRESERVED__40__, fill: this.numberPosition === __PRESERVED__41__ ? this.textColor : this.color, __PRESERVED__42__: __PRESERVED__43__ }); text.textContent = this.fingerNumbers[string]; svg.appendChild(text); } } } } } drawMuteIndicators(svg) { const radius = 10 const height = radius * Math.sqrt(2) for (let i = 0; i < 6; i++) { if (this.fingerPositions[i] == -1) { const line1 = this.createSVGElement(__PRESERVED__44__, { x1: this.paddingLeft + i * this.stringSpacing - height / 2, y1: this.topSpacing - height - this.infoPadding, x2: this.paddingLeft + i * this.stringSpacing + height / 2, y2: this.topSpacing - this.infoPadding, stroke: this.color, __PRESERVED__45__: __PRESERVED__46__ }); const line2 = this.createSVGElement(__PRESERVED__47__, { x1: this.paddingLeft + i * this.stringSpacing - height / 2, y1: this.topSpacing - this.infoPadding, x2: this.paddingLeft + i * this.stringSpacing + height / 2, y2: this.topSpacing - height - this.infoPadding, stroke: this.color, __PRESERVED__48__: __PRESERVED__49__ }); svg.appendChild(line1); svg.appendChild(line2); } } } drawOpenStrings(svg) { for (let i = 0; i < 6; i++) { if (this.fingerPositions[i] === __PRESERVED__50__) { const circle = this.createSVGElement(__PRESERVED__51__, { cx: this.paddingLeft + i * this.stringSpacing, cy: this.topSpacing - this.infoPadding - this.openStringRadius, r: this.openStringRadius, fill: __PRESERVED__52__, stroke: this.color, __PRESERVED__53__: __PRESERVED__54__ }); svg.appendChild(circle); } } } drawBarre(svg, barreFret, barreStartString, barreEndString) { if (barreFret != 0) { barreFret = barreFret - this.offset const barreWidth = barreEndString - barreStartString const barreHeight = 10; const barreX = this.paddingLeft - this.barreSidesOverflow + barreStartString * this.stringSpacing; const barreY = barreFret * this.fretSpacing + this.topSpacing + this.topBarHeight + (this.fretSpacing / 2) - barreHeight / 2; const rect = this.createSVGElement('rect', { x: barreX, y: barreY, width: barreWidth * this.stringSpacing + 2 * this.barreSidesOverflow, height: barreHeight, rx: '5', ry: '5', fill: this.color }); svg.appendChild(rect); } } drawFretHeight(svg) { if (this.offset > 1) { const text = this.createSVGElement('text', { x:this.paddingLeft + this.stringSpacing*5 + this.infoPadding, y: this.topSpacing + this.topBarHeight + this.fretSpacing * 0.5, 'font-family': 'Arial', 'font-size': '20', fill: this.color, 'text-anchor': 'left', "alignment-baseline": "central" }); text.textContent = this.offset + "fr"; svg.appendChild(text); } } } export default TabGenerator;

